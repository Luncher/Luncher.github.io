{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"Golang Rust Nodejs GUI","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CSS-动画详解","text":"CSS动画详解CSS animation使用十分广泛，特此来做一个详细的总结。 通过transiton属性控制动画基本语法： transition: width 2s 1s ease; width属性受到动画影响，动画持续时间为2s，动画延迟1s播出，动画插值算法采用ease。多个属性可以用逗号分隔。例如：transition: width 2s, height 1s;。 transiton控制动画应该是最简单的方式之一了，和其他属性类似transiton也是一个复合属性由以下几个属性组成： transiton-delay: 动画延时播放，默认为0 transiton-timing-function: 动画插值函数,默认为ease transiton-property: 指明要发生变化的属性 transiton-duration: 指明动画周期(持续时间),默认为0 动画延时 看一个demo,子元素宽度从0到填充父控件，延时1s。 鼠标进入和离开控件的时候都有1s延迟,这就是transiton-delay的效果。 动画速度变更函数(插值函数) transiton-timing-function属性用于改变动画的速度曲线。可选值有： ease：默认参数 linear ease-in ease-out ease-in-out cubic-bezier 关于插值函数对应的效果可以看这里。 说说cubic-bezier,由于css内值动画曲线比较有限，所以可以根据cubic-bezier规划一条贝赛尔曲线。 推荐一个贝塞尔曲线在线编辑器：cubic-bezier。 动画属性顾名思义，设置受到动画影响的属性。如果所有属性都受到影响，可以指定一个all参数。需要注意的是，css规定一些属性不受transiton影响，例如：display等。具体看W3C上一个对应表。值得一提的是，display属性虽然不受影响，但是visibility属性会受影响。 动画持续时间设置动画延迟播放时间，注意默认为0，除了以s为单位，也可以以ms为单位。 transition属性虽然使用方便，但是也有它的局限性: 动画需要事件触发，无法自动播放 无法重复播放，除非一直触发 无法为多个属性指定同样的变化规则(写起来比较麻烦) 只能控制开始和结束状态、无法定义中间态 通过animation属性控制动画和transition类似，animation也是一个复合属性。它提供了比较多的属性来控制动画，从而实现更加细致的控制。 基本格式： @keyframes关键字用于定义动画的细节，比例动画名称，动画在某一时刻的状态属性值等。 1234@keyframes anim { from: {background: red;} to: {background: blue;}} 上面一段css定义了一个动画，名称为anim,动画从背景红色过渡到背景蓝色，from表示起始时刻动画状态，to表示结束时刻动画状态。还可以换成百分比的形式从0%到100%。从而实现了在不同时刻控制动画状态的目的。 基本属性： animation-duration animation-direction animation-delay animation-name animation-iteration-count animation-timing-function animation-play-state animation-fill-mode 动画时长animation-duration和transition-duration类似，不做过多介绍，用于控制动画的时间长度。 动画播放延时animation-delay和transition-delay类似控制动画首次播放的延时。 动画名称animation-name指定元素引用哪个动画，名称通过@keyframes指定。 动画方向animation-direction控制动画循环播放的时候状态的变更次序。看个demo: 可选的属性： normal: 每次都从起始状态变更到终止状态 reverse: 每次都从终止状态变更到起始状态 alternate: 奇数次从起始状态变更到结束状态、偶数次从结束状态变更到起始状态 alternate-reverse: 与alternate相反 动画结束的状态animation-fill-mode属性控制动画结束播放时候的状态，看个demo： forwards: 让动画停留在最后一帧 backwards: 让动画停留在第一帧 both: 根据animation-direction控制使用forwards或者backwards。 动画播放次数animation-iteration-count属性控制动画播放次数，默认为1次, 设置infinite表示无限循环播放。 动画插值函数animation-timing-function控制动画插值函数，和transition-timing-function类似。 控制动画状态animation-play-state属性用于控制动画播放的状态，默认情况，自动开始播放，通过设置该属性，可以控制动画播放。 看一个demo 只有鼠标移动到方块上的时候动画才会继续播放。 参考文献： CSS动画简介 W3C css animation","link":"/2016/09/30/CSS-%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/"},{"title":"Blob","text":"&nbsp;&nbsp;&nbsp;&nbsp;Blob(Binary Large Object)术语最初来自数据库，早期数据库因为要存储声音、图片、以及可执行程序等二进制数据对象所以给该类对象取名为Blob。&nbsp;&nbsp;&nbsp;&nbsp;在Web领域，Blob被定义为包含只读数据的类文件对象。Blob中的数据不一定是js原生数据形式。常见的File接口就继承自Blob，并扩展它用于支持用户系统的本地文件。 &nbsp;&nbsp;&nbsp;&nbsp;构建一个Blob对象通常有三种方式：1、通过Blob对象的构造函数来构建。2、从已有的Blob对象调用slice接口切出一个新的Blob对象。3、canvas API toBlob方法，把当前绘制信息转为一个Blob对象。下面分别看看3种方式的实现： –构造函数：var blob = new Blob(array[optional], options[optional]);&gt;array(可选): 一个数组。数组元素可以是：ArrayBuffer、ArrayBufferView、Blob、DOMString.或者他们的组合。options(可选): 一个对象。用于指定Blob对象的属性，可选的参数有： type: Content-Type,用于指定将要放入Blob中的数据的类型(MIME)。 Blob对象的基本属性：&gt;size : Blob对象包含的字节数。(只读)type : Blob对象包含的数据类型MIME，如果类型未知则返回空字符串。 Blob对象的基本方法：Blob.slice([start, [end, [content-type]]])&gt;slice方法与数组的slice类似。 – 原生对象构建Blob 123456&lt;script type=\"text/javascript\"&gt;window.onload = function() { var blob = new Blob(1234);}&lt;/script&gt; 提示出错： Uncaught TypeError: Failed to construct ‘Blob’: The 1st argument is neither an array, nor does it have indexed properties. 原因在于Blob构造函数要求第一个参数必须是数组，而这里第一个参数既不是一个数组，也没有可索引的属性。既然这里提到了对象的可索引属性，让我联想到了类数组的概念，而Arguments就是一个很好的例子。来试一试：12345678910&lt;script type=\"text/javascript\"&gt;function testArgumentsBlob() { var blob = new Blob(arguments); console.log(blob.size);//3 console.log(blob.type);//\"\"}window.onload = function() { testArgumentsBlob(1, 2, 3);}&lt;/script&gt;可以看到即使是类数组对象，而数组元素类型是Number也能得出正确的结论，猜想大概是由于构造函数内部把Number转化为String的缘故吧！ 再来试一试其他的参数类型：123456window.onload = function() { var arg = {hello: \"2016\"}; var blob = new Blob([JSON.stringify(arg, null, \"\\t\")], {type: \"application/json\"}); console.log(blob.type);//application/json console.log(blob.size);//20}blob.type等于application/json没问题。arg转为字符串后的长度为16加上制表符\\t的宽度4个字节等于20。 – 用slice切出一个Blob对象123456789window.onload = function() { var arg = {hello: \"2016\"}; var str = JSON.stringify(arg, null, \"\\t\"); var blob = new Blob([str], {type: \"application/json\"}); var blob2 = blob.slice(); console.log(blob2.size);//20 console.log(blob2.type);//\"\"}可以看到，原始的Blob对象的type属性并不能传递给新的Blob对象，所以还是要自己指定。 12345678window.onload = function() { var arg = {hello: \"2016\"}; var str = JSON.stringify(arg, null, \"\\t\"); var blob = new Blob([str], {type: \"application/json\"}); var blob2 = blob.slice(0, blob.size, \"application/json\"); console.log(blob2.size);//20 console.log(blob2.type);//application/json}canvas toBlob接口 函数原型： void canvas.toBlob(callback, type, encoderOptions); callback: 一个回调函数，新建的blob对象是唯一的参数` type: 图片格式，默认为image/png，默认dpi: 96 encoderOptions: 0~1之间的数值。当type为image/jpeg 或 image/webp的时候，用于指定图片质量 来个DEMO:12345678910111213window.onload = function() { var canvas = document.getElementById(\"main\"); canvas.toBlob(function(blob) { var img = document.createElement(\"img\"); var url = URL.createObjectURL(blob); img.onload = function() { URL.revokeObjectURL(url); } img.src = url; document.body.appendChild(img); });}&lt;/script&gt;得出错误： Uncaught TypeError: canvas.toBlob is not a function. 一开始觉得自己写错了，Google了下才发现Chrome居然不支持这个接口。给个polyfillCanvas toBlob。 – Blob基本运用 知道了Blob对象的基本属性，以及构建的方法，来看几个具体的运用。 – 利用Blob显示对象`12345678910var blob = new Blob([1, 2, 3]);var src = URL.createObjectURL(blob);console.log(src);//blob:http%3A//localhost%3A8003/a47ea163-c253-471a-9d9e-877fe345b60fvar img = document.createElement('img');img.onload = function() { URL.invokeObjectURL(img.src);}img.src = src;document.body.appendChild(img); 由于blob对象不是一个有效的文件，所以不能正常显示图片。上面的demo提到了一个URL.createObjectURL接口，顺便来学习以下： objectURL = URL.createObjectURL(blob); 主要用于根据一个Blob对象(或者File,因为File继承自Blob)，创建一个URL用于表示该对象。需要注意的是即使对同一个对象调用两次也会得到不同的URL。如果该URL不用了需要调用URL.invokeObjectURL来进行释放。浏览器会在当前document unloaded的时候自动把该URL释放。URL格式： blob:http%3A//localhost%3A8003/a47ea163-c253-471a-9d9e-877fe345b60f 最后来看一个正常点的DEMO，利用URL.createObjectURL读取本地图片文件，并创建缩略图。 – 利用Blob显示缩略图` 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 var input = document.createElement(\"input\"); input.type = \"file\"; input.accept = \"image/*\"; input.multiple = true; input.style.display = \"none\"; document.body.appendChild(input); var fileSelect = document.createElement(\"a\"); fileSelect.href = \"#\"; fileSelect.appendChild(document.createTextNode(\"Choose files\")); document.body.appendChild(fileSelect); var imgList = document.createElement(\"div\"); imgList.innerHTML = \"&lt;p&gt;No file Selected!&lt;/p&gt;\" document.body.appendChild(imgList); input.addEventListener(\"change\", function(e) { var files = this.files; if(!files.length) { return; } imgList.innerHTML = \"\"; var list = document.createElement(\"ul\"); imgList.appendChild(list); for(var i = 0; i &lt; files.length; i++) { var li = document.createElement(\"li\"); list.appendChild(li); var img = document.createElement(\"img\"); img.src = window.URL.createObjectURL(files[i]); img.height = 60; img.width = 60; img.onload = function() { window.URL.revokeObjectURL(this.src); } li.appendChild(img); var info = document.createElement(\"span\"); info.innerHTML = files[i].name + \":\" + files[i].size + \" bytes\"; li.appendChild(info); }}, false);fileSelect.addEventListener(\"click\", function(e) { input.click(); e.preventDefault();}, false); 由于File对象继承自Blob,所以我们可以很方便的利用File对象加载本地系统图片文件，并通过createObjectURL生成一个URL并加以显示。 参考文献： Blob Using_files_from_web","link":"/2016/10/02/Blob/"},{"title":"Base64","text":"&nbsp;&nbsp;&nbsp;&nbsp;说到Base64相信大家都不陌生，在web开发过程中经常可以见到它的身影。Base64是一种编码方式，常用于表示、传输、与存储二进制数据。用64个可打印字符来表示二进制数据，从而解决一些二进制数据无法使用的场景。Base64最初主要用户多用途互联网邮件扩展(MIME Email), MIME规定了用于表示各式各样数据(非英文符号数据)的符号化方法，而Base64编码就作为内容传输编码方式之一(charset)。http协议就是采用了MIME的框架。 &nbsp;&nbsp;&nbsp;&nbsp;由于2^6=64所以最经济的方式就是把6bit作为一个编码单元，对应一个可打印字符来完成编码工作。来看看Base64编码表： Base64编码规则： Base64编码的时候将三个byte的数据先后放入一个24bit的缓冲区中，先来的byte占高位。然后，每次取出6个bit参照编码码表得出编码。如果被编码字符的长度不能被3整除，那么就在编码输出的末尾补上=号。比如说，如果待编码的字符长度是4个字节，那么编码输出会有两个等号。如果待编码字符的长度是8个字节那么编码输出末尾会补上一个等号。如果待编码的比特位不足一个编码单元(6bit)的时候，则需要在低位补全。当最后剩余一个八位字节（一个byte）时，最后一个6位的base64字节块有四位是0值。 说到这里你可能已经想到编码后的数据比原始数据略长，为原来的4/3。下面来看看Base64编码的应用。 ###Canvas &nbsp;&nbsp;&nbsp;&nbsp;canvas有一个toDataURL接口用于把当前的canvas转换为data url数据格式的图片。 canvas.toDataURL(type, encoderOptions); type属性设置转换的图片格式，默认为image/png。 encoderOptions为一个数字范围从0-1，用于设置图片的质量。 dataURL格式定义： data:[mediatype][;base64], mediatype 为一个MIME格式定义的字符串，如image/jpeg表示jpeg图片。 base64字段表示后面的数据编码方式。 举个例子：123456789&lt;script type=\"text/javascript\"&gt;window.onload = function() { var canvas = document.getElementById('main-canvas'); var context = canvas.getContext('2d'); context.fillRect(0, 0, canvas.width, canvas.height); var dataURL = canvas.toDataURL(); console.log(dataURL);}&lt;/script&gt; 将会得到如下输出:1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAALQCAYAAABIRqOlAAAc9UlEQ…AAgUBAgAN0kwQIECBAQID9AAECBAgQCAQEOEA3SYAAAQIELrSX0B9Umz4MAAAAAElFTkSuQmCC 此外，linux/mac系统有一个命令行工具: uuencode可以把文件转换成Base64格式输出, 先把当前的canvas另存为一个图片，然后运行命令行程序可以得到如下结论，与toDataURL结果一致： 12345678[luncher@localhost ~]$ uuencode -m 123.png 123-base begin-base64 640 123-baseiVBORw0KGgoAAAANSUhEUgAAAeAAAALQCAYAAABIRqOlAAAc9UlEQVR4Xu3VwQkAMAzEsGT/oVvoEPVHWeBABLwzc8YRIECAAAECXwVWgL96GyNAgAABAk9AgD0CAQIECBAIBAQ4QDdJgAABAgQE2A8QIECAAIFAQIADdJMECBAgQECA/QABAgQIEAgEBDhAN0mAAAECBATYDxAgQIAAgUBAgAN0kwQIECBAQID9AAECBAgQCAQEOEA3SYAAAQIEBNgPECBAgACBQECAA3STBAgQIEBAgP0AAQIECBAIBAQ4QDdJgAABAgQE2A8QIECAAIFAQIADdJMECBAgQECA/QABAgQIEAgEBDhAN0mA","link":"/2016/03/07/Base64/"},{"title":"CSSMastery读书笔记三-可视化格式模型","text":"可视化格式模型 盒模型概念 内容区域、边框、内边距、外边距 全局reset可能会造成一定的副作用(对option等元素). 外边距离叠加 外边距叠加一般指的是垂直外边距 一个元素出现在另一个元素上面时会发生叠加 一个元素包含在另一个元素中时会发生叠加 如果两个外边距都是负，浏览器取绝对值比较大的那个数 如果一正一负，浏览器会用正外边距减去负外边距的绝对值 行内框、浮动定位、和绝对定位元素之间的外边距不会叠加 定位概述可视化格式模型 见css视觉格式化 相对定位 元素还处于文档流中，相对于元素本来位置定位。 无论是否移动，元素仍然占据原来的框，这会导致覆盖其他元素。 绝对定位 元素不属于文档流，相对于父级已定位元素定位，如果没有就相对于包含块定位(canvas或者html元素) 固定定位 是绝对定位的一种相对于viewport定位。 浮动浮动元素不属于文档流，所以普通文档流的块框表现的好像浮动框不存在。 1、浮动框旁边的文档流元素会围绕浮动框 2、普通块框要包含浮动框，需要对浮动清理、或者把包含块也浮动 3、常见的清理浮动的方式： 1234567.clear:after { content: '.'; height: 0; visibility: none; display: block; clear: both;}","link":"/2016/08/22/CSSMastery%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/"},{"title":"CSSMastery读书笔记(一)","text":"基础知识 1、语义化编程 html每个标签都有特殊含义，不建议混乱使用标签，这样有利于搜索引擎抓取页面信息，以及更好的维护代码。 2、HTML4和HTML5 html4提供了一些简单的文档标记元素，而html5在此基础之上提供更多的元素如：header、nav等，满足web页面的UI特性。 3、元素类以及id 类命名应该根据元素是什么而不是元素的外观来命名、类名和id区分大小写，最好的方式是使用连接符号把单词分隔。 4、多类症以及多div症 应该谨慎的使用类名、例如一些元素的样式可以通过使用选择器来设置，而不用为每个元素都设置一个类。div元素的语义表示一个区域、一块。对于一些不需要div包装的元素则不应该使用div，譬如说：nav元素构建一个导航条，里面多个li元素构成的条目，此时不需要用div来把nav包装起来。 5、微格式 微格式解决了html元素不能表示特定信息的缺点：如日期等。 6、html与xhtml 1999发布了html4.01而对应的xml版本为xhtml1.0,两个差异在于 xml元素属性必须用引号包裹 xml元素必须封闭 7、DOCTYPE的作用 web页面都会有一个DOCTYPE声明，浏览器根据其来了解使用哪个版本的DTD来解析页面，由此也知道使用的是哪个版本的html。DTD又分为严格模式和过渡模式，严格模式不允许使用已经废弃的元素如font等，而过渡模式有助于引导开发者过渡到新版本的html。总结一下DOCTYPE声明的作用： 浏览器验证页面的有效性 浏览器模式切换(标准/混杂)实现向后兼容","link":"/2016/08/20/CSSMastery%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"ES6 CheatSheet(一)","text":"在线连接: ES6 CheatSheet","link":"/2017/05/03/ES6%20CheatSheet(%E4%B8%80)/"},{"title":"CSSMastery读书笔记二-为样式找到应用目标","text":"为样式找到应用目标 常用的选择器元素选择器 body 后代选择器 nav li中间有空格 伪类 链接伪类：link、visited 动态伪类：hover、active、focus、first-child、lang 伪元素 before after first-letter first-line 伪类与伪元素的区别伪类：对某些选择器添加特殊样式.伪元素：同于将特殊效果添加到某些选择器.伪类前面有一个冒号，伪元素前面有两个冒号. 通用选择器(*) 通配符匹配所有元素 对所有后代或者跳过某一级别设置样式 高级选择器子元素选择器 nav&gt;li中间可以有空格 兄弟选择器 h2+p中间可以有空格 属性选择器 根据属性是否存在span[title]:对存在title属性的span元素设置属性 根据属性值 span[title='foo']: 完全等于 span[title~='foo']:分词匹配 span[title^='foo']:以foo开头 span[title$='foo']:以foo结尾 span[title*='foo']:通配存在字符foo 层叠和样式层叠的重要性排序 持有!important的用户样式 持有!important的作者样式 作者样式 用户样式 浏览器默认样式 样式特殊性规则a、b、c、d四个权重 内联样式： 1 0 0 0 id选择器： 0 1 0 0 类、伪类、属性选择器： 0 0 1 0 类型选择器、元素选择器： 0 0 0 1 由于继承而来的样式的特殊性为0，所以直接应用于元素的任何样式都会覆盖继承而来的样式。 特殊性使用规则： 一般样式非常一般、特殊样式尽可能特殊 规划组织可维护的样式表对文档应用样式的方式： 导入样式(import) 链接样式(link元素) 一个好的样式文档结构： 1、一般性样式 主体 reset 链接 标题 其他元素 2、辅助样式 表单 通知和错误 页面结构 一致的条目 3、页面结构 标题、页脚和导航 布局 其他页面结构元素 4、页面组件 各个页面 5、覆盖 一些好的实践 文件开头放置一些常用的预定义：如颜色值 利用cssDoc注释css","link":"/2016/08/21/CSSMastery%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C%E4%B8%BA-%E6%A0%B7%E5%BC%8F%E6%89%BE%E5%88%B0%E5%BA%94%E7%94%A8%E7%9B%AE%E6%A0%87/"},{"title":"ES6 CheatSheet(二)","text":"在线连接: ES6 CheatSheet","link":"/2017/07/10/ES6%20CheatSheet(%E4%BA%8C)/"},{"title":"ES6 属性遍历","text":"在线连接: ES6 Property iter CheatSheet","link":"/2017/06/15/ES6%20%E5%B1%9E%E6%80%A7%E9%81%8D%E5%8E%86/"},{"title":"Golang几种依赖注入的实现","text":"依赖注入的作用 依赖注入是一个业界标准技术，用于解决复杂应用状态下模块之间依赖的问题。有了依赖注入，不需要再写很多按照依赖顺序而编写的初始化代码。在没有使用依赖注入的前提下，在升级重构一个模块的时候是相当痛苦的，因为这意味着需要在项目依赖图里面把所有该模块涉及的一整套依赖关系重新构建。简而言之，依赖注入主要目的只有一个：旨在简化初始化代码的管理。 go语言社区有很多依赖注入的框架，可以分为两个类别： 依赖反射实现的运行时依赖注入 使用代码生成实现的依赖注入 依赖反射实现的运行时依赖注入运行时依赖注入目前使用比较广泛的主要有：facebook inject、uber dig。 facebook inject12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( \"fmt\" \"github.com/facebookgo/inject\" \"net/http\" \"os\")type HomePlanetRenderApp struct { NameAPI *NameAPI `inject:\"\"` PlanetAPI *PlanetAPI `inject:\"\"`}func (a *HomePlanetRenderApp) Render(id uint64) string { return fmt.Sprintf(\"%s is from the planet %s.\", a.NameAPI.Name(id), a.PlanetAPI.Planet(id))}type NameAPI struct { HTTPTransport http.RoundTripper `inject:\"\"`}func (n *NameAPI) Name(id uint64) string { return \"Spock\"}type PlanetAPI struct { HTTPTransport http.RoundTripper `inject:\"\"`}func (p *PlanetAPI) Planet(id uint64) string { return \"Vulcan\"}func main() { var g inject.Graph var app HomePlanetRenderApp err := g.Provide(&amp;inject.Object{Value: &amp;app}, &amp;inject.Object{Value: http.DefaultTransport}) if err != nil { fmt.Fprintln(os.Stderr, err) os.Exit(1) } if err := g.Populate(); err != nil { fmt.Fprintln(os.Stderr, err) os.Exit(1) } fmt.Println(app.Render(42))} var g inject.Graph一个项目会有一个对象依赖图。app是一个需要被注入的对象。因为PlanetAPI和NameAPI都依赖http.RoundTripper这个接口，所以也需要注入一个transport实现。调用g.Populate完成创建对象，把DefaultTransport填充到PlanetAPI和NameAPI的行为。执行完Populate之后就可以正常使用app对象了。这里还有个问题，如果PlanetAPI和NameAPI需要依赖不同的transport怎么办呢？ facebook inject提供了named dependency解决这个问题。 123456789101112131415type NameAPI struct { HTTPTransport http.RoundTripper `inject:\"name-transport\"`}type PlanetAPI struct { HTTPTransport http.RoundTripper `inject:\"planet-transport\"`}...err := g.Provide( &amp;inject.Object{Value: &amp;app}, &amp;inject.Object{Value: http.DefaultTransport, Name: \"planet-transport\"}, &amp;inject.Object{Value: http.DefaultTransport, Name: \"name-transport\"},)... uber dig12345678910111213141516171819202122232425262728293031type Config struct { Prefix string}func main() { c := dig.New() err := c.Provide(func() (*Config, error) { var cfg Config err := json.Unmarshal([]byte(`{\"prefix\": \"[foo] \"}`), &amp;cfg) return &amp;cfg, err }) if err != nil { panic(err) } err = c.Provide(func(cfg *Config) *log.Logger { return log.New(os.Stdout, cfg.Prefix, 0) }) if err != nil { panic(err) } err = c.Invoke(func(l *log.Logger) { l.Print(\"You've been invoked\") }) if err != nil { panic(err) }} 和facebook inject类似，c := dig.New()创建一个实例，在这个实例上执行Provide注入对象构造器。Invoke依赖注入的构造器创建一个用户希望得到的对象。 使用代码生成实现的依赖注入google wire先看一个最传统的实现：123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"type Message stringfunc NewMessage() Message { return Message(\"Hi there!\")}type Gretter struct { Message Message}func NewGretter(m Message) Gretter { return Gretter{m}}func (g Gretter) Greet() Message { return g.Message}type Event struct { Gretter Gretter}func NewEvent(g Gretter) Event { return Event{Gretter: g}}func (e Event) Start() { msg := e.Gretter.Greet() fmt.Println(msg)}func main() { message := NewMessage() gretter := NewGretter(message) event := NewEvent(gretter) event.Start()} 使用wire重构： 12345678910func InitializeEvent() Event { wire.Build(NewEvent, NewGretter, NewMessage) return Event{}}func main() { event := InitializeEvent() event.Start()} 这样就简化了初始化对象模块的代码，一目了然。","link":"/2018/12/26/Golang%E5%87%A0%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"HTTP知识图谱","text":"在线文档链接：http-cheatsheet 参考文档： MDN HTTP Caching Tutorial HTTP缓存控制小结 HTTP协议之响应头Date与Age","link":"/2018/06/15/HTTP%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"title":"linux输入设备抽象","text":"最近在些GUI程序，之前也写过一些。长久以来一直对其中一些问题有些好奇，如：鼠标事件和键盘事件是如何获取如何引入程序的，GUI底层绘制操作又是怎么实现的。最近花了点事件学习了下其底层的实现，在这里做个笔记。 LINUX下输入设备放在/dev/input/下，我的电脑该目录内容为： 12345lc@lc-Lenovo:~/work/sources$ cd /dev/input/lc@lc-Lenovo:/dev/input$ lsby-id event0 event10 event3 event5 event7 event9 mouse0by-path event1 event2 event4 event6 event8 mice 这么多设备我们需要知道哪个设备对应鼠标哪个对应键盘，可以查看文件/proc/bus/input/devices，我的电脑下该文件鼠标和键盘相关信息为： 1234567891011121314151617181920212223I: Bus=0011 Vendor=0001 Product=0001 Version=ab41N: Name=\"AT Translated Set 2 keyboard\"P: Phys=isa0060/serio0/input0S: Sysfs=/devices/platform/i8042/serio0/input/input2U: Uniq=H: Handlers=sysrq kbd event2 B: PROP=0B: EV=120013B: KEY=4 2000000 3803078 f800d001 feffffdf ffefffff ffffffff fffffffeB: MSC=10B: LED=7I: Bus=0003 Vendor=17ef Product=6019 Version=0111N: Name=\"Logitech Lenovo USB Optical Mouse\"P: Phys=usb-0000:00:1d.0-1.4/input0S: Sysfs=/devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.4/2-1.4:1.0/input/input3U: Uniq=H: Handlers=mouse0 event3 B: PROP=0B: EV=17B: KEY=70000 0 0 0 0 0 0 0 0B: REL=103B: MSC=10 可以看到鼠标对应的是event3键盘对应的是event2。 LINUX下每个设备都有一个ID，如果想监视一个设备的行为需要获取该设备句柄，然后交给SELECT或则epoll即可，对于输入设备也是一样。当SELECT循环检测到输入设备有数据可以读取的时候，调用相关接口获取输入设备信息再进一步分发判断具体的事件类型即可。LINUX下相关的数据结构为： 1234567struct input_event { struct timeval time; //事件发生的时间 __u16 type; //事件类型 __u16 code; //事件的代码 __s32 value; //事件附带值}; 该结构体定义在linux/input.h文件下。time表示事件发生的时间戳，type标识事件类型，主要的事件类型有： 123456789101112131415161718/* * Event types */#define EV_SYN 0x00#define EV_KEY 0x01 //键盘事件#define EV_REL 0x02 //相对坐标#define EV_ABS 0x03 //绝对坐标#define EV_MSC 0x04#define EV_SW 0x05#define EV_LED 0x11#define EV_SND 0x12#define EV_REP 0x14#define EV_FF 0x15#define EV_PWR 0x16#define EV_FF_STATUS 0x17#define EV_MAX 0x1f#define EV_CNT (EV_MAX+1) 当type等于EV_KEY时，code的值为KEY_0,1,2…键盘上的按键，比较特殊的是，鼠标左键右键中间按下时键值分别为：BTN_LEFT/BTN_RIGHT/BTN_MIDDLE。EV_ABS表示绝对坐标事件，主要用于标识触摸屏下的用户触摸(touch)事件。此时事件代码code的值可能有ABS_X和ABS_Y两个，分别表示X轴坐标和Y轴坐标。如果事件的类型代码是EV_REL,code值表示轨迹的类型.如指示鼠标的X轴方向REL_X(代码为0x00),指示鼠标的Y轴方向REL_Y(代码为0x01),指示鼠标中轮子方向REL_WHEEL(代码为0x08）等。EV_SYN用于分割事件的一个标记，比如，鼠标按下会受到一个EV_KEY事件，紧接着就是一个EV_SYN事件，鼠标提起的时候也类似。 输入事件分发示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121static RET_E source_input_dispatch(EVENT_SOURCE_T* pstThiz){ int nRet = 0; DECL_PRIV(pstThiz, priv); struct input_event ievent; static int nCount = 0; nRet = read(priv-&gt;fd, &amp;ievent, sizeof(ievent)); if(nRet != sizeof(ievent)) { return; } switch(ievent.type) { case EV_KEY: { if(ievent.code == BTN_LEFT) { printf(\"EV_KEY BTN_LEFT click\\n\"); } else if(ievent.code == BTN_RIGHT) { printf(\"EV_KEY BTN_RIGHT click\\n\"); } else if(ievent.code == BTN_MIDDLE) { printf(\"EV_KEY BTN_MIDDLE click\\n\"); } else if(ievent.code == BTN_TOUCH) { printf(\"EV_KEY BTN_TOUCH click\\n\"); } if(ievent.code == BTN_LEFT || ievent.code == BTN_RIGHT || ievent.code == BTN_MIDDLE || ievent.code == BTN_TOUCH) { priv-&gt;stEvent.eType = ievent.value ? EVT_MOUSE_DOWN : EVT_MOUSE_UP; } else { priv-&gt;stEvent.eType = ievent.value ? EVT_KEY_DOWN : EVT_KEY_UP; priv-&gt;stEvent.u.key.nCode = key_map(pstThiz, ievent.code); printf(\"EVENT key code :%d\\n\", priv-&gt;stEvent.u.key.nCode); } break; } case EV_ABS: { switch(ievent.code) { case ABS_X: { printf(\"EV_ABS ABS_X value :%d\\n\", priv-&gt;x); priv-&gt;x = ievent.value; break; } case ABS_Y: { printf(\"EV_ABS ABS_Y value :%d\\n\", priv-&gt;y); priv-&gt;y = ievent.value; break; } default: { break; } } if(priv-&gt;stEvent.eType == EVT_NOP) { printf(\"EV_ABS mouse move \\n\"); priv-&gt;stEvent.eType = EVT_MOUSE_MOVE; } break; } case EV_REL: { switch(ievent.code) { case REL_X: { priv-&gt;x += ievent.value; printf(\"EV_REL REL_X value :%d\\n\", priv-&gt;x); break; } case REL_Y: { priv-&gt;y += ievent.value; printf(\"EV_REL REL_X value :%d\\n\", priv-&gt;y); break; } default:break; } if(priv-&gt;stEvent.eType == EVT_NOP) { priv-&gt;stEvent.eType = EVT_MOUSE_MOVE; printf(\"EV_REL mouse move\\n\"); } break; } case EV_SYN: { if(priv-&gt;stEvent.eType == EVT_MOUSE_DOWN) { printf(\"EV_SYN mouse down\\n\"); } else if(priv-&gt;stEvent.eType == EVT_MOUSE_UP) { printf(\"EV_SYN mouse up\\n\"); } else if(priv-&gt;stEvent.eType == EVT_MOUSE_MOVE) { printf(\"EV_SYN mouse move\\n\"); } break; } default:break; } return (RET_OK);} 鼠标左键按下提起事件捕获： 其他事件效果也是类似。","link":"/2013/10/21/LINUX%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1/"},{"title":"MobX知识图谱","text":"在线连接: MobX-知识图谱","link":"/2019/02/23/MobX%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"title":"MobX-依赖注入","text":"定义MobX基于React的Context机制，提供了依赖注入的语法来实现跨组件层级的数据注入功能。这项功能在要往子组件传递数据，但是不知道具体有多少层级的时候，相当有用。 inject用在目标组件上，设置依赖的store。Provider是一个HOC，用它包装现有的组件，为子组件传递数据。 使用方式基本用法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354type UserStore = { name: string, age: number}interface IMessageProps { text: string userStore?: UserStore}interface ImessageInjectProps extends IMessageProps { userStore: UserStore}@inject(&quot;userStore&quot;)class Message extends Component&lt;IMessageProps&gt; { render() { const { userStore } = this.props return ( &lt;div&gt; {userStore &amp;&amp; userStore.name}: &lt;strong&gt;{this.props.text}&lt;/strong&gt; &lt;/div&gt; ) }}interface IMessageListProps { messages: IMessageProps[]}class MessageList extends Component&lt;IMessageListProps&gt; { render() { return ( this.props.messages.map(it =&gt; &lt;Message key={it.text} text={it.text} /&gt;) ) }}class App extends Component { render() { return ( &lt;Provider userStore={{ name: &quot;linchen&quot;, age: 30 }}&gt; &lt;MessageList messages={[{ text: &quot;hello&quot;}, { text: &quot;foo&quot;}, { text: &quot;bar&quot;}]} /&gt; &lt;/Provider&gt; ) }} ts类型安全的依赖注入Message组件依赖userStore，userStore从App组件注入。整个应用程序能够正常工作。但是这里存在一个问题：Message的父组件MessageList并不需要知道userStore的存在，所以在定义Message的props类型的时候，把userStore设置为可选的参数。这也导致了，Message组件在使用userStore的时候，需要判断是否为空的情况。尽管我们知道，这里的userStore是必须存在的参数。 一种更好的方式： 123456789101112131415161718192021interface ImessageInjectProps extends IMessageProps { userStore: UserStore}@inject(&quot;userStore&quot;)class Message extends Component&lt;IMessageProps&gt; { get InjectedProps() { return this.props as ImessageInjectProps } render() { const { userStore } = this.InjectedProps return ( &lt;div&gt; {userStore.name}: &lt;strong&gt;{this.props.text}&lt;/strong&gt; &lt;/div&gt; ) }} 定义一个ImessageInjectProps类型，继承IMessageProps。在使用的时候强制转换为ImessageInjectProps类型。同时享受了ts强大的类型系统带来的便利性。 参考文档：How to get typesafe injectionstrongly-typing-injected-react-props","link":"/2019/02/24/MobX-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"},{"title":"Linux下SSH操作解析","text":"1.查看SSH状态：service sshd status 查看ssh是否已经启动以及一些状态信息 2.启动SSH服务：systemctl restart sshd.service ps:fedora下的一些基本服务都是通过systemctl restart/stop xxx.service操作来控制的，例如apache的服务器：httpd.service、防火墙服务firewalld.service等。 3.SSH配置文件路径：/etc/ssh/sshd_config。配置ssh连接的端口号，权限等信息 4.关闭防火墙systemctl disable firewalld.service 把防火墙整个关闭不太合适，使用下面的命令比较好一些： 5.将端口22（或者自定义的其他端口）加到防火墙的设置中，标记为Acceptiptables -A INPUT -p tcp –dport 22 -j ACCEPT 查看ssh的配置文件可以看到默认端口号是22，所以在防火墙解除屏蔽 6.防火墙配置文件路径：/etc/sysconfig/iptables SSH组件的一些基本操作： 首先登录远程服务器： ssh user@192.168.1.28 user表示远程服务器的用户名，这里需要输入密码。 利用scp进行文件操作： 文件上传：scp -r /home/xxx user@192.168.1.28:/home/xxx 文件下载：和文件上传的路径对调下就OK了。 利用sftp进行文件上传和下载： sftp和ftp工具操作类似，便于目录资源的管理。 登录： 格式：sftp -oPort= @通过sftp连接，端口为，用户为。 sftp连接成功之后常用操作命令如下：help/? 打印帮助信息。 123456789101112131415161718192021222324252627282930313233343536pwd 查看远程服务器当前目录；lpwd 查看本地系统的当前目录。cd &lt;dir&gt; 将远程服务器的当前目录更改为&lt;dir&gt;lcd &lt;dir&gt; 将本地系统的当前目录更改为&lt;dir&gt;。ls 显示远程服务器上当前目录的文件名；ls -l 显示远程服务器上当前目录的文件详细列表ls &lt;pattern&gt; 显示远程服务器上符合指定模式&lt;pattern&gt;的文件名；ls -l &lt;pattern&gt; 显示远程服务器上符合指定模式&lt;pattern&gt;的文件详细列表。lls 显示本地系统上当前目录的文件名；lls的其他参数与ls命令的类似。get &lt;file&gt; 下载指定文件&lt;file&gt;；get &lt;pattern&gt; 下载符合指定模式&lt;pattern&gt;的文件。put &lt;file&gt; 上传指定文件&lt;file&gt;； get &lt;pattern&gt; 上传符合指定模式&lt;pattern&gt;的文件。 progress 切换是否显示文件传输进度。mkdir &lt;dir&gt; 在远程服务器上创建目录； lmkdir &lt;dir&gt; 在本地系统上创建目录。 exit/quit/bye 退出sftp。 ! 启动一个本地shell。 ! &lt;commandline&gt; 执行本地命令行。其他命令还有：chgrp, chmod, chown, ln, lumask, rename, rm, rmdir, symlink, version。谨记：在sftp模式下对本地文件的操作前面会多一个'l' 免密码登陆： ssh提供了一套密钥对验证机制，把公钥文件上传服务器，并导入公钥库文件。这样客户端在以后不用输入密码可以登陆了。 一、生成密钥文件：123456789101112131415161718192021[luncher@localhost test]$ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/home/luncher/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/luncher/.ssh/id_rsa.Your public key has been saved in /home/luncher/.ssh/id_rsa.pub.The key fingerprint is:9e:39:ec:d8:fa:46:02:6a:d1:36:b9:83:04:75:95:b9 luncher@localhost.localdomainThe key's randomart image is:+--[ RSA 2048]----+| .. ...o ||. . o || . . . . || o * E || . = + S || + o .o.o || . . o* || +.. || o++ |+-----------------+ 二、利用scp命令把公钥拷贝到服务器1234[luncher@localhost test]$ scp /home/luncher/.ssh/id_rsa.pub luncher@192.168.1.17:/tmpid_rsa.pub 100% 411 0.4KB/s 00:00 [luncher@localhost test]$ 三、在服务器端把公钥导入验证key文件1cat /tmp/id_rsa.pub /home/luncher/.ssh/authorized_keys 四、用ssh-agent和ssh-add管理密钥ssh-agent是用于管理密钥，ssh-add用于将密钥加入到ssh-agent中，SSH可以和ssh-agent通信获取密钥，这样就不需要用户手工输入密码了。 End~","link":"/2015/01/13/Linux%E4%B8%8BSSH%E6%93%8D%E4%BD%9C%E8%A7%A3%E6%9E%90/"},{"title":"Quill编辑器添加自定义插件","text":"在前端领域，富文本编辑器一直是一个比较复杂的模块。技术选型的时候，如果没有擦亮眼睛看清楚，一不小心就掉入的坑中。之前用过summernote最后因为业务需求逐渐复杂，一些关键特性没法支持，自己拓展起来非常痛苦。这次新项目开发的时候仔细调研了下当下比较好的web富文本编辑器主要有：Quill，以及国内百度前端团队推出的ueditor。经过一番对比之后，选择了Quill作为最终方案。 Quill实现了一套类似的DOM Tree。通过parchment来实现。一颗parchment Tree包含了多个Blot，可以类比为DOM节点的概念。parchment提供了三种类型的Blot: Inline Blot、 Block Blot、Embed Blot。前两种分别对应html的行内元素、块元素，第三种类型是一个封装类型，Quill内置类型如：Video通过继承这个类型来实现。 Quill默认没有提供audio类型的实现。所以通过扩展Embed Blot来实现一个。 导入模块12345import { Quill } from 'vue-quill-editor'const BlockEmbed = Quill.import('blots/block/embed')const Link = Quill.import('formats/link') Quill内置的模块只能通过Quill.import函数导入。 创建对象12345678910111213export default class Audio extends BlockEmbed { static create (value) { let node = super.create(value) node.setAttribute('controls', 'controls') node.setAttribute('src', this.sanitize(value)) return node } static sanitize (url) { return Link.sanitize(url) } ... create由Quill负责调用value表示创建的对象的参数。这里audio只需要一个音频文件url参数。默认给音频文件添加控制按钮，如果有其他属性需要设置的可以在这里添加。 获取节点值 123static value (domNode) { return domNode.getAttribute('src')} 节点属性变更 123456789101112131415161718192021222324252627const ATTRIBUTES = [ 'height', 'width']//... //获取属性列表 static formats (domNode) { return ATTRIBUTES.reduce(function (formats, attribute) { if (domNode.hasAttribute(attribute)) { formats[attribute] = domNode.getAttribute(attribute) } return formats }, {}) }//... //设置属性 format (name, value) { if (ATTRIBUTES.indexOf(name) &gt; -1) { if (value) { this.domNode.setAttribute(name, value) } else { this.domNode.removeAttribute(name) } } else { super.format(name, value) } } 标示节点并注册 12345Audio.blotName = 'audio'Audio.tagName = 'audio'Quill.register(Audio) blotName必须唯一，tagName指定该Blot对应的DOM节点类型。如果该节点已经被其他Blot使用了，则比较添加一个className加以区分。 自定义Blot使用 12345678910111213141516&lt;span class=\"ql-formats\"&gt; &lt;qiniu-uploader @input=\"getQiniuUrl\" iconType=\"audio\"&gt;&lt;/qiniu-uploader&gt;&lt;/span&gt;&lt;!-- qiniu-uploader 组件实现--&gt;&lt;template&gt; &lt;!-- ... --&gt; &lt;div&gt; &lt;svg viewbox=\"0 0 18 18\" v-if=\"iconType === 'audio'\"&gt; &lt;ellipse class=\"ql-fill\" cx=\"10.5\" cy=\"14\" rx=\"2.5\" ry=\"2\"/&gt; &lt;path class=\"ql-stroke\" d=\"M12,14V3c0,1.5,3,2.021,3,5\"/&gt; &lt;path class=\"ql-fill\" d=\"M7,4A5,5,0,0,0,7,14a3.191,3.191,0,0,1,3-2.957V5.023A4.955,4.955,0,0,0,7,4ZM4.06,8.412a0.5,0.5,0,0,1-.49.4,0.485,0.485,0,0,1-.1-0.01,0.5,0.5,0,0,1-.393-0.588A3.98,3.98,0,0,1,6.216,5.079a0.5,0.5,0,0,1,.2.98A2.985,2.985,0,0,0,4.06,8.412ZM7,10A1,1,0,1,1,8,9,1,1,0,0,1,7,10Z\"/&gt; &lt;/svg&gt; &lt;/div&gt; &lt;!-- ... --&gt; 因为使用的是Vue框架，在toolbar注入控制按钮，当然也可以通过formats选项，在创建quill的时候指定需要在工具栏出现哪些控制按钮。组件内提供一个iconType控制上传文件类型。这里使用svg方式绘制图标，这个图标可以通过Quill官方找到。 注入节点 12345getQiniuUrl ({ url, type }) { this.editor.focus() this.editor.insertEmbed(this.editor.getSelection().index, type, url)} this.editor 表示quill实例对象，type这里传的是audio，和blotName一一对应。这段代码的含义表示：在当前编辑器光标位置插入一个音频文件节点。 参考文档:https://quilljs.com/guides/cloning-medium-with-parchment/https://dev.to/charrondev/getting-to-know-quilljs---part-1-parchment-blots-and-lifecycle--3e76","link":"/2018/06/02/Quill%E7%BC%96%E8%BE%91%E5%99%A8%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/"},{"title":"React Hooks Tutorial","text":"Hooks的定义 Hook是一个函数，在不创建类的前提下，使用React state以及React的其他特性。 为什引入Hooks 状态相关的逻辑难以重用、测试 复杂组件难以理解，嵌套过深(需要引入HOC、render props等概念) 类相比函数更加难以理解 Hooks详解state hooks 给函数组件提供state特性。 state hook通过replace的方式更新数据而不是merge state值会在多次执行的时候保持 effect hooks hooks会对其他组件产生副作用，并且不能在渲染的时候执行。提供统一的API，提供和类组件的componentDidMount、componentDidUpdate、componentWillMount一样的功能。 每次渲染之后都执行某一项操作(包含初始化和更新操作) 每次渲染之前会执行清理函数(如果有的话) side effect 操纵类型： 修改DOM 接口获取数据 状态订阅操作 分类： 不需要清理的effect 需要清理的effect useEffect返回一个清理函数,在运行下一次渲染之前执行清理函数。 总结 使用多个useEffect组件分离关注点 按照state和effect分离关注点。尽可能解耦 为什么要在每次Update的时候运行effect函数 避免在数据变更componentDidUpdate的时候，由于资源没有释放导致的BUG问题。 优化性能跳过不必要的useEffect执行 useEffect第二个参数由于比较，如果两次执行的时候第二个参数相同则不会执行useEffect内的函数。如果传递的是一个空数组，那么只会执行一次。 Hooks规则 只能在函数组件内使用 只能在函数组件内顶层作用域使用 原因： React 依赖于hook的执行顺序来对照state和useState, 以及effect function。这样在function component反复执行的时候才不会出错。 构建自己的组件 解决HOC、render props同样的问题，但是不引入新的组件。 hook使用use开头，函数内可能会调用其他hook。","link":"/2019/03/13/React-Hooks-Tutorial/"},{"title":"SVG学习笔记","text":"SVG是什么 SVG意为可缩放的矢量图形，采用XML语言格式来标记图像信息。最新版本为1.1。 SVG基本作用 用于绘制图形以及文字，支持旋转、滤镜、裁剪、渐变等效果。 基本属性及语法 html文档嵌入svg 对于新的html5标准可以直接在html文档内嵌入 使用其他元素嵌入：&lt;object data=&quot;image.svg&quot; type=&quot;image/svg+xml&quot; /&gt; 语法规范 SVG元素属性区分大小写(和html不同) SVG元素属性值必须用双引号引起来 基本使用坐标系统 类似于canvas，可以通过viewBox定义用户坐标系统, 达到缩放的结果。例如： 1&lt;svg width=\"200\" height=\"200\" viewBox=\"0 0 100 100\"&gt; 这里定义了视口(viewport)大小为: 200*200, viewBox属性定义了画布上可以显示区域，这个区域会放大到画布200*200上显示。这里可以类比canvas里面类似的概念，canvas里面通过style属性定义的宽高为显示区域，用户坐标系统，直接给canvas元素设置的宽高为视口大小。既然有缩放，就得控制缩放比例，以及对齐方式。 preserveAspectRatio属性用于定义viewBox相对于viewport对齐方式以及缩放属性： preserveAspectRatio=”xMidYMid meet”,意味着把viewBox的中心相对于viewport中心对齐，同时保持纵横比缩放viewBox适应viewport。其实这也就是默认值。 preserveAspectRatio前半部分参数： xMin|xMid|xMax YMin|YMid|YMax preserveAspectRatio后半部分对齐方式： meet:保持viewBox的纵横比，让viewBox在viewport内完全显示。 slice:保持viewBox的纵横比，用viewBox最大化填充viewport。 none: 水平和垂直都拉申填充viewport。 SVG-Demo,下载后可以直接编辑并用SVG查看器打开查看。 绘制图形 SVG包含内值基本元素,可以直接绘制基本图形例如：rect、circle等。还可以以类似于canvas路径的形式绘制图像：强大的路径支持绘制任意的元素。 着色 着色类似于canvas分为填充与描边。通过设置fill于stroke属性控制颜色，fill-opacity和stroke-opacity控制透明度,以及一些其他属性控制描边的风格。 参考MDN-SVGMDN-SVG Tutorial理解SVG的viewport,viewBox","link":"/2016/12/01/SVG%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"React知识图谱","text":"在线连接: React-知识图谱","link":"/2019/03/04/React%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"title":"CSS-background","text":"CSSbackground属性总结基本属性 background-color background-image background-size background-position background-origin background-attachment background-clip background-color顾名思义background-color用于设置元素的背景颜色,这应该是最好理解的属性之一了。但是有几点需要注意： 1、背景颜色涵盖了边框、padding、以及content区域(通过-background-clip属性控制,后面会看到) 2、背景颜色、边框、背景图片的层次从下到上顺序为：背景颜色=》背景图片=》边框，所以如果把边框样式设置伪dashed可以看到透过的背景颜色与图片. background-imageimage属性用于指定元素背景图片，除了图片还可以用radial-gradient或者linear-gradient函数创建一个渐变的图像对象。还可以给一个元素设置多个图像，后设置的图像在上面一层。 background-positionposition属性用于控制背景图片的位置，有三种类型的值可以设置： 1、直接设置关键字,水平方向：left、center、right,垂直方向：top、center、bottom.可以把背景图片看成相对于背景区域绝对定位，这样就比较好理解了。 2、使用像素值控制位置, 使用像素值的时候可以想像把背景图片相对定位，即：默认状态图片的位置为背景区域的左上角，这个时候修改背景图片的位置实际上是相对于背景区域的左上角做偏移。 3、使用百分比定位，这个属性不太好理解，简单说来一句话：把背景图片百分比的位置放置到背景区域对应百分比的位置.百分比定位的一个好处就在于，背景图片根据背景区域的放大而适配。 注意： 如果只设置了一个值，另外一个值将会是50%。不管是何种方式都是如此。 background-originorigin属性指定了背景图片属性的原点相对位置，默认值：padding-box,可选值有： content-box,元素内容区域 border-box,元素边框以内区域 padding-box,元素内边距以内区域 注意： 如果background-attachment设置为fixed则忽略该属性。 background-attachmentattachment属性决定背景图片滚动或者固定。可选属性： fixed,固定，相对视口做定位，类似于position属性的fixed。 scroll,相对元素自身的位置固定，不根据元素内容滚动。 local,相对元素内容的位置固定，根据元素内容滚动。 在线demo:scroll local fixed background-sizesize控制背景图片的显示区域大小，可以指定具体的宽高、也可以设置关键字、 background-size关键字 auto默认值，背景图片大小等与图片本身的大小。 contain包含，背景区域确保能放下整个图片，这样有可能造成背景图片没有涵盖整个背景区域的效果，但是图片能得到完整显示。 cover覆盖，用背景图片覆盖背景区域，这样会造成背景图片显示不全的情况，但是整个背景区域能被背景图片覆盖。 background-size指定大小 指定一个值这个时候另外一个属性会按照元素宽高比例缩放 指定两个值这个时候背景图片会被缩放到指定大小。 background-clipclip属性用于控制，背景图片和颜色延伸的区域，可选属性： border-box默认值，允许背景图片和颜色延伸到边框 padding-box允许背景图片和颜色延伸到内边距 content-box允许背景图片和颜色延伸到内容区 inherit继承","link":"/2016/08/25/CSS-background/"},{"title":"ScrollTo动画","text":"简单的ScrollTo动画实现在页面导航栏目设置几个标题按钮，按下的时候调转到对应的位置，这大概是浏览器页面开发最基本的动效之一了。看了一下很多页面都是基于jquery来实现，我不想用它，所以要自己造一个轮子。我们知道浏览器页面滚动都是基于window.scrollTo函数来实现的，还有一个函数叫window.scrollBy,用于滚动到某个相对坐标位置。 锚元素点击事件12345678let anchors = document.querySelectorAll('nav &gt; a'); anchors.forEach(function(element) { element.addEventListener('click', function(e) { e.preventDefault(); scrollTo(this, document.getElementById(this.href.split('#')[1]), 2000); }); }, this); 滚动时长设置为2s固定值。 滚动函数实现12345678910111213141516171819202122232425function scrollTo(element, to, delay) { var difference = to.getBoundingClientRect().top - element.getBoundingClientRect().top - 80; var stepTime = 8; var stepDis = difference*stepTime / delay ; var count = Math.ceil(difference/stepDis); var index = 0; var outQuart = function(n){ return 1 - (--n * n * n * n); }; function stepFunc() { index++; setTimeout(function() { var diff = outQuart(index/count)*difference; if(count &gt;= index) { window.scrollTo(0, diff); stepFunc(); } }, stepTime); } stepFunc();} getBoundingClientRect函数用于获取元素大小和相对视口的位置。为了让屏幕滚动更加平滑一些，这里借助了outQuart插值算法，如果想要其他效果可以看插值算法对照表,赠送一个插值算法库。","link":"/2016/08/26/ScrollTo%E5%8A%A8%E7%94%BB/"},{"title":"textMate snippet说明","text":"textMate一直是mac下常用的编辑器不过现在好像被sublime、atom、vscode等一系列新生带编辑器取代。为了学习vscode的编写，打算系统学学snippet语法。 以下译自： https://manual.macromates.com/en/snippets snippet是一小段的文本，你可以插入到你的文档里面。它可以包含代码，变量，tab键，占位符，以及转换。 普通文本在最简单的情况下，你可以使用 snippet插入一些文本，避免一遍又一遍的重复输入。这样不仅减少输入次数，而且减少出错。 在你使用 snippet的时候唯一一件事情需要注意的是：$和`是保留字符，如果你想要使用这两个字符，你需要在字符前面加入一个转译符号：\\。 变量你可以通过在变量名称前面加入$的形式插入变量。所有的正常变量都被支持，最有用的大概是：TM_SELECTED_TEXT变量。例如我们想要创建一个 snippet,用于包装LaTeX \\textbf命令的选择，我们可以这样写： \\textbf{$TM_SELECTED_TEXT} 如果没有文本被选中，变量不会被设置，也就不会插入任何文本。我们可以通过以下语法插入一个默认值： \\textbf{${TM_SELECTED_TEXT:no text was selected}} 默认值也可以包含变量，或者shell code。如果默认文本必须包含}，则需要转译。 Tab键在输入完成后，光标会停留在snippet最后的位置，又时候这不是我们要的结果。我们可以通过使用$0的形式指定光标停留的位置。例如，如果我们给html文件定义一个名为div的snippet，并且希望光标停留在开始和结束标签中间。我们可以这样写： 123&lt;div&gt; $0&lt;div&gt; 我们还可以在$后面指定更多的数字，按下tab键的时候控制光标在这些位置移动。例如： 123&lt;div$1&gt; $0&lt;div&gt; 第一次光标出现在$0位置，按下tab光标移动到$1位置。 占位符和变量一样，tab也可以有占位符，语法类似： ${«tab stop»:«default value»} 默认值可以包含文本、shell code、以及其他占位符： 123&lt;div${1: id=\"${2:some_id}\"}&gt; $0&lt;/div&gt; 插入该snippet将会插入一个div标签，id参数被选中，我们可以直接编辑它或者按下tab键切换光标位置。当你编辑占位符文本，内嵌的tab停止位会被删除。 镜像有时候我们想要同时修改多个位置，即编辑一个文本的时候能够影响到多个位置。例如，我们新建一个laTex的snippet： 123\\begin{${1:enumerate}} $0\\end{$1} 在插入完成该snippet，enumerate会被选中，修改它会影响到\\end位置部分。 vscode没有支持的格式没有做翻译，有兴趣的自己研究：）","link":"/2016/06/08/TextMate%20snippet/"},{"title":"Sailsjs参数校验","text":"参数校验模块是所有web server必不可少的一环，而实现的思路无外乎： 针对不同的action定义一个schema 编写一个中间件根据schema校验对应的action请求参数是否合法 之前针对swagger配合koa2编写过一套。因为通过swagger编写API规范的时候可以很容易的指定数据类型、数据长度、是否必传等信息。现在使用sailsjs框架实现思路也是类似，不过这次使用的不是swagger： 首先利用hapijs团队开源的joi模块，编写action schema: 12345678910111213const Joi = require('joi')module.exports = { putLogs: Joi.object().keys({ topic: Joi.string().required(), source: Joi.string().optional().allow(''), payload: Joi.array().items(Joi.object().keys({ time: Joi.string().required(), level: Joi.string().required(), message: Joi.string().required() })) })} 这是一个上传日志的action, 有两个参数是必传，一个参数是可选且允许传空。payload的三个字段也是必传。 为了对现有的代码保持最小的侵入性，我希望在无需改变现有代码的前提下使用这个参数校验模块。sailsjs的hook机制是一个不错的选择： 123456789101112131415161718192021222324252627282930313233const Joi = require('joi')const schemas = require('../schemas')module.exports = (sails) =&gt; ({ initialize: callback =&gt; { Object.keys(sails.controllers).forEach(key =&gt; { wrapAction(sails.controllers[key]) }) callback() }})function wrapAction (controller) { const id = controller.identity Object.keys(controller).forEach(key =&gt; { if (schemas[id] &amp;&amp; schemas[id][key]) { const action = sails.hooks.controllers.middleware[id][key.toLowerCase()] sails.hooks.controllers.middleware[id][key.toLowerCase()] = validateAction(action, schemas[id][key]) } })}function validateAction (action, schema) { return (req, res) =&gt; { const params = req.allParams() const { error } = Joi.validate(params, schema, { allowUnknown: true }) if (error != null) { return res.negotiate(sails.Error(ERROR_CODES.ERR_INVALID_PARAMS, error)) } return action(req, res) }} sailsjs允许用户自定义hook,并且在启动应用启动之前初始化它。所以我在hook启动初始化的时候对所有的action做一层包装，这样就做到了用户层代码无感知。 在校验错误的时候对客户端抛出一个参数错误字段。这里有一点需要注意的是，看到校验函数： 12const { error } = Joi.validate(params, schema, { allowUnknown: true }) 这里传了一个allowUnknown选项，该选项允许客户端传递schema以外的字段，这样也是为了向后兼容，因为一些客户端会默认传递一些额外的字段信息。","link":"/2017/12/02/Sailsjs%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"title":"Sailsjs项目模板","text":"在微服务体系下, 随着新需求的不断迭代，需要不停分解(新建)一些服务，这个时候会有很多重复的工作。譬如说搭建项目基础框架，设置开发、生产环境的配置。经过一段时间对sailsjs的折腾之后，下定决心总结一个属于自己的项目模板，方便下次直接使用。 项目模板主要包含以下几个模块： 基础结构1. 创建项目因为是一个\b纯后端项目，所以创建项目的时候指定基本选项： sails new project-name –no-linker –no-frontend 2. 配置response设置response: api/responses目录下有多个response文件，配置好相应的返回选项，譬如serverError.js: 1234567891011121314151617181920212223module.exports = function serverError (data, options) { const res = this.res const req = this.req sails.log.error(`${req.method} ${req.url} Result: ${util.inspect(data)}`); if (data instanceof VError) { const info = VError.info(data) const cause = VError.cause(data) const message = info.message + ':' + (cause ? cause.message : \"\" ) res.status(info.status) res.json({ code: info.code, message, data: info.data || {} }) } else if (data instanceof Error) { res.status(500) res.json({ code: -1, message: data.message, data: {} }) } else { res.status(data.status || 500) res.json({ code: -1, message: data.message, data: {} }) } return} 3. 设置rest风格的接口config/blueprint.js用于配置服务器支持的接口类型,关闭一些默认配置，只打开一些必要选项: 1234567{ actions: false, rest: true, shortcuts: false, restPrefix: '/api', pluralize: true,} 设置必要的hooks1. 捕获错误hookapi/hooks/asyncWrapper.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344const _ = require('lodash')module.exports = (sails) =&gt; { return { initialize: (callback) =&gt; { _.each(sails.controllers, (controller, controllerId) =&gt; { _.each(controller, (_, actionId) =&gt; { actionId = actionId.toLowerCase() const action = sails.hooks.controllers.middleware[controllerId][actionId] sails.hooks.controllers.middleware[controllerId][actionId] = handleAction(action) }) }) callback() } } function handleAction (action) { return (req, res) =&gt; { try { Promise.resolve(action(req, res)) .then(result =&gt; { return handleResult(result, req, res) }) .catch(err =&gt; { return handleError(err, req, res) }) } catch (err) { return handleError(err, req, res) } } } function handleResult (result, req, res) { if (res.headersSent || res.isHandled) return return res.ok(result) } function handleError (error, req, res) { if (res.headersSent || res.isHandled) return return res.negotiate(error) }} 2. 参数校验hookapi/hooks/validator.js12345678910111213141516171819202122232425262728293031323334const Joi = require('joi')const schemas = require('../schemas')module.exports = (sails) =&gt; ({ initialize: callback =&gt; { Object.keys(sails.controllers).forEach(key =&gt; { wrapAction(sails.controllers[key]) }) callback() }})function wrapAction (controller) { const id = controller.identity Object.keys(controller).forEach(key =&gt; { if (schemas &amp;&amp; schemas[id] &amp;&amp; schemas[id][key]) { const action = sails.hooks.controllers.middleware[id][key.toLowerCase()] sails.hooks.controllers.middleware[id][key.toLowerCase()] = validateAction(action, schemas[id][key]) } })}function validateAction (action, schema) { return (req, res) =&gt; { const params = req.allParams() const { error } = Joi.validate(params, schema, { allowUnknown: true }) if (error != null) { return res.negotiate(sails.Error(ERROR_CODES.ERR_INVALID_PARAMS, error)) } return action(req, res) }} 错误处理1. 设置错误码再项目启动的时候设置错误代码： 12345678module.exports.bootstrap = function(cb) { global.VError = require('verror') global.ERROR_CODES = sails.config.app.ERROR_CODES global.ERROR_PAYLOADS = sails.config.app.ERROR_PAYLOADS sails.Error = UtilService.createError cb()} 2. 创建自定义错误UtilService.createError提供一个\b函数创建自定义错误: 12345678createError: function (code, cause) { const payload = ERROR_PAYLOADS[code] const name = payload.name const info = payload info.code = code return new VError({ name, info, cause })} 3. 错误冒泡项目启动的时候引入了VError, 项目代码在抛出错误的时候传递上一次错误的原因，在response函数内返回内嵌错误： 12345678if (data instanceof VError) { const info = VError.info(data) const cause = VError.cause(data) const message = info.message + ':' + (cause ? cause.message : \"\" ) res.status(info.status) res.json({ code: info.code, message, data: info.data || {} })} 测试目录结构： sails-boilerplate/test 12345678├── bootstrap.test.js├── fixtures│ └── article.js├── integration│ ├── controllers│ └── services└── mocha.opts mocha.opts放置mocha测试框架基本配置： 1234--timeout 10s--exit--bail bootstrap.test.js是sails启动测试的入口： 12345678910111213141516171819before(function(done) { sails.lift({ // configuration for testing purposes }, function(err) { if (err) return done(err); // here you can load fixtures, etc. setupFixtures(function (err) { done(err, sails); }) }); after(function(done) { // here you can clear fixtures, etc. teardownFixtures(function (err) { sails.lower(done); }) });}) setupFixtures设置一些项目测试过程会使用的数据，teardownFixtures清除这些设置的数据。 integration文件夹方式一些测试用例。fixtures文件夹方式设置一些创建各种测试数据的代码文件。 项目\b地址：sails-boilerplate。","link":"/2017/12/10/Sailsjs%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"},{"title":"Session-&-Cookie","text":"Session&nbsp;&nbsp;&nbsp;&nbsp;web网站基于HTTP协议来做业务交互，HTTP协议本身是一个无状态的协议，但实际情况是日常很多业务逻辑都需要记录用户的行为信息。举个例子： 一个购物网站，顾客会在商品浏览页面选取需要的各类商品，放置到虚拟的购物车内。下单的时候需要跳转到结算页面，在这一串连续的用户行为中，至关重要的一点是记录当前的购物车信息，而session机制可以恰当的处理此类问题。 &nbsp;&nbsp;&nbsp;&nbsp;网站通常会在用户第一次登录的时候生成一个Session ID, Session ID不同于用户ID, 用户ID始终唯一，但是同一个用户每次登录获取的Session ID可能不一致。Session ID由服务器端生成，通过HTTP协议头返回给客户端，这样可以极大的降低可能导致的安全问题(其他劫持暂且不说)。因为浏览器拿到的只是一个token，而与此相关的数据存储都在服务器端完成。服务端在设置session ID的同时会指定改session id的过期时间，以及该session id试用的请求路径(path)。了解了session的大致原理，下面结合代码来了解大致的使用过程。 从cookie说起上述使用案例得益于cookie这一伟大发明，一般来说cookie的处理分为如下几个步骤： 用户打开网页 服务端生成cookie数据返回给浏览器 浏览器将cookie保存 之后每次加载该页面，浏览器都把cookie数据发送给服务器 cookies的基本数据格式标准的 HTTP协议有一个字段Set-Cookie用于标示cookie数据。服务器通过该字段告知客户端cookie数据。设置cookie数据的同时支持给该数据指定一些配置信息： Path: 表示该cookie数据影响到的路径，当前访问的url不满足该匹配时，不发送该cookie数据。 Expires: 该cookies数据的过期时间(具体的时间点)，如果不设置该选项，在浏览器关闭时该cookie丢失。该字段是一个UTC格式的字符串。 Max-Age: 告知浏览器cookie多久之后过期，可以解决客户端与服务器时间不一致导致过期时间不准确的问题, 在express里时间单位是毫秒。 HttpOnly: 告知浏览器该cookie不允许通过浏览器API的形式去修改，比如说通过document.cookie修改。在document.cookie不可见。 Secure: 当设置该值为true时，cookie数据在HTTP协议下无效，只有在HTTPS协议下才有效。 domain: domain属性指定了该cookie所属的域名(Domain), 比如说设置domain=example.com,那么浏览器在给www.example.com, www.abc.example.com发送HTTP请求时都会带上该cookie。如果服务器没有设置该属性那么浏览器默认该cookie从属于www.example.com域名。说到这里，一定会想，要是我把domain设置为其他网站,这样我是不是可以轻易更改其他网站的cookie数据了？浏览器有个策略，允许foo.example.com的服务器设置domain为example.com或者foo.example.com。但是不允许设置domain为bar.example.com ETC。同时考虑到安全方面的因素，浏览器拒绝只给domain设置公共(public suffixes)，比如说设置为com, co.uk是不被允许的。 Set-Cookie格式定义&gt;Set-Cookie: name=value; Path:/; Domin=.domin.com;Secure=true 第一部分表示设置的cookie键/值，后面跟着几个配置参数。 ###Cookie 解析Express/Connect有一个cookieParser中间件专门负责cookieParser的解析。其实现原理如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function parserCookie(cookie, options) { var obj = {}; var pairs = cookies.split(/; /); var decode = opt.decode || decodeURIComponent; pairs.forEach(function(pair) { var eq_idx = pair.indexOf('='); var key = pair.substr(0, eq_idx).trim(); var val = pair.substr(eq_idx, pair.length).trim(); try { obj[key] = decode(val); } catch(err) { obj[key] = val; } }); return obj;}function parseSignCookie(cookies, secret) { var keys = Object.keys(cookies); var dec = null; var ret = Object.create(null); var val = null for(var i = 0; i &lt; keys.length; i++) { var k = keys[i]; var v = cookies[k]; dec = unsign(v, secret); ret[k] = dec; } return ret;}function parseJSONCookie(cookie) { var keys = Object.keys(cookie); var key; var val; for(var i = 0; i &lt; cookie.length; i++) { val = cookie[i]; key = keys[i]; obj[key] = JSON.parse(val); }}var cookieParser = function(secret, opts) {function(req, res, next) { if(req.cookies) return; var cookies = req.headers.cookies; req.cookies = {}; req.signCookies = {}; //把name=value格式的字符串解析为一个json对象 req.cookies = parserCookie(cookies, options); if(secret) { //解析加密过的cookie字段 req.signCookies = parseSignCookie(req.cookies, secret); //解析stringify过的JSON对象 req.signCookies = parseJSONCookie(req.signCookies); } req.cookies = parseJSONCookies(req.cookies);}} Express 给不一样的cookie字段值打上不一样的标签，如j:表示该值是一个JSON对象stringify后的值，s:表示该字段是经过加密的。默认把加密与未加密的字段分别放在req.signCookies, req.cookies。 设置 CookieExpress提供了一个res.cookie接口来设置Cookie数据。来看看Express的处理代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263res.cookie = function (name, value, options) { var opts = merge({}, options); var secret = this.req.secret; var signed = opts.signed; if (signed &amp;&amp; !secret) { throw new Error('cookieParser(\"secret\") required for signed cookies'); } var val = typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value); if (signed) { val = 's:' + sign(val, secret); } if ('maxAge' in opts) { opts.expires = new Date(Date.now() + opts.maxAge); opts.maxAge /= 1000; } if (opts.path == null) { opts.path = '/'; } this.append('Set-Cookie', cookie.serialize(name, String(val), opts)); return this;};//序列化cookie以及配置信息function serialize(name, val, options) { var enc = opt.encode || encode; var pairs = [name + '=' + enc(val)]; if (null != opt.maxAge) { var maxAge = opt.maxAge - 0; if (isNaN(maxAge)) throw new Error('maxAge should be a Number'); pairs.push('Max-Age=' + maxAge); } if (opt.domain) pairs.push('Domain=' + opt.domain); if (opt.path) pairs.push('Path=' + opt.path); if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString()); if (opt.httpOnly) pairs.push('HttpOnly'); if (opt.secure) pairs.push('Secure'); return pairs.join('; ');}//设置到HTTP应答协议头res.append = function append(field, val) { var prev = this.get(field); var value = val; if (prev) { // concat the new and prev vals value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val]; } return this.set(field, value);};","link":"/2015/09/07/Session-&-Cookie/"},{"title":"URL编解码","text":"&nbsp;&nbsp;&nbsp;&nbsp;URI(统一资源定为标志)，用于指定想要访问的资源，URI可以有各种形式，如：日常在用的URL、每本书背面的ISBN码都是URI的一种形式, 日常过程中，如果不加区分，一般说的URI都指的是URL。拿我们熟悉的URL来说： 一个普通的URL： https://www.baidu.com/fuck.php?action=run#hash=1 URL一般包括以下几个部分： Scheme指定URL协议：http/https hostname指定域名，如上面的www.baidu.com port指定目标主机端口号，http协议默认为80端口，https默认为433端口。 path指定要访问的资源路径，以上为fuck.php query以?开头，传递给目标主机的参数，key/value的形式来表示参数，参数之间通过&amp;符号间隔开来。在Nodejs服务器，上面的URL最终解析得到query对象: req.query = {action: run} hashhash参数用于给浏览器渲染出来的HTML界面指定锚点，服务器在解析URL的时候会把#后面的字符丢弃。 如果在实际运用过程中我们仅仅只需要知道这些概念就好了，可惜事情的复杂度往往比现象的要大。 如果要给URL放其他字符怎么处理，如果我想放一些二进制数据呢？ 数据量一大，URL会不会出现过长的问题？ ####URL编解码&nbsp;&nbsp;&nbsp;&nbsp;在编写js代码过程中有几个常用的URL编码函数：encodeURI, encodeURIComponent, atob。以及对应的解码函数：decodeURI, decodeURIComponent, btoa。关于编解码，官方也有明确的规定(RFC 3986文档)，以下字符为保留字符，如果开发者需要使用它，就需要对其编码： ; , / ? : @ &amp; = + $ 同时也规定了一些非保留字符： 字母/数字/- _ . ! ~ * ‘ ( ) 对URL特殊字符的编码称之为百分号编码。即： 对于特殊字符序，需要转换为UTF-8编码方式，然后取每个字节的16进制值，在其前面加上%号，完成编码。由于UTF-8编码兼容ASCII码，所以对于特殊字符只需要取其ASCII码的16进制值，在前面加上%即可。由于%号(ASCII HEX = 25)在URL编码有特殊的含义，所以也需要对它编码：%25。最终得到的url仅仅由定义URL schema需要的字符，加上非保留字符组成。 来看看几个编解码函数的具体功能： encodeURI/decodeURI用于对整个URL编解码，但是其不会对保留字符与上面定义的非保留字符进行编码。举个例子：普通的编码：1234567&gt; var url1 = 'http://www.baidu.com/fuck.php?action=run';undefined&gt; encodeURI(url1)'http://www.baidu.com/fuck.php?action=run'&gt; 加上几个保留字符试一试：123456&gt; var url1 = 'http:/$/@;www.baidu.com/fuck.php?action=run';&gt; encodeURI(url1)'http:/$/@;www.baidu.com/fuck.php?action=run'&gt;可以看到并没有对保留字符编码。 再加入几个其他字符，如中文，试一试：1234&gt; var url1 = 'http:/$/@;www.baidu.com/你好fuck.php?action=run';&gt; encodeURI(url1)'http:/$/@;www.baidu.com/%E4%BD%A0%E5%A5%BDfuck.php?action=run'你好对应的Unicode码为：4F60、597D。UTF-8编码之后分别为：E4BDA0与E5A5BD正好匹配encodeURI的输出。可以看到对encodeURI除保留字符与特殊字符外的字符进行了编码。 由于encodeURI不会对一些特殊字符编码，但是URL规范使用中必须对一些特殊字符譬如说：&amp;, =,+进行编码。所以我们要用到的另一个函数是encodeURIComponent。 encodeURIComponent会把除非保留字符外的字符，通过百分号编码，转化为非保留字符的形式，这其中就包括了特殊字符。看几个例子：12345&gt; var component = 'http://www.baidu.com'; &gt; encodeURIComponent(component);'http%3A%2F%2Fwww.baidu.com'&gt;:, /都是保留字符，而.以及字母是非保留字符，验证了我们的想法。 如果我们要在URL传入一些二进制数据怎么办呢？首先想到的是：Base64编码的出现主要就是为了解决二进制数据的传输问题。btoa就是我们想要的接口。举个例子：123456var atob = require('atob');var btoa = require('btoa');var u1 = 'http://www.baidu.com';console.log(btoa(u1));输出： aHR0cDovL3d3dy5iYWlkdS5jb20= 由于Base64在被编码字符长度不为3的倍数情况下会出现=号，而=是保留字符，由于它在这里有特殊的含义(表示传输数据的一部分)，所以需要调用encodeURIComponent对其进行编码。 ####URL的一些数据长度限制规定web 浏览器对整个 URI 长度有一定的限制。传统的IE浏览器是2048个字节，而现代各种浏览器和 web 服务器的设定均不一样，这依赖于各个浏览器厂家的规定或者可以根据 web 服务器的处理能力来设定。","link":"/2016/04/17/URL%E7%BC%96%E8%A7%A3%E7%A0%81/"},{"title":"create-react-app支持ts和decorator","text":"create-react-app默认使用js作为开发语言，ts拥有强大的类型系统，更加适用于大型项目开发。许多面向对象的语言都有装饰器的语法，目前js也有相关的提案decorators。 创建新的应用： 直接创建ts项目 12345npx create-react-app my-app --typescript# oryarn create react-app my-app --typescript 把老的js项目迁移到ts 123456npm install --save typescript @types/node @types/react @types/react-dom @types/jest# oryarn add typescript @types/node @types/react @types/react-dom @types/jest 修改jsx文件名后缀，改为tsx123App.jsx -&gt; App.tsxindex.jsx -&gt; index.tsx ts开启装饰器支持修改tsconfig.json文件，加入配置： 12\"experimentalDecorators\": true 其他js项目开启装饰器 把配置文件暴露出来 12yarn run eject 安装装饰器模块 12yarn add babel-plugin-transform-decorators-legacy 修改配置文件 开发环境和生产环境的配置文件都在/config/webpack.config.js下面。修改相应的配置项目： 123456789// Process JS with Babel. { test: /\\.(js|jsx)$/, include: paths.appSrc, loader: require.resolve(‘babel-loader’), options: { plugins: [‘transform-decorators-legacy’], ... 参考资料： adding-typescriptdecorator-support-to-your-create-react-app","link":"/2019/02/01/create-react-app%E6%94%AF%E6%8C%81ts%E5%92%8Cdecorator/"},{"title":"css视觉格式化1","text":"视觉格式化基本概念总结块级元素水平格式化 1、水平格式化七个属性，只有宽度、左右外边距可以设置为auto，其他必须为特定值，或者默认为0. 2、外边距可以为负、其他不能。width默认为auto、其他默认为0. 3、七个水平布局属性之和等于父元素的width，只要所有所有属性都是大于或者等于0，元素就不会超过父元素的内容区域。 4、如果外边距离与width都设置为特定值且之和大于父元素的width，右边距会重置为auto。 5、如果只有一个设置为auto，其会根据公式计算。 6、如果参数之和大于父元素的width且margin-right设置为auto，则会重置margin-right以适配公式(如果没有设置margin-right为auto则会保持设置值) 块级元素的垂直格式化 1、高度默认由其内容决定、受到内容宽度影响 2、七个属性的值必须等于元素包含的height 3、七个属性只有三个可以设置为auto 4、如果把上下外边距设置为auto，那么它会自动计算为0 5、如果块级正常流元素的高度设置为auto,而且只有块级子元素，其默认高度是最高元素外边框(border)边界到最低子元素外边框边界的距离。 6、如果给包含块设置边框或者内边距时，包含块的高度会把子元素的外边距(margin)包含在内 7、垂直负外边距合并规则： 如果两个外边距都是负，浏览器取绝对值比较大的那个数 如果一正一负，浏览器会用正外边距减去负外边距的绝对值 行内框、浮动定位、和绝对定位元素之间的外边距不会叠加(外边距合并只发生在正常流元素) 行内元素布局的基本概念 1、em框： font-size大小确定 2、内容区 行内非替换元素：等于em框 行内替换元素：元素固有宽高、加上边距、边框 3、行间距 行内非替换元素：等于font-size与line-height的差 行内替换元素：没有行间距的概念 4、行内框 行内非替换元素：等于line-height 行内替换元素：等于内容区 行内元素布局一些有用的概念 1、内容区类似于块级元素的内容框 2、行内元素背景作用于内容区以及内边距 3、行内元素的边框包围内容区、内边距 4、非替换元素的边框、边距不会影响行内框高度 5、替换元素的边距、边框会影响行内框高度 6、可以为除了行内非替换元素外的任意元素设置垂直外边距 关于百分数参数 1、对margin/padding使用百分比将会相对于包含块的内容区宽度计算 2、对于height属性使用百分比将会相对于包含块内容区的高度计算 3、对于定位元素(position属性非static)的top、bottom属性使用百分比将会相对于包含块高度计算 4、不允许对border属性使用百分比","link":"/2016/08/18/css%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%961/"},{"title":"electron-研究笔记","text":"使用electron有一阵子了，随着项目推进，需要研究的东西也逐渐多起来。总结了以下，问题主要出现在： 跨平台兼容性 新的功能需求 ================= electron 渲染进程模拟浏览器环境electron渲染进程默认为nodejs环境，在里面你可以调用require引入第三方模块，但有时候我们想要的是一个真实的浏览器环境。electron需要做的配置如下： var mainWindow = new BrowserWindow({ resizable: true, width: size.width, height: size.height, title: 'HolaStudio', webPreferences: { nodeIntegration: false, preload: path.join(__dirname, 'tangide', 'expose-window-apis.js') } }); 创建BrowserWindow的时候指定nodeIntegration为false。 这样在electron内置浏览器里面不会有module和require全局变量。 ==================== 渲染进程与主进程之间的通信electron下主进程与渲染进程之间的通信主要有如下几种方式： 使用remote模块 使用ipc做进程间通信 这里我选择了第二种方式： // In main process. const ipcMain = require('electron').ipcMain; ipcMain.on('asynchronous-message', function(event, arg) { console.log(arg); // prints \"ping\" event.sender.send('asynchronous-reply', 'pong'); }); ipcMain.on('synchronous-message', function(event, arg) { console.log(arg); // prints \"ping\" event.returnValue = 'pong'; }); // In renderer process (web page). const ipcRenderer = require('electron').ipcRenderer; console.log(ipcRenderer.sendSync('synchronous-message', 'ping')); // prints \"pong\" ipcRenderer.on('asynchronous-reply', function(event, arg) { console.log(arg); // prints \"pong\" }); ipcRenderer.send('asynchronous-message', 'ping'); 在渲染进程引入模块，都需要用require的方式，但是按照要求，渲染进程必须是一个真实的浏览器环境，所以需要通过其他方式来引入模块包。 preload: path.join(__dirname, 'tangide', 'expose-window-apis.js') 该配置的作用在于： 界面的其它脚本运行之前预先加载一个指定脚本. 这个脚本将一直可以使用 node APIs 无论 node integration 是否开启. 脚本路径为绝对路径。 expose-window-apis.js实现如下： //inner process communication window.ipc = require('electron').ipcRenderer; 通过这种方式，渲染进程window对应引入了ipc模块，解决了渲染进程引入模块包的问题：） ============================ mac系统下快捷键问题Mac系统下，默认的快捷键Redo、Undo、复制粘贴等不能使用，阅读了electron发现需要通过创建应用菜单的方式做一个映射。 const Menu = require(\"menu\"); // Create the Application's main menu let template = [{ label: \"Application\", submenu: [ { label: \"About Application\", selector: \"orderFrontStandardAboutPanel:\" }, { type: \"separator\" }, { label: \"Quit\", accelerator: \"Command+Q\", click: function() { app.quit(); }} ]}, { label: keysBinding[\"Edit\"], submenu: [ { label: keysBinding[\"Undo\"], accelerator: \"CmdOrCtrl+Z\", selector: \"undo:\" }, { label: keysBinding[\"Redo\"], accelerator: \"Shift+CmdOrCtrl+Z\", selector: \"redo:\" }, { type: \"separator\" }, { label: keysBinding[\"Cut\"], accelerator: \"CmdOrCtrl+X\", selector: \"cut:\" }, { label: keysBinding[\"Copy\"], accelerator: \"CmdOrCtrl+C\", selector: \"copy:\" }, { label: keysBinding[\"Paste\"], accelerator: \"CmdOrCtrl+V\", selector: \"paste:\" }, { label: keysBinding[\"Select All\"], accelerator: \"CmdOrCtrl+A\", selector: \"selectAll:\" } ]} ]; //注册菜单 Menu.setApplicationMenu(Menu.buildFromTemplate(template)); ======================= 系统快捷键冲突问题开发者最常用到的快捷键一个是F12,打开开发者工具。 F5刷新当前网页： const globalShortcut = require('global-shortcut'); registerShortcut(); function registerShortcut() { function doRegister(cmd, callback) { globalShortcut.register(cmd, callback); } let registed = globalShortcut.isRegistered('F12'); if(registed) return; doRegister('F12', function() { let win = BrowserWindow.getFocusedWindow(); if(!win) return; win.webContents.toggleDevTools(); console.log(\"toggleDevTools F12\"); }); doRegister('F6', function() { let win = BrowserWindow.getFocusedWindow(); if(!win) return; win.webContents.toggleDevTools(); console.log(\"toggleDevTools F6\"); }); doRegister('F5', function() { let win = BrowserWindow.getFocusedWindow(); if(!win) return; win.reload(); console.log(\"refresh\"); }); return; } 正常情况下通过注册全局快捷键的方式能够满足绝大多数情况下的应用场景，但是使用过程中还是有如下问题： electron注册了快捷键后，系统默认浏览器无法通过快捷键触发调式工具。 windows系统electron应用的F12按键无效。 对于windows系统F12无效问题，electron官方貌似也没有一个好的解决方案。一个讨论的帖子。 快捷键覆盖的问题，目前的解决办法如下：监听blur和focus事件，在blur事件下注消快捷键，在focus下重新注册监听快捷键。 mainWindow.on('blur', function() { let win = BrowserWindow.getFocusedWindow(); if(win) return; globalShortcut.unregisterAll(); console.log('blur'); }); mainWindow.on('focus', function() { registerShortcut(); console.log('focus'); }); 一个electron应用可能存在多个窗口，所以在主窗口触发blur事件的时候需要判断是不是所有electron都失去了焦点。 在这种情况下注消快捷键，以便系统浏览器能正常调式。","link":"/2016/05/07/electron-%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0/"},{"title":"flex-box-xmind","text":"CSS3引入了强大的弹性布局(flex-box)，解决了传统CSS布局效率低下的问题。说句实话，学了一个礼拜多的CSS知识，我到现在都还没搞清楚，float\\display\\clear。三个布局参数之间的联系。查资料的过程中发现了flex-box这一神器，仿佛抓住了救命稻草。 兼容性探测： 推荐一个主流浏览器的特性支持情况检测网站: caniuse-flexbox flex-box所有属性思维导图：","link":"/2016/07/31/flex-box-xmind/"},{"title":"jvascript模块管理","text":"代码模块化目的： 1、封装 2、代码复用 常见模块化解决反案1、AMD(Asynchronous Module Definition) RequireJS实现了AMD规范。 2、CMD(Common Module Definition) SeaJS实现了CMD规范。 3、CommonJS Modules NodeJS环境的模块加载实现了CommonJS规范。每个文件都是一个单独的模块，有单独的作用域。模块之间通过global设置共享变量。Browserify可以让服务器代码跑在客户端。 特点： 1、所有代码都运行在模块作用域，不会污染全局作用域。 2、模块可以多次加载，但是只会在第一次加载时运行一次， 然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 3、模块加载的顺序，按照其在代码中出现的顺序。 常见问题： 清除缓存：delete require.cache[require.resolve(‘./b.js’)]模块按照绝对路径缓存，require.resolve返回模块的绝对路径。 解决互相依赖包含问题：CommonJS的做法是，一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 总结： AMD、CMD主要用在浏览器端异步加载、COMMONJS主要用在服务器端的同步加载。","link":"/2016/01/15/javascript%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86/"},{"title":"async-tutorial","text":"async是一个强大的异步流程控制库，其语义类似于js对数组的操作。它提供了一系列非常强大而便捷的方法，有助于我们在javascript单线程模型背景下写出优雅的逻辑控制代码。 牛刀小试先从文件操作开始初步了解async函数库的作用： 使用filter过滤出磁盘中存在的文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167const fs = require('fs'); const async = require('async'); async.filter(['f1', 'f2', 'f3'], function(it, callback) { fs.access(it, function(err) { callback(null, !err); });}, function(err, results) { console.log(results);});``` 假设当前目录下存在以上三个文件，那么`results`输出为： ```javascript['f1', 'f2', 'f3']``` + 使用`map`判断文件是否存在 ```javascriptasync.map(['f1', 'f2', 'f3'], function(it, callback) { fs.exists(function(exists) { callback(null, exists); });}, function(err, results) { console.log(results);//[true, true, true]});``` &gt;以上两个例子分别使用了`access`与`exists`判断文件是否存在，关于两个`API`的详细说明，请查看`nodejs`[官方文档](https://nodejs.org/dist/latest-v6.x/docs/api/fs.html#fs_fs_exists_path_callback) + 常用的多任务并行 ```javascript function asyncTask(delay, arg) { return function(callback) { setTimeout(function() { console.log(arg + \"done\"); callback(null, arg); }, delay); };}async.parallel([ asyncTask(10, \"task1\"), asyncTask(1, \"task2\"), asyncTask(100, \"task3\"),], function(err, ret) { console.log(ret);});``` `asyncTask`输出的顺序依次为：```javascript [luncher@localhost async]$ node app.jstask2donetask1donetask3done//ret[ 'task1', 'task2', 'task3' ]``` 可见虽然任务是并行的，但是最终的结果依然按照任务数组的顺序排列。 + 顺序执行任务 ```javascript function asyncTask(delay, arg) { return function(callback) { setTimeout(function() { console.log(arg + \"done\"); callback(null, arg); }, delay); };}async.series([ asyncTask(10, \"task1\"), asyncTask(1, \"task2\"), asyncTask(100, \"task3\"),], function(err, ret) { console.log(ret);});``` 输出： ```javascript [luncher@localhost async]$ node app.jstask1donetask2donetask3done[ 'task1', 'task2', 'task3' ] ``` 可以看到任务按照传入的顺序依次执行。 --- ### 集合类型多任务处理 - `each` `each`函数依次遍历数组执行回调函数： ```javascript function readFile(file, callback) { fs.readFile(file, function(err, ret) { console.log(\"readFile \"+ file + \" done\"); callback(err); });}async.each(['f1', 'f2', 'f3'], readFile, function(err) { console.log(\"all done\");});``` **需要注意的是，each不能保证迭代函数完成的顺序，这取决于用户的具体任务** - `forEachOf` `each`函数可以对数组进行遍历，如果想要遍历的是一个对象，那么需要用到`forEachOf`. ```javascript function readFile(file, k, callback) { fs.readFile(file, function(err, ret) { console.log(\"readFile \"+ k + \" \" + file + \" done\"); callback(err); });}async.forEachOf({k1: \"f1\", k2: \"f2\", k3: \"f3\"}, readFile, function(err) { console.log(\"all done\");});``` 迭代函数第一个参数是`value`，第二个参数是`key`. - 控制`each`和`foEachOf`的顺序 ` eachSeries`与`forEachOf`都是用来控制迭代函数的顺序执行： ```javascript function readFile(file, k, callback) { fs.readFile(file, function(err, ret) { console.log(\"readFile \"+ k + \" \" + file + \" done\"); callback(err); });}async.forEachOfSeries({k1: \"f1\", k2: \"f2\", k3: \"f3\"}, readFile, function(err) { console.log(\"all done\");});``` 这样程序的输出始终是： ```javascript[luncher@localhost async]$ node app.jsreadFile k1 f1 done readFile k2 f2 donereadFile k3 f3 doneall done 使用apply包装异步任务 前面几个异步任务都需要人为的额外写一个函数，如asyncTask，async提供一个apply语法糖用于解决此类问题： // 使用 apply async.parallel([ async.apply(fs.writeFile, 'testfile1', 'test1'), async.apply(fs.writeFile, 'testfile2', 'test2'), ]); // 等同于 async.parallel([ function(callback){ fs.writeFile('testfile1', 'test1', callback); }, function(callback){ fs.writeFile('testfile2', 'test2', callback); } ]); 使用Limit类函数控制并发数量 async为每个接口都提供了一个Limit参数，用户限制并发数量，我们利用filterLimit做一个简单的测试： var count = 0; async.filterLimit([1, 10, 28, 90, 10], 2, function(it, callback) { count++; console.log(it + \"开始\"); console.log(\"并发数：\", count); setTimeout(function() { count--; console.log(it + \"结束\"); callback(null); }, it); }, function(results) { console.log(results); }); 输出： [luncher@localhost async]$ node app.js 1开始 并发数： 1 10开始 并发数： 2 1结束 28开始 并发数： 2 10结束 90开始 并发数： 2 28结束 10开始 并发数： 2 10结束 90结束 null 可以看到，最大并发数也就是2，虽然待执行任务大于2. async几乎提供了全类数组操作类型的接口，例如：sortBy、reduce、some等，这里不再一一展开。 异步控制函数前面介绍了两个异步流程控制函数：series和parallel。下面介绍其他几个流程控制函数： 使用whilst实现while操作 whilst用于实现，类似于while的效果，直到满足条件，否则持续执行回调函数。 var c = 0; async.whilst(function() { console.log(\"judge\"); return c &lt; 3; }, function(callback) { c++; console.log(\"try \" + c); setTimeout(function() { callback(null, c); }, 1000); }, function(err, val) { console.log('err', err); console.log('value: ', val); }); 输出： [luncher@localhost async]$ node app.js judge try 1 judge try 2 judge try 3 judge err null value: 3 使用waterFall解决异步任务依赖问题 async.waterfall([ function(callback) { callback(null, 'one', 'two'); }, function(arg1, arg2, callback) { // arg1 now equals 'one' and arg2 now equals 'two' callback(null, 'three'); }, function(arg1, callback) { // arg1 now equals 'three' callback(null, 'done'); } ], function (err, result) { // result now equals 'done' });","link":"/2016/06/07/async-tutorial/"},{"title":"iptables配置","text":"1、Iptables介绍Centos系统内建了一个强大的防火墙，通常又被称为iptables。准确的说应该叫iptables/netfilter。iptables工作于用户层，用户通过命令行给防火墙预定规则表。netfilter是一个内核模块，完成实际的过滤工作。有许多GUI软件方便用户来设置防火墙规则，但都缺乏一定的灵活性，并且限制用户了解其中真正发生了什么。 在开始配置Iptables之前，我们需要知道知道一些它是如何工作的。Iptables利用到了 IP 地址、协议(tcp,udp,icmp)和端口。我们不需要成为这方面的专家，但多少知道一些有助于理解iptables是如何工作的。 Iptables给预定义的链路(INPUT、OUTPUT、FORWARD)设置规则。链路校验IP包并根据定义的规则对其做相应的处理，如：接受、丢弃等。对包的处理又被称为：targets。两个通常用到的target一个是DROP用于丢弃一个包、一个是ACCEPT用于接受一个包。 链路有三个预定义的链路定义在filter表内，我们可以给它添加规则来处理通过链路的IP包。三个链路分别是： INPUT -所有发往本机的数据包 OUTPUT -所有从本机输出的数据包 FORWARD -所有的即不是发往本机也不是从本机发出的数据包，但是需要通过本机的数据包。通常用在本机当作一个路由器的情况下。 所有的规则最终被添加到链路的一张表内。一个数据包在链路的规则表内轮流被校验，从顶部开始，一旦匹配到规则，规则定义的行为被执行，例如接受(ACCEPT)、丢弃(DROP)数据包。一旦数据包被处理、后续的规则将不会被执行。如果一个数据包没有匹配到任何一条规则，那么链路的默认行为会被使用，这被称为链路的默认策略。通常有两种默认的链路配置策略： 1、 设置默认策略丢弃所有的数据包、添加规则指定我们需要允许的IP地址或者指定端口的服务，如FTP、web服务器、Samba文件服务等。 2、 设置默认策略接受所有的数据包、添加规则指定我们需要拒绝的IP地址或者指定端口等。 2、起步确认iptables已经安装：123[luncher@localhost ide-server]$ rpm -qa iptablesiptables-1.4.21-13.fc21.x86_64[luncher@localhost ide-server]$ 查看当前配置信息：1234567[luncher@localhost ide-server]$ sudo iptables -L[sudo] password for luncher: Chain INPUT (policy DROP)target prot opt source destination ACCEPT all -- anywhere anywhere ACCEPT all -- anywhere anywhere state RELATED,ESTABLISHEDACCEPT tcp -- anywhere anywhere tcp dpt:ssh 我们可以看到ssh服务默认被centos服务允许了。 iptables 还有一些基本的命令如：start/restart/off/on等，和其他系统服务器基本类似。 3、写一个简单的规则设置一组简单的配置规则：123456789# iptables -P INPUT ACCEPT# iptables -F# iptables -A INPUT -i lo -j ACCEPT# iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# iptables -A INPUT -p tcp --dport 22 -j ACCEPT# iptables -P INPUT DROP# iptables -P FORWARD DROP# iptables -P OUTPUT ACCEPT# iptables -L -v 看看最终的结果：12345[luncher@localhost ide-server]$ sudo iptables -L -vChain INPUT (policy DROP 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 34 6368 ACCEPT all -- any any anywhere anywhere state RELATED,ESTABLISHED 0 0 ACCEPT tcp -- any any anywhere anywhere tcp dpt:ssh 下面来详细解释一下以上八个命令的具体作用： 1、 iptables -P INPUT ACCEPT如果我们远程登录到服务器修改配置，那么我们必须临时给INPUT设置默认的策略ACCEPT，否则一旦我们把规则表清空，我们将无法登录服务器。 2、 iptables -F用户清空filter表当前的配置规则。以便添加新规则。 3、iptables -A INPUT -i lo -j ACCEPT给INPUT链的末尾添加规则，当数据包进入本地网络使用的接口为localhost时，那么跳转(-j)到行为接受(ACCEPT)。多数软件都回和本地主机(localhost)适配器通信，所以必须开启该通道。 4、iptables -A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT接下来我们要保障已经建立的链路通信，这里我们使用state判断数据包的状态，辨别这是一个新的链接、还是一个已经建立的链接。允许接受已经建立链接的数据包。 5、iptables -A INPUT -p tcp –dport 22 -j ACCEPTSSH链接基于22端口，我们必须开启ssh服务。--dport选项基于tcp包的目的端口来匹配包，--sport类似。 6、iptables -P INPUT DROP为INPUT链设置默认的行为(target)。-P用于指定链路(--policy)。 7、iptables -P FORWARD DROP为FORWARD链设置默认行为(target)。 8、iptables -P OUTPUT ACCEPT最后，我们设置OUTPUT允许默认输出，表明我们信任我们的用户。 9、iptables -L -v列出当前的配置规则 4、接口在上面例子，我们可以给以指定网络接口的数据包设置规则，例如： 123456789iptables -A INPUT -i lo -j ACCEPT ``` 常用的网口还有:`eth0`、`eth1`等等。 ### 5、IP地址有时候对整个网口做限制还是不够精确，我们需要更加细致的规则来达到我们说要的效果。例如，添加一个可信的IP地址： iptables -A INPUT -s 192.168.0.51 -j ACCEPT1有时候一个IP还是不够用，我们需要对一个地址范围的IP定制规则：iptables -A INPUT -s 192.168.0.0/51 -j ACCEPT1为了防止`IP`地址伪造，我们也可以根据`mac`地址来过滤：iptables -A INPUT -s 192.168.0.51 -m mac –mac-source 0a:d0:62:de -j ACCEPT1234### 6、端口和协议上面我们看到了一些基于IP地址的过滤规则配置，接下来我们来学习根据协议以及端口号来设置过滤规则。在我们开始之前，必须知道一些特定服务的协议以及端口号，例如：bittorrent 服务，使用的是`tcp`协议，端口号默认`6881`：iptables -A INPUT -p tcp –dport 6881 -j ACCEPT1如果我们要对一系列连续的端口做相同的操作可以这样：iptables -A INPUT -p tcp –dport 6881:6991 -j ACCEPT1234注意：在限制端口之前必须指定协议类型，常用的有：tcp、udp、icmp。 ### 7、总结 来看一个生产机器上的防火墙配置：*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT-A INPUT -m state –state NEW -s 117.135.137.133 -m tcp -p tcp –dport 10050 -j ACCEPT-A INPUT -p tcp -m state –state NEW -m tcp –dport 10240 -j ACCEPT-A INPUT -p tcp -m state –state NEW -m tcp –dport 80 -j ACCEPT-A INPUT -j REJECT –reject-with icmp-host-prohibited-A INPUT -p tcp -m tcp –dport 80 -j ACCEPT-A FORWARD -j REJECT –reject-with icmp-host-prohibited-A OUTPUT -p tcp -m tcp –sport 10240 -j ACCEPTCOMMIT ```解释几个选项 1、*filter表示当前的表名为filter，一般不可以修改 2、:INPUT ACCEPT [0:0]表示链的详细说明，:&lt;chain-name&gt; &lt;chain-policy&gt; [&lt;packet-counter&gt;:&lt;byte-counter&gt;]。 3、COMMIT：每个表的描述都以COMMIT关键字结束 4、–reject-with icmp-host-prohibited：设置REJECT(target)的返回信息，也就是给发送者返回拒绝信息。可以参看常用的icmp类型。 到这里，我们学习了iptables的基础配置。相信经过不断的刻意练习，iptables配置一定烂熟于心。","link":"/2015/10/07/iptables%E9%85%8D%E7%BD%AE/"},{"title":"nginx反向代理基本配置","text":"nginx 基本配置为了让nginx能正常运行，必须设置它的一些基本配置，nginx基本配置主要包含了\bnginx正常运行的配置，包括了日志，以及对master/worker进程的控制、\bnginx服务监听分发等。 1234567891011121314151617181920212223242526272829303132333435363738user nobody; #worker进程启动用户worker_processes 1; #worker进程数量error_log logs/error.log debug; #设置nginx错误日志输出路径以及日志等级pid logs/nginx.pid;#设置保存master进程ID的文件路径events { worker_connections 1024;#设置每个worker进程最大连接数量为1024}http { # 定义MIME type 到文件拓展\b名的映射 include mime.types; #默认的MIME type default_type application/octet-stream; # 新增日志格式，格式名称为main log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # 设置http请求访问日志写入的路径，以及解析请求日志的格式 access_log logs/access.log main; #设置上游服务器地址 upstream backend { server 127.0.0.1:3000; server 127.0.0.1:3001; } server { listen 80;# 设置nginx服务监听80端口 server_name localhost; # 该server只处理请求的Host等于`localhost`的请求 }} nginx 反向代理配置\bnginx包含了一系列的http请求相关的配置，包含如：ngx_http_core_module、ngx_http_proxy_module等。参考链接: Modules reference。这里只配置一些能够用得上的选项： 定义缓存路径123456http { # 设置缓存路径、设置一个两层结构的目录、设置缓存键和元数据的共享内存区名称为：mycache, 大小：10m # 设置项目不被访问情况下再内存中保持60分钟、缓存的上限为1g、关闭缓存临时文件，避免不必要的文件拷贝 proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=my_cache:10m inactive=60m max_size=1g use_temp_path=off;} 反向代理缓存基本配置123456789101112131415161718192021222324252627282930313233343536server { # 定义共享内存区域名称 proxy_cache my_cache; # 定义nginx连接到代理服务器的超时时间 proxy_connect_timeout 1s; #如果当前正在更新缓存或者当前没有代理服务器来处理请求，则使用老的缓存 proxy_cache_use_stale timeout updating; #同一时间只允许一个请求修改缓存 #锁定时间：1秒 proxy_cache_lock on; proxy_cache_lock_timeout 1s; #关闭代理服务器的重定向请求 proxy_redirect off; #根据客户端请求的uri生成缓存键(对uri做md5操作) proxy_cache_key \"$request_uri\" #设置200状态码的返回数据的缓存时间为1秒钟 #定义的其实是一个绝对过期时间即：(第一次缓存的时间+配置的缓存时间) proxy_cache_valid 200 1s; #nginx反向代理的时候，一些http头部请求字段不会传递给代理服务器，这个时候需要我们手动指定 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #设置代理服务器集群 location / { proxy_pass http://backend; }} 利用ngx_http_headers_module和ngx_http_upstream_module设置响应头信息12345location / { # 设置响应头部信息，判断请求是否被缓存 add_header X-Cache '$upstream_cache_status';} nginx gzip模块配置1234567891011121314151617181920212223242526272829303132333435363738server { #开启gzip压缩功能 gzip on; #设置启用gzip的http版本信息 gzip_http_version 1.0; #设置gzip压缩等级 gzip_comp_level 5; #设置当Content-Length大于256的时候启用gzip配置 gzip_min_length 256; #对所有的代理请求都启用gzip gzip_proxied any; #添加“Vary: Accept-Encoding”到请求头部告知代理服务器是否支持gzip压缩 gzip_vary on; #设置需要压缩的MIME types gzip_types application/atom+xml application/javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/svg+xml image/x-icon text/css text/plain text/x-component;} –EOF–","link":"/2018/05/20/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"},{"title":"npm-的工作原理","text":"包(Package)和模块(Module)如何定义一个Package满足如下条件都可以称为一个包： 一个文件夹包含应用程序，使用package.json来描述它(a) 一个用gzip压缩的文件夹，满足(a)定义(b) 一个url可以获取(b)描述的压缩包(c) 一个@描述的一个包已经被发布到npm仓库 (d) 一个@描述的包同(e) 一个描述的包，并且具有latest标签，满足(e) (f) 一个git url 可以被克隆，满足(a) 定义 即使没有把包推送到公共的npm仓库，依然可以从npm获得很多好处： 如果你只是想写一个基于nodejs的应用程序，或者 如果你想安装一个压缩的包 git URL可以是以下几种格式： git://github.com/user/project.git#commit-ish git+ssh://user@hostname:project.git#commit-ish git+http://user@hostname/project/blah.git#commit-ish git+https://user@hostname/project/blah.git#commit-ish commit-ish 是一个可以git checkout的参数。默认为master。 如何定义一个ModuleModule是任何的能被nodejs程序使用require加载的模块。满足以下条件均可以称为Module： 一个文件夹包含package.json文件并指定了main字段 一个文件夹包含index.js文件 一个javascript文件 大多数Package都是一个Module譬如说一些cli程序的package只包含一些可执行的命令行程序，并没有提供main字段来指定程序供外部使用。 这些package不是module。 npm v2解析包的依赖关系想像一下现在有三个模块module A、module B、module C。A依赖B的V1版本，C依赖于B的V2版本。 现在创建一个应用程序依赖A和C。 模块依赖地狱(Dependency Hell)包管理器必须必须提供一个module B的版本。在nodejs之前的runtime，都会尝试通过提供一个折中的版本来解决它。 npm采取了另外一种方式，把依赖的模块包嵌入子目录： npm V3 解析包的依赖关系npm3和npm2的不同之处在于： npm2使用嵌套的方式来管理依赖包，npm3尝试缓和过长的包依赖路径问题。 把二级依赖的包安装在同一级目录下。 想像一下我们有一个模块A依赖模块B。我们在安装模块A的时候，在项目的node_modules文件夹下： 可以看到 npm v2与npm v3的差异： 现在我们需要安装一个模块C，模块C依赖模块B但是版本与模块A依赖的不同： 由于B v1.0已经安装在node_modules目录的根目录下了，不能把B v2.0也安装在根目录下。这个时候npm v3的处理方式和npm v2类似： 通过 npm ls查看当前项目所有包的依赖关系。如果只是想看顶级包的依赖关系可以执行npm ls --depth=0。 npm v3去重npm dedupe 该命令会删除node_modules顶级目录下没有被使用的模块，并且把被重复依赖的模块移动到顶级目录下。","link":"/2015/11/07/npm-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"position","text":"提到web控件的布局(layout)，position的概念必须理清楚。简单对position属性的基本概念做一个总结吧！以下文档参考了：CSS-tricks、W3School。 position基本属性： static relative absolute fixed inherits static所有web element默认的position属性都为static。在static模式下，元素的left、top、right、bottom、z-index。属性都不起作用。也就是说，默认情况下，所有元素的这些属性都不能用！ relativerelative顾名思义表示相对定位，相对元素在正常流中的位置做偏移。注意：relative定位的元素参考的是该元素正常流氏布局的位置。 absoluteabsolute又名绝对定位，该属性的元素在计算位置的时候参考的是最近的非static属性的祖先元素。如果不存在相应元素，则参考body定位。注意：absolute定位的元素会随着屏幕滚动。 fixedfixed意为固定，参考浏览器视口来定位(viewport)。不随屏幕滚动,所以在调出调式工具的时候依然可见。 inheritsposition属性非继承。所以可以显示的把父元素的属性强制继承过来。 再所说z-indexz-index表示元素元素所在的层级，默认为0，数字越大越贴近用户，当然也可以为负数。","link":"/2016/08/02/position/"},{"title":"table","text":"表格大概是html里面最常用的元素之一。看书上介绍说，在css出现之前，前端工程师一直采用table来布局页面，不过我没有尝试过，相比于那些早些年的前端工程师，现在的前端工程师应该算比较幸运吧！IE系列老旧浏览器逐渐死去，HTML5标准颁布，一切都在往好的方向走～ 表格的基本属性以及实践表格相关的基本元素 table定义表格的根元素 thead定义表头(页眉) tbody定义表体 tfoot定义表脚(页脚) tr定义一行 th定义表头内单元格 td定义普通数据单元格 caption定义表格标题 col定义表格列 colgroup定义表格列组 注意事项： thead、tbody、tfoot主要方便对表格不同区域进行分组，以及在打印表格的时候提供不同信息。 td、th单元格必须包含在tr属性里面 col、colgroup元素主要方便对表格不同列进行样式设置,需要注意的是列元素可以控制的属性比较有限.基本的color、text-align都不被支持 比较合理的解释看这里： The colour of text is dependent on the ‘color’ property of its element. Unless specified, the ‘color’ property (basically) defaults to ‘inherit’, which means “take the value of the parent element”. So for some text in a cell, the colour is determined by the ‘color’ property of the cell, which is taken from the row, which is taken from the table, which is taken from the table’s parent, and so on. What about the column? Well, the column isn’t one of the cell’s ancestors, so it never gets a look-in! And therein lies the problem. 表格样式布局 caption-side控制表格标题位置 border-collapse控制表格边框模型 table-layout控制表格布局，是否根据单元格内容缩放 border-spacing控制相邻单元格边框之间的距离，仅用于边框模型为分离模式 empty-cells控制隐藏表格中空单元格的背景与边框 rowspan控制单元格所跨行数 colspan控制单元格所跨列数 实践问题奇偶行设置不同背景色1、css 奇偶行伪类选择器 nth-child(n)选择器匹配其父元素的第n个子元素，odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词。 123table tr:nth-child(even) { background-color: red;} 为tr相对父元素为偶数索引(从1开始)的行设置背景为红色 设置第一列为不同背景1、使用first-child伪类选择器 123table td:first-child { background-color: red;} 2、使用col元素控制样式 12345678&lt;table&gt; &lt;caption&gt;hahah&lt;/caption&gt; &lt;col class=\"col1\"\\&gt; &lt;tr&gt; &lt;th&gt;th1&lt;/th&gt; &lt;th&gt;th2&lt;/th&gt; /... 1234table .col1 { background-color: gray;} 设置单元格边框并合并单元格控制单元格的显示除了盒模型基本属性外还有rowspan colspan empty-cells三个属性。 需要注意的是rowspan与colspan只能通过html属性设置，而不能通过css样式引用。","link":"/2016/08/07/table/"},{"title":"vscode开发环境配置","text":"初衷一直一来都是vim编辑器的忠实用户，说来也没有什么特别的原因，只不过是因为用的久了，习惯罢了。改变已有的习惯就跟在学习新知识的时候刻意练习会带来同样的体会，会让你感觉不舒服。之所以想放弃使用多年的vim(也就3-4年罢了)转投vscode名下. 前言 学习任何东西都有一个有效的方法论：在了解了一些必要的知识之后，快速开始行动，刻意练习！在练习中不断总结提高！ 科学研究者把人们应对一件事情分为3个步骤： 1、认知该事件的方式方法。 2、通过何种方式方法可以完成该事情。 3、实践该方法的步骤以及条件。 安装编辑器在github上找到vscode仓库，简要的阅读一下readme文档，然后再阅读一下How to build and run from source。vscode是基于electron开发的，所以再安装过程中需要下载electron的平台包，考虑到墙的原因我们可以自己下载electron electron,放到vscode根目录的.build下的electron文件夹 另外一种安装方式更为简便，到vscode官网下载安装包并安装。 阅读官方文档vscode官方网站是 https://code.visualstudio.com。阅读完overview以及setup下的平台环境完成安装。对于新手来说接下来应该认真阅读EDITOR一章。 vscode cheatsheet对于 任意一个软件来说，掌握好了快捷键会提升你的效率，让你有更多的时间专注于有价值的事情上。vscode按下F1快捷键，会提示所有的快捷键，还有一种方式：打开File=&gt;Preferences=&gt;keyboard Shortcuts列出所有的快捷键。另外这一章节的内容必须把它背下来：https://code.visualstudio.com/docs/editor/editingevolved。 小结： vscode EDITOR一章 vscode cheatsheet","link":"/2016/03/07/vscode%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"vscode编辑器进阶","text":"前言假定你已经阅读完成了EDITOR一章。现在开始来定制vscode。 两个目的： 减少重复工作，把时间花费在有意义的事情上 可定制、可扩展、可积累 主题颜色字体File&gt;&gt;Perfences=&gt;corlor theme选择一个舒服的主题，当然也可以按下ctril+p输入ext install安装喜欢的主题。字体通过用户配置文件来设置：按下F1输入user选择第一个条目按下回车。左边是默认配置，右边写入自定义配置。 颜色字体这类属于无关紧要的细节，不需要在这方面浪费过多的时间，接下来说说snippets。 vscode snippetsvscode针对不同的语言有不同的snippets。举个例子,新建一个test.html,输入： html 按下ctrl+space触发snippets。有两个选项可供选择，html标签以及html模板。选择html模板按下回车你会看到一下子多了很多东西： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 光标默认停留在en的位置，按下TAB会在en、title、以及body之间切换，能这么做归功于vscode的html snippets扩展。项目地址：&gt;https://github.com/abusaidm/html-snippets/blob/master/snippets/snippets.json 看看snippets.json的实现：123456789101112131415161718&quot;html5&quot;: { &quot;prefix&quot;: &quot;html5&quot;, &quot;body&quot;: [ &quot;&lt;!DOCTYPE html&gt;&quot;, &quot;&lt;html lang=\\&quot;$1en\\&quot;&gt;&quot;, &quot;\\t&lt;head&gt;&quot;, &quot;\\t\\t&lt;title&gt;$2&lt;/title&gt;&quot;, &quot;\\t\\t&lt;meta charset=\\&quot;UTF-8\\&quot;&gt;&quot;, &quot;\\t\\t&lt;link href=\\&quot;$3css/style.css\\&quot; rel=\\&quot;stylesheet\\&quot;&gt;&quot;, &quot;\\t&lt;/head&gt;&quot;, &quot;\\t&lt;body&gt;&quot;, &quot;\\t$4&quot;, &quot;\\t&lt;/body&gt;&quot;, &quot;&lt;/html&gt;&quot; ], &quot;description&quot;: &quot;HTML - Defines a template for a html5 document&quot;, &quot;scope&quot;: &quot;text.html&quot; } 解释一下这个snippets: “html5”表示该snippets的名称，prefix后面的html5表示触发条件 body表示snippets内容，是一个数组，数组元素最终会用换行符号链接起来 \\t表示缩进 $数字表示光标停留的次序，$1表示第一次停留位置，按下Tab键移到下一个位置 实在太方便了，工程师们就应该多动动脑子！！！ 当然也可以定义自己的snippets，在File=&gt;Perfences=&gt;User Snippets选择语言然后会出现以下代码： /* // Place your snippets for Markdown here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, ${id} and ${id:label} and ${1:label} for variables. Variables with the same id are connected. // Example: &quot;Print to console&quot;: { &quot;prefix&quot;: &quot;log&quot;, &quot;body&quot;: [ &quot;console.log(&apos;$1&apos;);&quot;, &quot;$2&quot; ], &quot;description&quot;: &quot;Log output to console&quot; } */ 以后你可以把自己的snippet放到这里。顺便说一句vscode``snippet格式遵循textmate,除了： ‘regular expression replacements’, ‘interpolated shell code’ and ‘transformations’ https://manual.macromates.com/en/snippets 你可以按下ctrl+p(快速打开)输入ext install sni,会列出一系列snippet。enjoy it :) 任务： 到https://marketplace.visualstudio.com/vscode找最常用的包试一试 学习snippet基本语法，学会自己编写 snippet","link":"/2016/04/07/vscode%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/"},{"title":"从这个劫持页面我学到了什么?","text":"移动端input默认样式清除样式： 123appearance: none;-moz-appearance: none;-webkit-appearance: none; appearance属性用于给元素指定平台相关的默认样式。有时候这并不是我们想要的效果。 垂直居中的flex实现1234&lt;body&gt; &lt;div class=\"main\"&gt; &lt;/div&gt;&lt;/body&gt; 1234567891011121314body { display: flex; min-height: 100vh; align-items: center; flex-direction: column; justify-content: ; background: blue;}.main { width: 5em; height: 5em; background: gray;} flex-direction: column把flex主轴方向设置在竖直方向，align-items控制元素在交叉轴线上(水平方向)的对齐方式。justify-content属性控制元素在主轴(竖直方向)的对齐方式。简单的实现了垂直和水平居中。 控制斜体文本123input::-webkit-input-placeholder{ font-style: italic;} 输入框的placeholder文本是斜体字，根据不同平台，需要把webkit、ms、o、moz等前缀的伪元素的样式也一起设置。","link":"/2016/09/07/%E4%BB%8E%E8%BF%99%E4%B8%AA%E5%8A%AB%E6%8C%81%E9%A1%B5%E9%9D%A2%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88/"},{"title":"一款在线秒杀游戏的设计","text":"秒杀的场景常见于在线商户，12306抢火车票等等。它们的特点都是类似，即：在某一个瞬间并发大量请求。而这个请求量如果不加以防范很可能会超过系统的负载能力，使得系统崩溃，影响公司的其他正常业务。 最近公司在做一个游戏项目，游戏的玩法类似于秒杀活动： “用户投入金币购买算力帮助AI获得算力，构建美丽新世界。游戏时间是有限的，在某个点投入金币获得额外的奖励。” 预估请求量秒杀活动顾名思义：物品数量有限，而用户数量庞大。首先要做的是预估请求数量，也就是说：预计有多少个用户能真正获得商品。举个例子：某在线商城要进行一个1元秒杀手机的活动，数量200台，每个用户限一台。那么实际成功的最大请求数量也就是200，其余的请求发送到服务器可以统一返回售罄的错误信息。对于这类需求，瓶颈通常在数据库层面。这个时候需要加一个缓存队列。每次用户发送购买请求，先判定缓存的长度，如果小于预估的请求数量则把购买请求入队列： 处理正常请求通过前面一个缓存队列，已经把绝大多数请求抵挡住了。现在要开始处理正常的购买请求。正常请求的处理逻辑基于解耦考虑通常放置在不同的模块。通过一个消息队列来通信。 查询购买状态由于用户的请求量比较大，而用户往往会不断的刷新页面，查询是否已经抢购到了商品，所以最好通过缓存队列来查询购买的状态，如果购买记录不在队列中，默认已经售罄。 注意事项：用户请求入缓存队列之后，会给处理购买的模块发送一条消息。在消息队列的选型要看清是at least once还是at most one或者exact once。通常队列实现的都是at least once。这个时候要做到处理逻辑必须是可重入的。","link":"/2018/11/01/%E4%B8%80%E6%AC%BE%E5%9C%A8%E7%BA%BF%E7%A7%92%E6%9D%80%E6%B8%B8%E6%88%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"title":"你不知道的Javascript上卷-阅读笔记","text":"SCOPE&amp;CLOSURES–THIS&amp;OBJECT-PROTOTYPES 作用域和闭包作用域是什么？作用域的定义： 需要一套良好的规则存储变量，并且之后可以找到这些变量，这套规则被称为作用域。 编译原理基本步骤： 词法分析，把代码块分解为词法单元 语法分析，把词法单元转换为抽象语法树AST 代码生成，将AST转换为可执行的代码(机器指令) 对比传统的编译型语言，javascript编译发生在代码执行前的几微妙。javascript引擎用JIT来保证性能最佳。 在代码生成的过程中，需要引擎、编译器、作用域三者协作完成。在编译的过程中，引擎会进行LHS,RHS操作。RHS表示取得变量的值，而LHS表示获取赋值操作的目标。 作用域嵌套： 引擎从当前执行作用域开始查找变量，如果找不到就会向上一级继续寻找，直到到达最外层作用域。 作用域操作的异常： RHS操作失败会抛出ReferenceError异常，而LHS操作没有找到目标变量，如果非严格模式下会创建一个全局变量，严格模式下会抛出ReferenceError。如果对RHS操作的变量的值进行不合理操作会抛出TypeError。 词法作用域词法作用域由书写代码时决定，通过一些方法如eval、with。可以在词法分析器处理之后修改作用域。 在标示符查找的过程中同名的会发生屏蔽，全局变量会自动成为全局对象的属性，因此可以通过window.a的形式访问被屏蔽的全局变量。 欺骗词法 eval 把字符串参数当做代码运行，就好像代码原来就是在那个位置。通过这种方式来修改词法作用域。严格模式下eval在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域。 with 把一个对象处理为一个词法作用域，对象属性被定义为在这个作用域内的词法标示符。块内部的var声明会被添加到with所处的函数作用域中。 不推荐使用eval和with： 严格模式下禁止使用 无法优化代码(作用域查找优化) 函数作用域和块作用域函数作用域分级的好处： 隐藏内部实现 避免冲突 函数声明不可以是匿名的，函数表达式可以是匿名的。 匿名函数缺点： 匿名函数在栈上不会显示出有意义的函数名，调式困难 没有函数名，只能通过argument.callee调用自身，在严格模式下不可用 匿名函数可读行不高 立即执行的函数表达式 12345(function foo() { var a = 3; console.log(a);})(); 第一个括号用于把函数变成一个表达式，第二个括号用于执行这个函数。 IIFE的作用： 把它当做函数调用，可以传入参数 解决undefined标示符默认值被覆盖问题 倒置代码的运行顺序，UMD模式 创建块作用域的方法： with try/catch catch分句会创建一个块作用域，其中声明的变量仅仅在catch内部有效。 let es6新语法关键字，let定义的变量不会在块作用域中进行提升。 constes6新语法关键字，const同样可以创建块作用域变量，其值是固定的。 提升 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理（编译阶段）。 规则： 只有声明会被提升、赋值不会 函数表达式不会被提升 函数首先被提升，然后才是变量 重复声明被忽略 闭包 通过任何手段，将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 循环和闭包问题： 循环迭代的过程中引用同一个变量。 解决办法： 1、IIFE 新建一个块作用域，并且每次都把变量传递进来。 2、let for循环头部的let声明有一个特殊行为： 变量在循环过程中不止声明一次。 利用闭包构建模块模块模式的条件： 必须有外部封闭的函数，该函数必须至少调用一次。 封闭函数必须至少放回一个内部函数，这样内部函数才能在私有作用域内形成闭包，并且可以访问或者修改私有的状态。 箭头函数与词法作用域好处： 用当前的词法作用域覆盖了this本来的值。 问题： 它是匿名的而非具名 this和对象原型this是什么 this既不指向自身，也不指向函数的词法作用域，this实际上是在函数调用时发生的绑定。 全面解析thisthis的绑定规则： 默认绑定 this指向全局对象。严格模式下无法使用（函数本身是严格模式）。 隐式绑定 对象属性引用炼只有最后一层会影响调用位置。 显式绑定 通过apply、call、bind来完成。 new 绑定 new调用一个函数发生的操作： 1、创建一个全新对象 2、这个新对象会被执行[[原型]]连接 3、这个新对象会绑定到函数调用的this 4、如果这个函数没有放回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 绑定优先级： 默认绑定优先级最低，显式绑定优先级别高于隐式绑定。new绑定高于显式绑定。 对象js基本类型： string number boolean null undefined object null由于语言本身的BUG执行typeof会返回object。 内值对象子类型： String Number Function Object Array Boolean Date RegExp Error 属性描述符号： writable 决定是否可以修改属性的值 configurable 决定是否可以用defineProperty修改属性。configurable:false的属性，禁止删除。 enumerable 决定是否出现在对象属性的枚举中。 不变性 1、结合使用writable和configure 2、禁止扩展 Object.preventExtensions 3、密封 Object.seal=Object.preventExtensions + configurable:false但是可以修改属性 4、冻结 Object.freeze=Object.seal + writable:false; 属性的存在性 1、in 检查是否在元素本身，以及原型链中。 2、hasOwnProperty 检查是否在对象本身。 3、peopertyIsEnumerable 检查属性名是否直接存在于对象中，而且enumerable:true。 4、Object.keys 返回一个对象本身所有可以枚举的属性 5、Object.getOwnPropertyNames 返回对象包含的所有属性(不含原型链)，不论是否可以枚举。 遍历 1、for in 遍历对象可以枚举的属性，包含原型链。 2、for 遍历数组 3、forEach\\some\\every ES5添加的方法，用于遍历数组。 4、for..of 通过迭代器(Symbol.iterator)遍历数组或者对象。 原型Object.prototype 所有的[[prototype]]最终指向Object.prototype。其提供了一些方法，如valueOf等等。 myObject.foo = &quot;bar&quot;出现的情况： 1、[[prototype]]存在foo,并且可以写，那么会在myObject新建一个foo属性。 2、[[prototype]]存在foo,并且不可以写，严格模式报出错误。 3、[[prototype]]存在foo且是一个setter,那就一定会调用这个setter,foo不被添加，而且调用这个setter。 基本原型关系：123456789101112131415function Foo() {}var foo = new Foo();Foo.prototype.__proto__ == Object.prototypeFunction.prototype.__proto__ == Object.prototypeArray.__proto__ == Function.prototypeFoo.__proto__ == Function.prototypefoo.__proto__ == Foo.prototypeFoo.constructor == Functionfoo.constructor == Foo","link":"/2016/12/08/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Javascript%E4%B8%8A%E5%8D%B7-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"title":"你不知道的box-shadow","text":"box-shadowbox-shadow是CSS3提出的一个重要属性用于给元素附加一层阴影。基本格式书写： box-shadow: h-offset v-offset blur-radius spread h-offset: 阴影距离元素水平方向的偏移,允许为负数 v-offset: 阴影距离元素垂直方向的偏移,允许为负数 blur-radius: 模糊半径 spared: 延展半径,允许为负数 基本使用 在div元素周围生成了黑色的阴影，这里我们只用到了三个参数，水平和垂直方向的偏移以及模糊半径。在这个例子中，四个方向的阴影长度大致为5px。 加上偏移量 水平偏移2px垂直偏移3px，模糊半径10px，这个时候元素在四周依然有阴影存在，我们如何计算阴影的长度呢？答案在于： 在顶部看到7px的投影(10px - 3px) 在底部看到13px的投影(10px + 3px) 在左边看到8px的投影(10px - 2px) 在右边看到12px的投影(10px + 2px) 单个方向的投影知道了阴影半径的计算，那么如何设计一个单个方向的投影呢？这个时候就需要spared属性，spared属性用于扩大或者缩小投影的尺寸。 利用spread，可以把需要隐藏的投影缩小，实现呢单边投影的效果。 邻边投影把上面的例子稍微修改一下得到右边和下边都为5px的投影。 对边投影box-shadow属性允许指定多个阴影，越往后z-order越小。我们利用单边投影的方式轻松实现对边投影的效果。 总结投影实现步骤： 在元素的上面，以元素原大小和指定颜色绘制一个矩形 根据h-offset、v-offset偏移矩形 根据blur-radius对元素模糊处理,在元素两边模糊的大小近似于模糊半径的两倍 根据spread裁剪投影 把投影和元素叠加的部分切除掉，完成了投影的过程","link":"/2016/09/03/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84box-shadow/"},{"title":"修复npm安装全局模块权限问题","text":"我们曾经可能都遇到过安装某个模块包的过程中提示EACCESS的错误问题。这是由于npm全局安装模块的默认路径没有权限导致的。 有三个方式可以解决该问题： 修改全局安装路径的权限 修改默认安装路径 借助第三方工具安装node 修改安装路径的权限 查看默认全局安装路径 npm config get prefix 对于大多数系统显示目录为：/usr/local 警告：如果默认路径是在/usr/请跳过该步骤，否则你会搞乱系统权限。 修改路径权限 sudo chown -R $(whoami) $(npm config get prefix)/{lib/node_modules,bin,share} 执行完毕将会把/usr/local下的lib/node_modules、bin、share所有权更改为当前用户。 修改默认全局安装路径当你不想修改默认安装路径的权限，因为由此可能会带来一些额外问题，譬如说，修改权限后无法跟当前系统其他用户共享。这个时候可以考虑修改默认的安装路径。 在示例下，我把默认全局安装路径修改到当前用户的home目录下面： 1、新建一个全局安装的路径 mkdir ~/.npm-global 2、配置npm使用新的路径 npm config set prefix ‘~/.npm-global’ 3、打开或者新建~/.profile，加入下面一行 export PATH=~/.npm-global/bin:$PATH 4、更新系统环境变量 source ~/.profile 安装一个全局包试一试： npm install -g jshint [luncher@localhost aaa]$ ls ~/.npm-global/bin/ jshint [luncher@localhost aaa]$ 借助第三方工具安装node mac系统借助brew安装node brew install node centos借助yum工具安装node yum install node","link":"/2015/11/07/%E4%BF%AE%E5%A4%8Dnpm%E5%AE%89%E8%A3%85%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9D%97%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"},{"title":"关于express下session的几个注意事项","text":"使用nodejs开发web应用之所以快，其中一个重要原因是非常齐全的第三方模块，你几乎可以找到任何想要的module。express-session是expressWEB框架常用的session管理包。其主要有如下几个配置选项： cookie : 用于设置sessionID cookie选项，如过期时间，cookie适用的路径等。 name : sessionID 对应的cookie名。 resave : 强制把session写入存储，即使session在整个请求过程中都没有被修改。 saveUninitialized : 保存新建的但没有被改动的session。 secret : 加密sessionID cookie的密钥。 ###1、 session并发问题resave选项如果配置为true，而实际的运用场景有并发请求并且依赖session的情况下就得注意了。因为问题在于，一个请求设置得数据可能被另外一个请求重写覆盖了。 对于一些有并发的服务器，需要把该选项配置为false。当然这只能解决session信息覆盖的问题。 并不能很好解决session数据一致性问题，比如说：用户首先发送一个更新session的请求，该请求依赖于其他服务器的应答，而后续的其他请求依赖于最新得session信息否则必须给以错误得应答。这个时候我们必须手动更新session的信息，把依赖于更新session信息的并发请求串行化。 Promise.resolve() .then(function() { req.session.user.gameKey = null; req.session.user.companyId = null; return syncUserSession(req); }) .then(function() { //.... }); function updateUserInfo(user) { return new Promise(function(resolve, reject) { user.gameKey = gameKey; user.companyId = user.companyIdSrc; user.save(function() { req.session.user = user; }); }); } ###2、 合理搭配中间件得顺序express-session作为几个基础中间件，每次请求都有创建对象，分配内存，保存数据等一系列操作。实际上，服务器上一些资源得应答没有使用到session。所以我们可以把它提前。当然也可以把没有使用到session得用户中间件提前。 //静态资源 app.use('/public', express.static(staticDir)); app.use(require('cookie-parser')(config.session_secret)); app.use(session({ secret: config.session_secret, store: new RedisStore({ port: config.redis_port, host: config.redis_host }), resave: false, saveUninitialized: true })); cookie-parser模块解析cookie数据，随后得session模块根据sessionID cookie管理会话数据。 把静态资源服务提前避免不必要得session操作。","link":"/2016/10/07/%E5%85%B3%E4%BA%8Eexpress%E4%B8%8Bsession%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"title":"分布式ID生成","text":"在分布式系统的大环境下，传统的自增方式生成唯一ID已经不太适用了，因为等到业务规模大到一定的体量的时候，必须要考虑到分库分表的问题，就不能保证ID的唯一性。所以我们需要一个替代方案来生成唯一ID。 现有的几种全局ID生成方式： 通过redis自增数值 Twittersnowflake算法 美团点评Leaf分布式ID生成系统 利用redis生成唯一IDredis是一个单进程单线程的架构（不考虑到快照备份、数据同步等）。其有一个incr原子指令，用于对数值加1操作。并返回执行 INCR 命令之后 key 的值。 优点，自增ID天然有序，对于数据库索引写入性能较好。 缺点，引入redis相当于引入了一个单点的性能瓶颈，同时增加了系统的复杂度和维护成本。 Twittersnowflake算法 snowflake生成一个64位的数值，前41bit是一个时间戳，精确到毫秒，中间10个bit用于表示机器组，一个集群最多可以表示1024台机器，后12bit表示随机数。2^12=4096，即：每台机器每毫秒最多可以生成4096个ID。 优点，实现简单，不依赖于第三方组件。 缺点，在并发量大的情况下会出现ID冲突的情况。 美团点评Leaf分布式ID生成系统Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。 具体可以参考官网说明: Leaf 分布式ID","link":"/2018/09/26/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90/"},{"title":"Kong网关集成到Prometheus监控","text":"Prometheus作为目前云生态环境下炙手可热的监控报警平台，目前已经得到社区开发者和厂商的广大认可。其灵活的组件设计为编写第三方扩展提供了很大方便。针对不同的应用场景，prometheus包含了大量了exporter。如: 各种数据库exporter，硬件信息的exporter，消息系统如kafka的exporter等。 在公司项目引入kong之后，发现没有一个合适的exporter可以用，所以动手实现了一个。 首先在Kong后台配置一个HttpLogPlugin插件。 Prometheus要求exporter提供一个/metrics的endPoint供给Prometheus Main Server调用，定时拉取当前网关的各项指标。而kong网关一端利用一个HttpLogPlugin插件定时把数据抛到exporter: 12345func main() { http.Handle(\"/metrics\", promhttp.Handler()) http.Handle(\"/kong\", http.HandlerFunc(handleKong)) log.Fatal(http.ListenAndServe(\":8080\", nil))} 初始化的时候注入各项metrics label: 12345678910111213141516171819202122232425262728import ( \"encoding/json\" \"fmt\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promhttp\" \"log\" \"net/http\")var ( totalRequest = prometheus.NewCounterVec( prometheus.CounterOpts{ Name: \"http_total_request_size\", Help: \"total http request size\", }, []string{\"status\", \"module\"}) responseTimeInMs = prometheus.NewSummaryVec( prometheus.SummaryOpts{ Name: \"http_response_time_milliseconds\", Help: \"Request completed time in milliseconds\", }, []string{\"method\", \"module\", \"status\", \"method_type\"}))func init() { prometheus.MustRegister(totalRequest) prometheus.MustRegister(responseTimeInMs)} kong抛过来的log主要包含请求的客户端ip、请求基本数据、请求延迟、\b请求的消费方、以及响应数据等： 12345678type KongLog struct { Request Request `json:\"request\"` Response Response `json:\"response\"` Api API `json:\"api\"` Consumer Consumer `json:\"consumer\"` Latencies Latencies `json:\"latencies\"` ClientIp string `json:\"client_ip\"`} 接收到kong抛过来的数据之后，写入prometheus\b缓存： 123456789101112131415161718192021222324252627func handleKong(w http.ResponseWriter, req *http.Request) { decoder := json.NewDecoder(req.Body) var kongLog KongLog err := decoder.Decode(&amp;kongLog) if err != nil { log.Println(err) log.Printf(\"handleKong Decode error\\n\") return } defer req.Body.Close() log.Printf(\"%#v\\n\", kongLog.Request) log.Printf(\"%#v\\n\", kongLog.Response) log.Printf(\"%#v\\n\", kongLog.Api) log.Printf(\"%#v\\n\", kongLog.Consumer) log.Printf(\"%#v\\n\", kongLog.Latencies) log.Printf(\"%#v\\n\", kongLog.ClientIp) method := kongLog.Request.Uri module := kongLog.Api.Name status := fmt.Sprint(kongLog.Response.Status) methodType := kongLog.Request.Method responseTimeInMs.With(prometheus.Labels{\"method\": method, \"module\": module, \"status\": status, \"method_type\": methodType}).Observe(float64(kongLog.Latencies.Request)) totalRequest.With(prometheus.Labels{\"status\": status, \"module\": module}) return} 项目代码地址：kong-prometheus-exporter","link":"/2017/08/01/%E5%88%A9%E7%94%A8prometheus%E7%9B%91%E6%8E%A7Kong%E7%BD%91%E5%85%B3/"},{"title":"压力测试","text":"在项目上线之前，打算对几个热点HTTP请求API做压力测试。首先看一下服务器的基本配置： 物理CPU个数: cat /proc/cpuinfo| grep “physical id”| sort| uniq| wc -l // 1 每个物理 CPU 中 core 的个数: cat /proc/cpuinfo| grep “cpu cores”| uniq //cpu cores : 1 查看逻辑CPU数: cat /proc/cpuinfo| grep “processor”| wc -l //2 逻辑CPU核心数大于物理CPU的核心数，说明开启了超线程。 内存: 12345678910[www@iZj6ce0dbddsjxmfjkt2p0Z ~]$ cat /proc/meminfoMemTotal: 3881692 kBMemFree: 376924 kBMemAvailable: 1839064 kBBuffers: 192600 kBCached: 1424992 kBSwapCached: 0 kBActive: 2506732 kBInactive: 73235... 看完了服务器的基本配置之后，需要选用一个压力测试工具，这里选用https://github.com/wg/wrk这个功能强大的压力测试工具。先来看几个wrk涉及的指标参数： 项目 名称 说明 Avg 平均值 每次测试的平均值 Stdev 标准偏差 结果的离散程度，越高说明越不稳定 Max 最大值 最大的一次结果 +/- Stdev 正负一个标准差占比 结果的离散程度，越大越不稳定 Latency: 延迟Req/Sec: 每个线程每秒钟的完成的请求数 wrk可以配合lua脚本一起使用。以一个常见的post请求为例： 12345require('base')wrk.method = \"POST\"wrk.body = '{\"devId\":7,\"taskType\":\"CPU_TASK\"}'wrk.headers[\"Content-Type\"] = \"application/json\" base这个包放置通用的配置，如通用的请求头等：1wrk.headers[\"test\"] = \"true\" 设置好之后执行压力测试： 123456789wrk -t10 -c10 -d10s -s ./module/getTask.lua --timeout 5s http://127.0.0.1:4001/feathers/v1/taskOperationsRunning 10s test @ http://127.0.0.1:4001/feathers/v1/taskOperations 10 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.01s 4.36ms 2.02s 81.63% Req/Sec 0.00 0.00 0.00 100.00% 49 requests in 10.09s, 38.57KB readRequests/sec: 4.86Transfer/sec: 3.82KB 在本次测试中，我们可以看到： wrk开启10个线程的并发请求，开启10个连接，请求时间10秒，每秒钟可以处理4.86次（也就是说在这种压力下，看到的QPS为4.86） 平均每次请求处理的Latency为2.01s左右","link":"/2018/08/24/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"},{"title":"基于Vuejs和Sailsjs的SSR实践","text":"Sails作为老牌Node.js框架,师从ROR,在Node.js社区也有一定的影响力。我们团队在微服务化之后选中其作为web开发基础框架。最近在做代码下发服务的时候需要一个后台管理页面，所以去了解了一下怎么利用sailsjs做服务器端渲染。 服务器端渲染依赖于webpack编译出的server-bundle文件。为了保证renderer的单例，所以在sailsjs启动的时候创建： 12345678910111213141516171819202122module.exports.bootstrap = function (cb) { if (isTest) { return cb() } const bundle = require('../assets/vue-ssr-server-bundle.json') const clientManifest = require('../assets/vue-ssr-client-manifest.json') const renderer = createRenderer(bundle, { clientManifest }) if (sails.config.setupDevServer) { console.log('setup-dev-server') require('../build/setup-dev-server') } global.renderer = renderer global.serialize = serialize global.createRenderer = createRenderer cb()} 为了方便本地开发实现hot reload功能，所以判断是本地开发环境的时候启动一个服务器，检测bundle文件变化并自动编译更新renderer： 123456789101112131415161718192021222324//...let bundle = fs.readFileSync(serverBundlePath, 'utf8')let clientManifest = fs.readFileSync(clientManifestPath, 'utf8')function update () { if (bundle &amp;&amp; clientManifest) { console.log('renderer updated.') global.renderer = createRenderer(JSON.parse(bundle), { clientManifest: JSON.parse(clientManifest) }) }}chokidar.watch(clientManifestPath).on('change', () =&gt; { clientManifest = fs.readFileSync(clientManifestPath, 'utf8') console.log('clientManifest updated.') update()})chokidar.watch(serverBundlePath).on('change', () =&gt; { bundle = fs.readFileSync(serverBundlePath, 'utf8') console.log('serverBundle updated.') update()}) 注意的是，这里只是监测bundle文件的变更，至于其他文件例如.vue文件或者前端js文件的更新没有能够监测，这可以利用webpack的watch功能来实现: 1234567\"scripts\": { //... \"dev\": \"rimraf assets &amp;&amp; npm run dev:server &amp;&amp; npm run dev:client\", \"dev:client\": \"cross-env NODE_ENV=development webpack --config ./build/webpack.client.config.js --progress --hide-modules --watch &amp;\", \"dev:server\": \"cross-env NODE_ENV=development webpack --config ./build/webpack.server.config.js --progress --hide-modules --watch &amp;\"}, 在基本配置写完之后，需要写一个视图渲染中间件，因为sailsjs本身是基于express来封装的，所以可以在中间件列表的末尾注入一个serverRenderer中间件，作用类似于connect-history-api-fallback： config/http.js 123456order: [ //... 'serverRenderer', '500'], serverRenderer实现： 12345678910111213141516171819202122232425262728293031323334353637function serverRenderer (req, res, next) { if (!global.renderer) { return res.end('waiting for compilation... refresh wait in a moment') } res.header('Content-Type', 'text/html') const s = Date.now() const context = { url: req.url, cookies: req.headers.cookie } sails.log.info('render context:', context) const renderStream = global.renderer.renderToStream(context) renderStream.on('data', chunk =&gt; { res.write(chunk) }) renderStream.on('end', () =&gt; { sails.log.info(`whole request: ${Date.now() - s}ms`) res.end() }) renderStream.on('error', err =&gt; { if (err &amp;&amp; err.code === 404) { return res.status(404).end('404 | Page Not Found') } res.status(500).end('Internal Error 500') sails.log.error(`error during render : ${req.url}`) sails.log.error(err) }) return} 在请求进来的时候判断渲染器是否准备好。如果准备好了，则调用渲染器传入请求的url，匹配相应的控件做数据的预加载。在这里我们还把请求的cookies传递过去，这是因为服务器的一些api请求需要鉴权，这样在数据预加载的时候才能成功取到数据： axios 请求传入cookies 1234567891011121314151617181920//...const request = axios.create({ baseURL, timeout})const createAPI = (method, url, config = {}) =&gt; { return request({ url, method, ...config })}request.interceptors.request.use(config =&gt; { if (!isClient) { config.headers.Cookie = serverCookies } return config}, error =&gt; Promise.reject(error)) api/polices/isLogined.js 123456789101112function isLogined (req, res, next) { if (!req.session.uid &amp;&amp; req.url !== '/signin') { if (req.wantsJSON) { res.serverError(sails.Error(ERROR_CODES.ERR_NEED_LOGIN)) } else { res.redirect(sails.config.app.redirectUrls.signin) } } else { next() }} 对于服务器和客户端的数据预加载的基本写法可以参考vuejs的官方文档。 另外一点需要注意的是，我使用的iview框架，而它本身没有针对ssr适配所以在渲染的时候，或者数据预加载的时候最好加一个判断: 123456789101112131415request.interceptors.response.use(res =&gt; { const body = res.data const messageDefault = res.config.messageDefault if (body.code !== 0) { if (isClient) { iView.Notice.error({ title: 'Error', desc: messageDefault || body.message || '操作失败' }) } return Promise.reject(res) } return res}, ... isClient变量依赖于webpack编译的时候注入的环境变量process.env.VUE_ENV。","link":"/2017/11/12/%E5%9F%BA%E4%BA%8EVuejs%E5%92%8CSailsjs%E7%9A%84SSR%E5%AE%9E%E8%B7%B5/"},{"title":"如何学习","text":"深度学习的关键点： 高质量的信息源和第一手知识 把知识连成地图，将自己的理解反述出来 不断的反思和思辨，与不同年龄段的人讨论 举一反三，并践行之，把知识转换成技能 学习的三个步骤: 知识采集 获取信息的源头、破解表面信息内在的本质、多方的数据验证 知识缝合 连接记忆，逻辑推理，知识梳理 技能转化 举一反三，实践练习，传授教导 学习方法论挑选知识和信息源的原则 应该是第一手资料，不是被人理解过、消化过的二手资料 应该有佐证、有数据、有引用的，或者有权威人士或者大公司生产系统背书 应该是加入了一些自己的经验和思考，可以发人深思 注重基础和原理 基础不行会影响你对事物的理解，甚至会让你不能理解为什么是这样。当你对事物的出现有不理解的东西时，通常来说，是因为你的基础知识没有跟上。 基础知识和原理性的东西和技术，都是经历长时间的考验的，所以，这些基础技术也有很多人类历史的智慧结晶，会给你很多启示和帮助。 使用知识图 把一块大知识拆解成知识树，采用联想记忆的方式梳理知识点。 当遇到某个不知道的知识点的时候，就把它挂到这颗知识树上。 学习不是为了要记忆那些知识点，而是为了找到一个知识的地图，在这个地图上能通过关键路径找到你想要的答案。 系统地学习学习某个技术的时候问几个问题： 这个技术出现的背景、初衷和要达到什么样的目标或者是解决什么样的问题。 这个技术的优势和劣势分别是什么，或者说，这个技术的trade-off是什么。 这个技术的适用场景 技术的组成部分和关键点 技术的底层原理和关键实现 已有的实现和它之间的对比 举一反三人与人之间最大的差别就在于举一反三的能力。举一反三的能力包含： 联想能力 平时需要锻炼同一个事物不同的看法，或者是联想与之有关的别的事物。 抽象能力 对问题进行抽象，获得多种表现形式 自省能力 当你得到一个解的时候，要站在对立面来找这个解的漏洞。这种自己和自己辩论的能力又叫思辨能力。获得完整全面的问题分析能力。 训练方法： 对于一个场景，制造出各种不同的问题或者难题 对于一个问题，努力寻找尽可能多的解，并比较这些解的优劣 对于一个解，努力寻找各种不同的测试案例，以图让其健壮 总结和归纳 在学习的开始阶段，可以不急于总结归纳，不急于下判断，做结论，而应该保留部分知识的不确定性，保持对知识的开放状态。 总结和归纳的方法： 把你看到和学习到的信息，归整好，排列好，关联好，总之把信息碎片给结构化掉，然后在结构化的信息中，找到规律，找到相通之处，找到共同之处。进行简化、归纳和总结，最终形成一种套路一种模式，一种通用方法。 实践出真知 实践是一件很痛苦的事，但只有痛苦才会让人反思，而反思则是学习和改变自己的动力。 坚持不懈 一方面你要把你的坚持形成的成果晒出来，让别人来给你点赞，另一方面，你还要把坚持变成一种习惯，就像吃饭喝水一样，你感觉不到太多的付出成本。只有做到这两点，你才能够真正坚持。","link":"/2018/10/18/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"},{"title":"微服务系统架构","text":"一、引入微服务架构需要作出权衡微服务解决了传统SOA项目开发部署的效率问题，大大提升了产品的迭代速度。另一方面通过把需求合理的划分为单一小模块，针对不同业务场景可以采用不同的技术选型。 微服务的优势已经被研究的很透彻，但是在实践的过程中需要作出权衡。在业务规模比较小的时候传统的单一代码库的开发效率远高于微服务。也就是说在项目初期，产品方向不明确，这个时候采用传统的单一代码库来开发是一个更好的选择。随着业务复杂度的上升，微服务模式的开发效率逐渐高于单体代码仓库。 可以看到在项目前期SOA开发效率比较高，随着项目不断迭代，需求复杂度上升，到达某一零界点的时候微服务架构开发效率高于SOA模式这个时候微服务的优势才慢慢体现出来。 二、微服务架构与组织模块划分著名的康威法则为团队的组织关系与系统代码架构的划分给出了良好的建议： 设计系统的组织，其产生的设计和架构等价于组织间的沟通结构。 团队之间是松散的，而单一应用必须让不同团队协同开发测试部署，成本比较高。通过把项目合理划分到不同的团队，互不干扰，系统效率得到了提升。 三、微服务总体技术架构 四、微服务网关网关作为微服务入口主要有以下几个功能： 反向路由 认证安全 限流熔断 日志监控 常见的网关如zuul, 和基于openResty的Kong都有很好的支持。 五、微服务集中配置中心随着微服务数量增多集中化配置会慢慢变成一个痛点，集中化配置主要有以下一些优点： 可追溯 响应快 集中化管理 常用的集中化配置实现方式： pull模式(定时拉取) push模式(配置更新推送) 作为业界微服务的楷模Netflix开源了一个archaius专门负责配置管理。 六、微服务通信方式RPC vs REST RPC REST 耦合性 强耦合 松散耦合 消息协议 二进制、thrift、protobuf 文本XML、JSON 通信协议 TCP HTTP／HTTP2 性能 高 一般低于RPC 接口契约 thrift、protobuf swagger、openAPI 客户端 强类型客户端、一般通过工具自动生成 普通http请求客户端即可 案例 Dubbo、motan、Tars、grpc、thrift Jax-rs 开发者友好 客户端集成方便、二进制消息不可读 文本消息可读 对外开放 一般需要转换成REST/文本协议 直接可以对外开放","link":"/2017/10/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"title":"如何设计一个数据字典","text":"数据字典在Javascript语言里面随处可见，对象本身就可以看成一个数据字典，通过给对象设置属性与方法，达到一个字典的目的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148var dict = new Dict();obj.pro1 = \"hello world!!!\";obj.pro2 = function () { console.log(\"I'am pro2\");};``` &lt;!-- more --&gt;先来看一个常见的数据字典的设计： ```javascriptfunction Dict() {}Dict.prototype.count = function() { let n = 0; for(let k in this) { n++; }; return n;};//let dict = new Dict();dict.paul = 3;dict.lebron = 23;dict.count() // 3 ``` 为什么给设置了两个属性，通过`count`计算得出的结果是`3`呢？这里比较容易看出来，因为`for in`会遍历原型链上的可枚举的属性，例如上面的`count`方法。为了避免这种由于遍历原型链导致的错误结果，实现一个改进版本： ```javascript var dict = {};dict.diwy = 3;dict.love = 10;let n = 0;for(let k in dict) { n++;}console.log(n) //2``` 通过这种改进虽然能够得出正确的结果，但是我们把这一切能够正常运行的希望寄托于`Object.prototype`原型没有受到`污染`。这种假设通常伴随一定的风险，如果和其他人协同开发产品，你不能保证其他人也和你一样遵循相应的规范。 了解到潜在的原型污染问题之后，可以想到的做法是，构造一个对象，不依赖于常规的原型对象： ```javascriptfunction C() {}C.prototype = null;``` 来测试一下： ```javascriptvar c = new C();Object.getPropertyOf(c) === null;//falseObject.getPropertyOf(c) === Object.prototype; //true``` 遗憾的是`c`对象的原型依然是`Object.prototype`。`ES5`提供了一个方法来创建一个没有原型的对象： ```javascript var dict = Object.create(null);Object.getPropertyOf(dict) === null; // true``` 通过创建一个没有原型的对象，可以很好的规避原型污染问题。但是如果你既需要对象原型，又想保证字典枚举的安全性，那就得改造一些字典的设计。 使用`hasOwnProperty`来判断对象的实体属性，而不是原型熟悉。 ```javascript var dict = {};dict.name = 'lebron';dict.hasOwnPropertyOf(\"name\") //true;dict.hasOwnPropertyOf(\"valueOf\") //false\"valudeOf\" in dict //true``` 为了避免设置`hasOwnPropertyOf`这样奇怪的属性，我们需要在任何安全的位置提取出`hasOwnPropertyOf`方法。 ```javascriptvar hasOwnProperty = Object.prototype.hasOwnProperty;//或者 var hasOwnProperty = {}.hasOwnProperty; hasOwnProperty.call(dict, \"name\"); //true``` 一个安全的数据字典实现： ```javascript function Dict(elements) { this.elements = elements || {};}Dict.property.has = function(key) { return {}.hasOwnPropertyOf(key);};Dict.property.get = function(key) { return this.has(key) ? this.elements[key] : undefined;};Dict.property.set = function(key, value) { this.elements[key] = value;};Dict.property.remove = function(key) { delete this.elements[key];};``` 在一些`javascript`环境中，特殊的属性名`__proto__`可能会导致自身的污染问题(修改对象的原型)。我们必须把它优化掉： ```javascriptfunction Dict(elements) { this.elements = elements || {}; this.specialPropValue = undefined; this.specialProp = \"__proto__\"; this.hasSpecialProp = false;}Dict.prototype.has = function(key) { if(key === this.specialProp) { return this.hasSpecialProp; } return {}.hasOwnPropertyOf.call(this.elements, key);};Dict.prototype.get = function(key) { if(key === this.specialProp) { return this.specialProp; } return this.has(key) ? this.elements[key] : undefined;};Dict.prototype.set = function(key, value) { if(key === this.specialProp) { this.specialPropValue = value; } else { this.elements[key] = value; }}; 这样javascript环境是否处理__proto__属性，该实现均能保证是可工作的，以上也算是数据字典比较好的一个设计吧！。","link":"/2016/07/07/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/"},{"title":"数字货币-什么值得挖?","text":"现在我们正处于数字货币泛滥的时期，随着一些山寨币的热度的下降，无数的矿工相信都被套牢了：）。当前数字货币市场波动比较大，特别是一些山寨币。矿主为了使得收益最大化，选择适合当前设备的数字货币是关键（这里抛开定制矿机，定制矿机在出厂的时候已经固定了能挖的数字货币种类）。这里主要讨论GPU挖矿的场景。 目前市场上常见的GPU种类有如下几种： 12345678910111213141516RX470RX480RX570RX580GTX750GTX750TiGTX950GTX960 GTX965 GTX970 GTX980GTX980TiGTX1060_6GGTX1070GTX1080GTX1080Ti 每种型号的GPU对应每种数字货币的算法是固定的，比如说对于RX470而言其算法如下： 123456789101112131415161718192021222324252627282930313233{ \"device\": \"RX470\", \"type\": \"GPU\", \"price\": \"1500\", \"Ethash_h\": \"27500000\", \"Ethash_p\": \"120\", \"Groestl_h\": \"14500000\", \"Groestl_p\": \"120\", \"X11Gost_h\": \"5300000\", \"X11Gost_p\": \"125\", \"CryptoNight_h\": \"660\", \"CryptoNight_p\": \"100\", \"CryptoNightV7_h\": \"660\", \"CryptoNightV7_p\": \"100\", \"Equihash_h\": \"260\", \"Equihash_p\": \"110\", \"Lyra2REv2_h\": \"4400000\", \"Lyra2REv2_p\": \"120\", \"NeoScrypt_h\": \"600000\", \"NeoScrypt_p\": \"140\", \"LBRY_h\": \"80000000\", \"LBRY_p\": \"120\", \"Blake(2b)_h\": \"800000000\", \"Blake(2b)_p\": \"120\", \"Blake(14r)_h\": \"1100000000\", \"Blake(14r)_p\": \"120\", \"Pascal_h\": \"510000000\", \"Pascal_p\": \"120\", \"Skunkhash_h\": \"15000000\", \"Skunkhash_p\": \"105\", \"Myriad-Groestl_h\": \"21315000\", \"Myriad-Groestl_p\": \"120\"} 通过这个对照表，我们可以知道当前设备对应每一种挖矿算法的算力值(hashrate)。而每一种数字货币都有固定的挖矿算法，比如，ETH的挖矿算法是Ethash。这样一来就把设备和数字货币挂钩了。 接下来我们还需要知道当前数字货币的行情数据，这样才能计算出挖哪一个币比较划算。 123456789101112131415161718192021222324{ \"tag\": \"ETH\", \"algorithm\": \"Ethash\", \"block_time\": \"14.1923\", \"block_reward\": 2.91, \"block_reward24\": 2.91000000000003, \"last_block\": 6311414, \"difficulty\": 3289197384217730, \"difficulty24\": 3251946013832730, \"nethash\": 231759290898425, \"exchange_rate\": 0.030679, \"exchange_rate24\": 0.030857829846583, \"exchange_rate_vol\": 9535.24681118, \"exchange_rate_curr\": \"BTC\", \"market_cap\": \"$19,833,206,007.40\", \"estimated_rewards\": \"0.00676\", \"estimated_rewards24\": \"0.00684\", \"btc_revenue\": \"0.00020754\", \"btc_revenue24\": \"0.00020992\", \"profitability\": 100, \"profitability24\": 100, \"lagging\": false, \"timestamp\": 1536659576} 通过这个对照表的基本信息，结合上面的算力对照表，我们可以计算出，当前设备挖取该数字货币的收益, 具体算法如下： 12345678910//根据出块时间，计算全网24小时出块的个数const awardDay = coin.blockReward / coin.blockTime * 3600 * 24//根据当前设备的算力、全网算力，计算当前设备获得币的数量const myAwardDay = (awardDay * hashRateDict[coin.algorithm] / coin.nethash) || 0coin.hashRate = hashRateDict[coin.algorithm]coin.mining_coin = myAwardDay//根据当前币相对于BTC的交换率，计算得到的BTC个数coin.mining_btc = myAwardDay * (coin.tag === \"BTC\" ? 1 : coin.exchangeRate24)//根据BTC个数以及BTC价格计算收益coin.mining_cny = coin.mining_btc * BTCPrice 一个完整的流程图： 参考资料： 什么值得挖","link":"/2018/11/08/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81-%E4%BB%80%E4%B9%88%E5%80%BC%E5%BE%97%E6%8C%96/"},{"title":"每个工程师都应该知道的 API 设计知识","text":"REST 风格是现在使用最广泛的 API 设计规范。全称：Representational State Transfer（表现层状态转移）。 REST APIREST 核心包含以下几个基本概念： 基本概念 资源（Resources） 它可以是：一个用户信息、一部电影等。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。 表现层（Representation） 资源的呈现形式，HTML格式、XML格式、JSON格式表现等。 状态转化（State Transfer） 如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。具体来说就是在 HTTP 协议下通过 GET 、POST、DELET、PUT等操作动词来操作资源。 REST API 主要包含以下几个部分： 1、协议 推荐使用 HTTPS 的协议，HTTPS 相较于 HTTP 提供了更高的安全性，也因为现在在很多环境下有对 HTTPS 协议强制的要求： 苹果的应用审核要求苹果在 iOS 9 当中首次推出的一项安全功能，它会强制应用通过 HTTPS(而不是 HTTP)连接网络服务，通过 HTTPS 加密来保障用户数据安全 微信小程序对 API 接口的要求： 2、域名 API 可以使用专有域名，如：https://api.example.com。也可以跟随在主域名下通过路径的前缀来区分：https://example.com/api。GitHub 的 API Host： 3、版本 服务器对外的 API 应该受到版本的控制，通常版本号可以放在：api host、请求头、请求 PATH 里面。建议不要放到请求头部，因为这样不太直观。Github API 的做法是放到了 PATH 里面。 4、路径endpoint, 每个endpoint代表一种资源。一般来说往往使用和数据库表名的复数形式，如： https://example.com/api/v1/usershttps://example.com/api/v1/employees HTTP 动词GET/POST/PUT/PATCH/DELETE。在这里PUT表示全量更新、PATCH表示部分的更新。 RESTFul 风格的 API 是一种规范一种约定，在某些环境可能不能完全按照规范来实施。例如： 1、微信小程序底层的http请求没有支持 PATCH 这一 HTTP 动词，需要使用其他 HTTP 动词来规避这个问题。 2、对于一些 API 比较难以对应到某一种资源，例如：登录类的接口等。 七牛 portal 的登录和登出接口： 如果脱离这种设计应该反思，一定要再三考虑是不是必要？有没有其他方案可以避免破坏 RESTful 风格。例如：登录接口的 endpoint 通常设计成：/signin或者 /login。但是换个角度，登录也是在请求某一种资源：session。完全可以把登录类的接口设计成是对session这一资源的操作。而 Github 就是这么设计的：https://github.com/session。 Github 的接口： API 的兼容性API 系统框图： 随着需求不断迭代，API 接口也在不断的演化。API 设计应该尽量兼容之前的版本。因为客户端通常包含了：Android、IOS、Web。客户端软件通常安装在用户机器上，当 服务器更新版本，API 接口升级的时候，用户必须升级产品到最新的版本才能正常使用。当然我们可以在老版本的客户端要求用户强制升级，但是这样会带来比较糟糕的用户体验。正确的做法是，服务器尽量兼容最新的 2-3 个版本的 API 接口。同时做好客户端版本用户数量的统计，当低版本的客户端使用量降低到一定程度的时候，服务器再考虑强制用户升级并且废弃老版本的 API 接口。 API 签名格式一个上线使用的 API 再想改它的签名，会因为兼容性的问题痛苦不堪。因此，API 签名的设计初期，定要经过反复推敲，尽量避免上线后的改动。如果一个系统出现了多套的 API 签名格式，那么我们就不得不在 API gateway、或者客户端写很多冗余的代码来处理这个问题。因此 API 设计的时候，就应该做到用最简洁直观的格式去支持所有的需求。 幂等性幂等的定义：一个操作如果多次任意执行所产生的副作用，均与一次执行的副作用相同。幂等机制的核心是为了保证资源唯一性，客户端重复提交或服务端的多次重试只会产生同样的副作用。在一些客户端网络环境比较差或者服务器拥堵的情况下调用方可能会重试接口。 举个例子：当一笔订单开始支付，在支付请求发出之后，在服务端发生了扣钱操作，接口响应超时了，调用方重试了一次。是否会多扣一次钱？ 幂等实现的步骤 生成幂等 Token 客户端和服务器端通过这个 Token 来识别，这实际上是同一个请求还是同一请求的多次尝试。这种在同一个请求上具备唯一标识的元素，可以由客户端生成，也可以由服务器生成。常见的有使用UUID ，或者Snowflake算法等。 确保唯一性 服务器如何通过 Token 确保唯一性? 最常用的做法是利用数据库。比如把幂等 Token 所在的数据库表的列作为唯一索引。但是对于分布式（分库分表）环境下就不能用唯一索引了。我们可以先查询一次数据库，然后判断是否约束的资源字段存在重复，没有的重复时再进行插入操作。考虑并发的场景我们还需要使用分布式锁。 HTTP 的幂等性 GET、获取数据，不会产生副作用，所以是幂等的。HEAD、不应用有副作用，也是幂等的OPTIONS 主要用于获取当前 URL 所支持的方法，所以也是幂等的DELETE、调用一次和 N 次对系统产生的副作用是相同的。POST、多次调用会创建多个资源，不满足幂等性。PUT/PATCH、同一个资源更新一次和多次产生的副作用是一样的，满足幂等性 幂等漏洞 完全的幂等操作比较难以实现，在一个API的请求链路上通常涉及多个服务，其中任意一个服务不满足幂等性就会出现幂等漏洞。 安全性 身份验证 标示用户的身份：Session/Cookie、JWT。 接口签名 接口签名防止参数被恶意篡改，可以对请求参数进行排序拼接成一个字符串，然后对字符串进行加密。得到一个 sign 参数，传递给服务器，服务器拿到客户端请求 sign 参数进行解密，然后跟客户端传递的参数进行对比。判定参数的合法性。 重放攻击 接口签名用于防止参数被恶意篡改。但是不能阻止你的请求被原封不动地再发送一次，两次…n次。使用timestamp和nonce来做的防止重放机制。具体做法是：客户端请求服务器的时候会带上时间戳和随机字符串两个参数，服务器和客户端校准时间，服务器对于收到时间戳误差大于60s的请求之间拒绝。同时服务器缓存nonce在60s内，如果期间收到了同样的nonce则直接拒绝服务。 权限控制 对特定的用户永远只暴露相关的接口和权限。常用的方式如：基于角色的权限访问控制（Role-Based Access Control）。主要包含三个方面：1、用户与角色的指派；2、角色与权限的指派；3、权限控制项的管理； API 层的日志（ Logging ），要保证不记录任何敏感信息 例如说：登录的接口把账号密码写到url上，写入了日志。","link":"/2019/09/20/%E6%AF%8F%E4%B8%AA%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%83%BD%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84-API-%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86/"},{"title":"数据库设计基础","text":"需求分析数据库设计简介数据库设计步骤 需求分析 了解需要存储的数据 了解存储的数据的特点(实效性,增长过快需要分库分表) 了解数据的生命周期(归档、清理规则) 要搞清楚的问题： 实体之间的关系（1对1，1对多，多对多） 实体包含的属性有什么 有哪些属性或属性的组合可以唯一标识一个实体 逻辑分析 使用ER图建模 物理设计 考虑数据库的特点，把逻辑设计转化为物理设计。 维护优化 新需求建表 索引优化 大表拆分 逻辑设计 将需求转化为数据库的逻辑模型 通过ER图的形式对逻辑模型进行展示 和具体的DBMS无关 ER图常见的概念： 关系：一个关系对应通常所说的一张表元组：表中的一行即为一个元组属性：表中的一列称之为一个属性；每一个属性都有一个名称，称之为属性名候选码：表中的某个属性组，它可以唯一确定一个元组（唯一索引、主键）主码：主键域：属性的取值范围分量：元组中的一个属性值 数据库设计概要 数据库范式用于减少数据冗余，减少数据插入更新异常。 数据库设计范式 第一范式： 数据库中所有的字段都是不可分割的单一属性，字段的数据类型都是基本数据类型,如：整形、字符串、浮点数等。 第二范式： 数据库表中不能存在组合关键字的某一字段决定非关键字段的情况。所以第二范式只针对于有组合关键字的情况。 第三范式： 数据库表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。 BC范式： 数据库表中不存在任何字段对任意候选关键字段的传递函数依赖则符合BC范式。 物理设计 选择合适的数据库管理系统 定义数据库、表以及字段的命名规范 根据所选的DBMS系统选择合适的字段数据类型 反范式化设计（考虑效率：空间时间等） DBMS选型 版权考量 商业数据库： Oracle SQLServer 开源数据库： MySQL PgSQL 功能上 事物的支持 特殊数据类型的支持 … 操作系统 Windows系统 SQLServer Windows/类Linux SQLServer MySQL PgSQL 开发语言 .Net首选SQLServer 使用场景 互联网项目 MySQL PgSQL 企业级项目 Oracle SQLServer MySQL常用存储引擎 存储引擎 事务支持 锁的粒度 主要应用 忌用 MyISAM 不支持 表级锁 insert,select 读写频繁 MRG_MYISAM 不支持 表级锁 分段归档 全局查找过多的场景 InnoDB 支持 行级锁 事务 无 Archive 不支持 行级锁 日志记录，只支持insert,select 需要随机读取，更新，删除 Ndb Cluster 支持 行级锁 高可用 大部分应用 数据库、表以及字段的命名规范 数据库名、表名、字段名的命名规范 数据库名/表名在Windows/Mac上大小写不敏感，在其他类Unix系统上大小写敏感 字段名/索引名在所有系统上都是大小写不敏感(除非加了双引号) 定义的时候要望文生义 数据库字段类型的选择原则字段数据类型的选择原则： 存储开销 查询性能: 对数据进行比较操作时，同样的数据，字符处理往往比数字慢。 当一个列可以选择多个数据类型时，优先选择数字类型，其次是日期或二进制类型 同级别的数据类型，应该优先选择占用空间小的数据类型。 数据库数据处理以页为单位(MySQL18k每页)，列的长度越小，一次加载数据约多，数据库IO性能会有所提升 数据库如何具体选择字段类型 char和varchar 如果列中要存储的数据长度差不多是一致的，则应该考虑用char，否则应该考虑用varchar。 如果列中最大数据长度小于50Byte，则一般也考虑用char。 一般不宜定义大于50Byte的char类型列。 decimal和float decimal(numeric)用于存储精确数据，而float只能用于存储非精确数据。 float开销一般比decimal小，所以非精确数据一般选择float 时间类型 用int存储的优缺点优点：字段长度比datetime小。缺点：使用不方便，要进行函数转换。限制：由于int类型占用4个字节，最多只能存储到2038-1-19 需要存储的时间粒度年 月 日 小时 分 秒 周 数据库设计其它注意事项 如何选择主键 区分业务主键和数据库主键 业务主键用于标示业务（有可能会更改） 数据库主键为了优化数据存储（避免业务的变更带来的影响） 根据数据库的类型，考虑主键是否需要顺序增长 主键的字段类型所占用的空间要尽可能小（提高IO效率） 避免使用外键 降低数据倒入导入的效率 增加维护成本 虽然不建议使用外键约束，但是相关联的列上一定要建立索引 避免使用触发器 关于预留字段 无法准确知道预留字段的类型 无法准确知道预留字段中存储的内容 后期维护预留字段的成本和增加一个新的字段所需要的成本是相同的 严禁使用预留字段 反范式化 通过一定数据的冗余，空间换取时间的操作，违反数据库的第三范式。提高读取性能。要点： 减少表的关联数量 增加数据的读取效率 反范式化要适度 数据库维护如何维护数据字典 利用第三方工具 利用COMMENT属性，并通过information_shema查询数据字段信息 维护索引如何选择合适的列建立索引： 出现在WHERE从句,GROUP BY从句, ORDER BY从句中的列 可选择性高的列要放到索引的前面 索引中不要包含太长的数据类型 Mysql支持对TEXT类型前缀进行索引 对长类型进行MD5然后索引 太长影响IO效率(16k/page)问题 注意事项： 索引不是越多越好，过多的索引不但会降低写的效率(维护索引数据结构),还会影响读的效率(影响索引优化器)。 定期维护索引碎片 在SQL中不要使用强制索引关键字 数据库中适合的操作如何维护表的结构 使用在线变更表结构根据 MySQL5.5之前可以使用pt-online-schema-change(通过临时表) MySQL5.6之后本身支持在线表结构的变更(ALTER语句) 同时对数据字典进行维护 控制表的宽度和大小 适合的操作： 批量操作vs逐条操作 禁止使用Select * 这样的查询 控制使用用户自定义函数 不要使用数据库中的全文索引 在适当的时候进行表的水平和垂直拆分表的垂直拆分 为了控制表的宽度，可以进行垂直拆分。提高每一页存储的行数。从而提高IO效率。 经常一起查询的列放到一起 text、blob等大字段拆分到附加表中 表的水平拆分 为了控制表的大小(数据量)，可以进行表的水平拆分。把大表数据平均分到小表中。 方法： 对主键进行hash取模,把大表数据平均分配到小表中。","link":"/2018/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"},{"title":"浅析C++重载覆盖隐藏以及虚函数","text":"C++里面重载覆盖隐藏的概念经常被提及，在很多C++测试题目里面也一直有遇到，每次做这类型的题目总感觉没有彻底搞清楚，故在这里做一个总结，以后遇到类似的问题能够轻易解决。首先来看看&lt;&lt;高质量C/C++编程指南&gt;&gt;作者对几个概念的描述: 重载：（1）相同的范围（在同一个类中）；（2）函数名字相同；（3）参数不同；（4）virtual关键字可有可无。覆盖：（1）不同的范围（父子类中）（2）函数名称相同（3）参数相同（4）基类必须有virtual关键字隐藏：（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。 重载发生在一个类中，覆盖发生在子类重新实现了父类的虚函数。一般来说，只要记住了重载和覆盖，遇到其他情况只要函数同名基本可以判定为隐藏。隐藏顾名思义就是还可以被找出来，而覆盖就不存在了。重载不能仅仅根据返回值不一致来区分两个重载函数。下面看几个例子。 example1： 123456789101112131415161718192021222324252627282930313233class base{ public: int test(char x) {printf(\"base::test(char) %d \\n\", x);} virtual int test(int x) {printf(\"base::test(int) %d \\n\", x);}};class derived: public base{ public: int test(char x) {printf(\"derived::test(char) %d \\n\", x);} int test(int x) {printf(\"derived::test(int) %d \\n\",x);} virtual int test(float x){printf(\"derived::test(float) %f \\n\",x);}};int main(void){ derived obj; base* pobj = &amp;obj; derived* p2obj = &amp;obj; pobj-&gt;test((char)(100)); //(1) p2obj-&gt;test((char)(100)); //(2) ((derived*)pobj)-&gt;test((char)(100));//(5) pobj-&gt;test(100); //(3) p2obj-&gt;test(100); //(4) return (0);} 输出： 12345base::test(char) 100 derived::test(char) 100 derived::test(char) 100 derived::test(int) 100 derived::test(int) 100 说明：Base类中，因参数类型不相同，两个test的关系为重载。derived类中三个test也为重载关系，其中derived的test(char)隐藏了基类test(char)，test(int)覆盖了基类虚函数virtual int test(int)的实现，也可以说在derived的虚函数表里面用自身的test(int)替换了继承而来的test(int)。 1 pobj-&gt;test((char)(100));参数类型为char，pobj类型为base，基类test(char)与派生类test(char)的关系为派生类隐藏了基类函数。此时pobj指针类型为base所以此时调用的是基类的test(char)函数，如果此时要调用派生类的test(char)，可以把pobj抢转为derived*类型如（5）所示。同理（2）调用的是derived中的函数。 2 在derived的虚函数表中，derived中test(int)覆盖了继承而来的base中test(int)函数。（3）用基类指针指向派生类，并调用被覆盖的虚函数，发生了动态绑定，显然调用的是派生类中的test(int)。至于（4）指针指向类型为drived*调用的也是test(int)函数。 example2： 12345678910111213141516171819202122232425262728293031class Father { public: void name(){cout&lt;&lt;\"Father name\"&lt;&lt;endl;} virtual void call(){cout&lt;&lt;\"Father call\"&lt;&lt;endl;} }; class Son:public Father { public: void name(){cout&lt;&lt;\"Son name\"&lt;&lt;endl;} virtual void call(){cout&lt;&lt;\"Son call\"&lt;&lt;endl;} }; int main() { Son *s1 = new Son(); Father *f1 = (Father *)s1; f1-&gt;call(); //son call (1) f1-&gt;name(); //father name (2) ((Son*)f1)-&gt;call(); //son call (3) ((Son*)f1)-&gt;name(); //son name (4) Father *f2 = new Father(); Son *s2 = (Son*)f2; s2-&gt;call(); //father call (5) s2-&gt;name(); //son name (6) ((Father*)s2)-&gt;call();//father call(7) ((Father*)s2)-&gt;name();//father name(8) return 0; } 输出： 12345678Son callFather nameSon callSon nameFather callSon nameFather callFather name 说明：son中的name隐藏了father中的name，son中的call覆盖了father中的call。(1)发生了动态绑定输出son call。(2)指针类型是father因此输出father name。(3)动态绑定与指针实际指向的类型相关而与指针类型无关故输出son call。(4)由于当前指针类型为father前面(2)输出father name，而这里把指针类型转为son*相当与把隐藏的name函数显式调用，因此输出son name。(5)输出father call。(6)输出son name。(7)输出father call。(8)输出father name。 小结：如果函数的关系为隐藏，则判别指针(引用)类型(-&gt;符号左边的类型)，根据指针类型决定调用的是哪个函数。如果函数关系为隐藏，则判断指针具体指向的类型，根据具体指向来判断调用的函数。","link":"/2013/09/21/%E6%B5%85%E6%9E%90%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F%E4%BB%A5%E5%8F%8A%E8%99%9A%E5%87%BD%E6%95%B0/"},{"title":"重读refactoring","text":"记得刚毕业那年，在网络上寻找各种经典的计算机软件工程相关书籍来阅读，其中就包含了martin fowler的refactoring这本书。毫无项目经验的我，对书中列举的各种重构方案如: extract method、pull up method等不以为然，一方面觉得这些点都太小了，简单的移动字段，提取函数真的有那么大的效用么？这当时在我心里是一个大大的问号。另一方面在我心里一直对重构有一种偏见，总觉得它是一种对软件架构设计缺陷的补丁方案，为什么当初在设计之初没有考虑好呢？这种打补丁的方案真的好吗？ 最近重新阅读了这本书，五年来经历了大大小小多个项目，深刻体会到重构带来的价值。重构这种中庸之道，在不推翻所有代码的前提下，能够保证项目的正常交付，同时防止的代码的腐烂，这或许是最佳的工程实践方案了。 一、为什么需要重构1、需求变更软件开发领域切实的印证了那句话，不变的或许就是变化本身。程序员再项目开发的时候应该尽可能的洞悉项目未来的业务发展方向。但是，这也仅仅是一种可能。企业为了生存，需要不断的调整方向，来追求利益的最大化。需求变更或许是软件需要重构的最大原因。 2、人无完人人无完人，我们不可能在项目开发初期就把架构设计的天衣无缝。或许某一天学习到了某个好的模式，希望把它运用到项目中，这个时候我们就需要重构了。也许因为项目开发周期短，一些模块不得不采用当下最快的方式来实现，等到未来某一天希望把实现方式通过重构变更一下。 二、准备工作重构书本上列举了一系列需要重构的预判条件，这些统一称之为“坏味道”。其中包含，如：”函数过长”、“函数参数过长”、”注释过多”、”类职责不单一”等等。再遇到这些情况的适合，我们就需要仔细的审视是不是该重构了。 嗅出这些坏味道只是第一步，正如重构的序言四人帮之一Erich Gamma说的那样：设计模式是实现重构的手段，所以在执行重构之前需要对常用的软件开发模式方法有一定的了解。 重构的定义：在不改变软件外在行为的前提下，改善软件内部结构。重构书中着重说明了测试的重要性，测试直接关系到重构的成败。没有测试作为保障的前提下进行重构那将会是一场灾难。对于动态语言更是如此，没有编译期的保障下，任何一点修正都无法及时发现。 三、常用原则有了一定项目经验再回过头来看书中列举的各种重构案例，惊讶的发现，这不就是我一直在用的手段吗？原来我一直窃喜的开发方法早就有人总结并且广为流传了。其中最印象深刻的莫过于Form Template Method以及Replace Conditional with Polymorphism。Form Template Method需要对设计模式中的模版方法有一定的理解，反过来说，如果理解了模版方法会更加容易的发现它的适用场景。对于Replace Conditional with Polymorphism方案，不同的条件判断意味着不同的类别，在面向对象的大环境下很容易想到每个类别代替不同的子类。而不同的子类有不同的行为这刚好印证了面向对象编程最重要的特性：多态。 四、总结软件开发更像是一门艺术，软件产品就是一个艺术品，需要不断的细心雕琢。非常赞同人月神话作者的那句话: “软件开发最大的复杂度来自于变化。”所以隔离变化，降低复杂度将会是软件开发永恒的主题。","link":"/2018/05/09/refactoring/"},{"title":"用户系统密码安全","text":"最近闲着没事，看了几篇关于账户安全方面的文章。之前也听说过CSDN被脱裤事件。回过头翻开之前写的代码，看看自己设计的账户系统，确实包含了多处安全隐患。对于如何良好的保障用户密码安全，在这里做一个总结，方便日后查阅。 开门见山，保障密码安全方式：哈希和加盐。 哈希哈希算法是一种摘要算法，根据原始数据得出一个摘要信息，这种算法是不可逆的，即：正常情况下，通过摘要信息无法反向得出原始数据。 哈希算法通常分成两类：一、普通散列表使用的哈希算法，也称为快速哈希算法，如：MD5、SHA1、SHA256等。二、用于密码摘要的慢哈希函数Slow Hash Function，这种哈希算法主要为了降低常见密码攻击的效率而设计的。终极目标是使哈希函数的速度慢到足以令攻击者放弃，但由此造成的延迟又不至于引起用户的注意。如：Argon2、 bcrypt 、 scrypt 或 PBKDF2。 加盐对原始密码加盐是一种有效的防止常见密码攻击的方式。关于加盐的具体工作原理，请参考盐)。需要注意的是，即使你知道要对密码加盐，还是有几个需要注意的点。 不要重复使用盐使用重复的盐和不使用盐的效果几乎是一样的。使用重复的盐，攻击者一样可以\b轻松的构造出查找表，轻松攻破你的系统。 使用安全的盐既然不能使用相同的盐，那么就需要给每个用户配置不同的盐，这个时候我们会想到随机函数，如：crypto.getRandomBytes、Math.random等函数。但是这些函数都不是安全可靠的。盐值应该使用加密的安全伪随机数生成器（ Cryptographically Secure Pseudo-Random Number Generator，CSPRNG ）产生。在Node.js环境下，可以选择的方案有： uuidv4 专用的库csprng 既然我们了解了密码哈希函数和加盐的基本规则，让我们总结一下账户系统用户注册和登陆的流程： 用户注册 用户输入用户名密码发送到服务器 服务器对用户密码加盐，哈希之后 把哈希值同盐一起保存到数据库 用户登陆 从数据库取出用户对应的哈希和盐值 把用户输入的密码加入数据库取出的盐计算哈希值 对比第二步计算的哈希值和数据库取出的哈希值，如果相等则认为密码正确，反之认为密码错误。 下面了解几个常见的\b密码破解方式，这样对上面的几个保障密码安全的方式有更加深入的理解。 常见的攻击方式：暴力破解、字典攻击、查找表等。 暴力破解顾名思义就是用穷举的方式一一匹配看看密码是否正确。 字典攻击字典攻击使用包含单词、短语、常用密码和其他可能用做密码的字符串的字典文件。对文件中的每个词都进行哈希加密，将这些哈希值和要破解的密码哈希值比较。如果它们相同，这个词就是密码。字典文件是通过大段文本中提取的单词构成，甚至还包括一些数据库中真实的密码。 查找表对于破解相同类型的哈希值，查表法是一种非常高效的方式。主要理念是预先计算（ pre-compute）出密码字典中的每个密码的哈希值，然后把他们相应的密码存储到一个表里。一个设计良好的查询表结构，即使包含了数十亿个哈希值，仍然可以实现每秒钟查询数百次哈希。 其他安全方面的考量 永远不要告诉用户输错的究竟是用户名还是密码 就像通用的提示那样，始终显示：“无效的用户名或密码。”就行了。这样可以防止攻击者在不知道密码的情况下枚举出有效的用户名。 避免明文密码传输 避免明文传输的方式一般有：一、非对称加密，客户端用公钥加密，服务器端用私钥解密。二、HTTPS，在目前的环境下上HTTPS或许是最便捷的方式了。 参考文献： [1]如何正确对用户密码进行加密[2]Secure random values (in Node.js)","link":"/2018/05/27/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8/"},{"title":"通用日志模块设计","text":"在程序设计世界里，大大小小的项目都会有自己的日志模块。网络上有很多开源的Log模块，在这里算是以学习为目的重新造了一次轮子，也方便以后项目过程直接可以用上。 按照abused老师的说法，设计一个Log模块需要注意以下几点：1.按照重要程度过滤Log信息，在程序设计阶段我们会打印一些调试信息，但是在程序release的时候要把调试信息关闭了。在这里，我把Log信息按照严重程度划分为8个级别： typedef enum tagLogLevel{LC_LOG_PANIC = 0,LC_LOG_ALERT = 1,LC_LOG_CRIT = 2,LC_LOG_ERR = 3,LC_LOG_WARN = 4,LC_LOG_NOTICE = 5,LC_LOG_INFO = 6,LC_LOG_DEBUG = 7,LC_LOG_MAX = 8}LogLevel; 1. 枚举从小到大严重程度依次递减。DEBUG纯粹是调试的时候打印，INFO答应一些信息，NOTICE提示一些轻微的警告信息，以此类推。 2.按照模块过滤Log，大的项目由一些小模块组成，按照模块过滤Log利于更快的定位错误信息，系统太大，按照模块关闭一些模块，有利于我们查找错误所在，也节省了Log信息占用的资源。 3.Log模块可配置，平时写控制台应用程序只需要把Log信息输出到控制台，真正项目过程中，Log信息有可能保存在文件里，也有可能通过串口，或者网络发送给其他模块，因此Log模块输出的可配置性也是关键。 4.可变参数的支持，现在的编译器一般都支持可变参数，对于GNUC编译器还可以支持可变参数动态的参数检查： void lc_log(LcLog thiz, int level, const char format, …) #ifdef GNUCattribute(formate(printf, 2, 3)) #endif 按照printf的参数风格对lc_log函数的2，3两个参数规则检查。 5.编译器定义的一些和调试信息有关的宏。Log信息我们需要知道打印的时候，程序编译的时间，Log出自哪个文件的哪个函数等。编译器相关的一些宏主要有：__DATE__/__TIME__,标识程序编译的时间日期。__FILE__/__LINE__/__func__(GNUC)标识打印Log信息所在的文件位置信息。","link":"/2013/12/19/%E9%80%9A%E7%94%A8%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"},{"title":"动态化资源下发","text":"近一两年移动端开发领域掀起了一股动态化的浪潮。当然早几年也有诸如phoneGap, cordova等跨平台的方案。但是随着react-native, weex的出现了把这股浪潮推向了高点。动态化的一大优势在于，省去了繁琐的发版流程，避免了只是为了修改几个icon，就得等待好几天的发版审核这样痛苦的过程。通过动态化，开发者自行管理更新包。精准的控制每次迭代的资源和代码，大大的提高了产品迭代速度。 代码下发服务主要包含以下几个主要功能点： 一、静态文件托管静态文件管理主要是把每次项目迭代的更新包上传到CDN，同时还应该动态计算每次迭代的差异包，这样可以最大限度的减少移动端下载的资源体积。代码下发服务资源主要包含两个部分：1、图片资源, 2、代码。图片资源的增量比较简单，每次计算文件md5。同时把之前不存在的图片资源拷贝到新的增量包 12345678910111213141516171819202122232425262728293031323334353637383940doPatchDiff: async function (patchDir, oldPatchDir, diffPatchKey, diffPatchDir) { return new Promise((resolve, reject) =&gt; { const walker = new Walker() //创建一个临时目录放置增量包 const output = fs.createWriteStream(diffPatchDir) const archive = archiver('zip', { zlib: { level: 9 } }) archive.pipe(output) walker.on('error', reject) archive.on('error', reject) archive.on('warning', reject) output.on('close', () =&gt; { //上传增量包 this.uploadPatchDiff(diffPatchKey, diffPatchDir) .then(res =&gt; resolve(res)) .catch(reject) }) walker.on('end', () =&gt; { archive.finalize() }) walker.walk(patchDir, (filePath, isDirectory) =&gt; { if (isDirectory) return const subFilePath = path.relative(patchDir, filePath) const oldFilePath = path.join(oldPatchDir, subFilePath) //文件不存在则拷贝 if (!fs.existsSync(oldFilePath)) { archive.append(fs.createReadStream(filePath), { name: subFilePath }) } else { //判断md5 const newFileMD5 = md5File.sync(filePath) const oldFileMD5 = md5File.sync(oldFilePath) if (newFileMD5 !== oldFileMD5) { archive.append(fs.createReadStream(filePath), { name: subFilePath }) } } }) })} 代码文件做增量更新主要通过Google开源的一个diff-match-patch来实现。感觉对于js体积比较大的场景收益高一些，react-native这种比较适合。我们项目采用weex的方案，weex提倡每个页面一个js文件，通常文件的体积也比较小，在这里没有使用这个方案，而是采用和图片资源同样的处理方式。 二、语义化版本控制语义化版本管理是比较公认的一种项目管理方式。规则如下： 123456版本格式：主版本号.次版本号.修订号，版本号递增规则如下：主版本号：当你做了不兼容的 API 修改，次版本号：当你做了向下兼容的功能性新增，修订号：当你做了向下兼容的问题修正。先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 在代码下发管理后台每次新建app版本信息、上传补丁都必须采用语义化版本来命名。 三、app渠道管理IOS开发天生只有一个渠道，而Android开发渠道五花八门。有些时候，譬如说运营的app推广需求，我们可能只希望对某一个渠道做功能迭代。所以代码下发服务应该支持针对某一渠道上传资源包，更新功能。 四、下发统计动态化app之后，需要一个工具去衡量用户下载补丁效果。统计主要包含两个纬度：针对某个版本app的下发统计、针对某个补丁(某个功能点)的下发统计。 五、日志收集移动端开发往往调试，看日志会比较困难，特别是项目发布之后，需要一个方案动态收集移动端产生的日志。日志服务说复杂也复杂，说简单也比较简单。首先为了移动端避免频繁发送请求，移动端应该有一个队列，对于同一种类型的错误，只是间隔的收集一次。其次，服务端需要对客户端发送上来的日志做一些处理，主要包括： 利用map文件定位原始出错的位置，方便快速定位问题。 日志入库，方面后续做日志分析。可以使用第三方的日志服务，如阿里云SLS，或者AWS CloudWatch。也可以利用第三方工具，如Elasticsearch 自行搭建日志分析服务。 日志报警。通过对日志分级，对于等级高于warning或者error日志的信息。应当及时报警通知开发人员。如果原有项目已经对接了第三方报警系统如promethues，这里需要做一个适配。 六、管理后台页面所有的以上功能点，最终都希望有一个可视化的方案能够呈现在用户面前。包括但不限于：项目管理、统计查询、补丁上传等。 项目源代码：assets-push","link":"/2018/04/22/%E8%B5%84%E6%BA%90%E4%B8%8B%E5%8F%91%E6%9C%8D%E5%8A%A1/"},{"title":"块级元素于行内元素","text":"块级元素与行内元素区别以及联系 为了更好的进行CSS样式布局，html元素可以分为两类：块级元素以及行内元素。按照元素内容的显示方式又可以分为替换元素与非替换元素，把这几个概念搞清楚，CSS应该算入门了吧！ 块级元素块级元素汇总(含HTML5)： address、 article、aside、blockquote、canvas、dd、div、dl、fieldset、figcaption、figure、footer、form、h[1-6]、header、hgroup、hr、li、main、nav、noscript、ol、output、p、pre、section、table、tfoot、ul、video 块级元素基本特性： 1、如果没有设置宽度将会填充父级控件 2、可以设置内边距、外边距属性 3、在没有浮动定位的情况下，块级元素的高度将会根据子控件的高度做相应的扩展 4、在没有浮动定位的情况下，块级元素将会放置在前一个元素的下边一行,后一个元素也会在新行开始 5、忽略vertical-align属性 6、遵从text-align属性 所以说，如果希望块级元素水平填充父及控件，没有必要给它设置一个宽度为100%。因为这样可能会导致一些意想不到的问题。 行内元素行内元素汇总(含HTML5)： b, big, i, small, ttabbr, acronym, cite, code, dfn, em, kbd, strong, samp, time, vara, bdo, br, img, map, object, q, script, span, sub, supbutton, input, label, select, textarea 行类元素基本特性： 1、跟随文本内容来布局 2、不会类似于块元素换行 3、布局的时候考虑字符间隔宽度设定 4、忽略上下外边距、但可以设置左右外边距以及内边距 5、忽略宽度、高度设置 6、如果被浮动了将会自动变成一个块级元素，遵从块级元素特性 7、遵从vertical-align属性设置 8、忽略text-align属性 替换元素常见替换元素： img,object,input,select,textarea,button 替换元素基本性质： 1、可以有自己的固有尺寸(通过元素本身设置) 2、有视觉格式化需求、类似于块级元素 3、可以为行内替换元素设置宽、高 替换元素的具体显示以及尺寸通过外部资源来设定。除了替换元素，其他元素都称为非替换元素。","link":"/2016/08/12/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E4%BA%8E%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"},{"title":"Vue数据绑定(一)","text":"Vue作为当下炙手可热的前端三大框架之一，一直都想深入研究一下其内部的实现原理，去学习MVVM模式的精髓。如果说MVVM是当下最流行的图形用户界面开发模式，那么数据绑定则是这一模式的根基。这也是我为什么要从数据绑定开始了解Vue的原因。 本篇文章首先从Vue构建开始，后面主要了解methods、data的执行过程以及原理，结合Vue文档来分析，做到知其然且知其所以然。对于计算属性、组件系统、指令等将在后续文章中分析。 源代码基于vue1.0，最新版本为2.x，其中的差异我会在文章尽量列出来。 Vue构造过程1234function Vue (options) { this._init(options)} Vue构造函数调用了一个_init函数，Vue所有的内置属性和方法都以_或者$开头： 12345//util/lang.jsexports.isReserved = function (str) { var c = (str + '').charCodeAt(0) return c === 0x24 || c === 0x5F} _init函数调用了若干个初始化函数其中就包含了一个初始化状态属性相关的函数： 12345678//instance/state.jsexports._initState = function () { this._initProps() this._initMeta() this._initMethods() this._initData() this._initComputed()} 看到调用函数的名称都知道是什么意思，这里主要研究一下_initMethods和_initData两个函数的实现原理。其余的会在后续文章分析。 _initMethods: 12345678exports._initMethods = function () { var methods = this.$options.methods if (methods) { for (var key in methods) { this[key] = _.bind(methods[key], this) } }} 对于methods的初始化相对比较简单，这个函数的主要作用就是把用户定义在methods属性内的一些方法绑定到当前的Vue实例中。由于ES6的箭头函数会导致bind失败，这也是为什么Vue在文档中提示： 不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 _initData:12345678910111213141516171819202122exports._initData = function () { var propsData = this._data var optionsDataFn = this.$options.data var optionsData = optionsDataFn &amp;&amp; optionsDataFn() if (optionsData) { this._data = optionsData for (var prop in propsData) { if (process.env.NODE_ENV !== 'production' &amp;&amp; optionsData.hasOwnProperty(prop)) { _.warn( 'Data field \"' + prop + '\" is already defined ' + 'as a prop. Use prop default value instead.' ) } if (this._props[prop].raw !== null || !optionsData.hasOwnProperty(prop)) { _.set(optionsData, prop, propsData[prop]) } } } //...} 对于子组件而言，propsData表示父组件传递过来的数据，因为initProp先执行_data填充的是父组件传递过来的数据。optionsDataFn表示组件自身的数据。 为什么这里看到的是一个函数呢？这是因为在Vue的初始化函数_init内调用了util/option.js下的mergeOptions这个方法，为了方便合并父组件和子组件的数据，它定义了一系列策略把组件传入的参数替换了。为了避免父组件的数据被子组件原生的数据覆盖需要做一次判定，发现有数据覆盖就警告用户。需要注意的是属性值为null且子组件原生就有的数据字段是不会被覆盖的。 在把数据合并之后，接下来要对组件数据做一个代理： 1234567891011//...var data = this._data// proxy data on instancevar keys = Object.keys(data)var i, keyi = keys.lengthwhile (i--) { key = keys[i] this._proxy(key)}//... 数据代理的作用就是为了实现：vm.prop === vm._data.prop的效果。代码位置在instance/state.js下的_proxy函数: 12345678910111213141516171819exports._proxy = function (key) { if (!_.isReserved(key)) { // need to store ref to self here // because these getter/setters might // be called by child scopes via // prototype inheritance. var self = this Object.defineProperty(self, key, { configurable: true, enumerable: true, get: function proxyGetter () { return self._data[key] }, set: function proxySetter (val) { self._data[key] = val } }) }} 为了避免覆盖Vue内置的属性所以做一次判定，接下来就是对数据的访问做一个代理。 仅仅代理数据是不够的，接下来要看到的是监控数据的变化： 12345exports._initData = function () { //... // observe data Observer.create(data, this)} Observer.create是Vue响应式数据绑定的核心: 1234567891011121314151617181920212223Observer.create = function (value, vm) { if (!value || typeof value !== 'object') { return } var ob if ( value.hasOwnProperty('__ob__') &amp;&amp; value.__ob__ instanceof Observer ) { ob = value.__ob__ } else if ( (_.isArray(value) || _.isPlainObject(value)) &amp;&amp; !Object.isFrozen(value) &amp;&amp; !value._isVue ) { ob = new Observer(value) } if (ob &amp;&amp; vm) { ob.addVm(vm) } return ob} 数据监听只针对对象类型，监听对象会内嵌到被监听的对象，这样可以避免重复监听数据对象： 12345function Observer (value) {//... _.define(value, '__ob__', this)//...} 需要注意的是,Vue对象实例不会被监听，通过_isVue属性来辨别。对于被冻结的对象也是不能监听的,Vue通过接口Object.isFrozen来判定，官方文档也有说明： 这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。 Observer对象会反向引用Vue实例对象，这是为了在用户调用$delete的时候能够反向通知到Vue实例对象, 把挂在实例上的被删除属性去除： 12345678910111213141516171819exports.delete = function (obj, key) { if (!obj.hasOwnProperty(key)) { return } delete obj[key] var ob = obj.__ob__ if (!ob) { return } ob.notify() if (ob.vms) { var i = ob.vms.length while (i--) { var vm = ob.vms[i] vm._unproxy(key) vm._digest() } }} 数据的变化追踪分为两类：对象和数组类型。对象类型遍历属性监听每个属性的变化： 1234567Observer.prototype.walk = function (obj) { var keys = Object.keys(obj) var i = keys.length while (i--) { this.convert(keys[i], obj[keys[i]]) }} convert函数调用了数据追踪最关键的一个函数：1234567891011121314151617181920212223function defineReactive (obj, key, val) { var dep = new Dep() var childOb = Observer.create(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function metaGetter () { if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() } } return val }, set: function metaSetter (newVal) { if (newVal === val) return val = newVal childOb = Observer.create(newVal) dep.notify() } })}由于对象的属性可能还是一个对象或者数组。所以需要递归的追踪内嵌数据的变化。数据的监听者存放在Dep模块内。每次设置新的对象需要重新监听数据属性。 数组类型的数据监听追踪比较特殊，Vue通过拦截几个数组方法来追踪数组的变化 123456789101112function Observer (value) { //... if (_.isArray(value)) { var augment = _.hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) }} arrayMethods是一个以Array.prototype为原型的对象：//observer/array.js12var arrayProto = Array.prototypevar arrayMethods = Object.create(arrayProto) 通过_.hasProto方法判定代理数组对象的若干个方法：123function protoAugment (target, src) { target.__proto__ = src} 至此Vue的数据追踪流程执行完毕。Vue提供了两个全局方法Vue.set和Vue.delete。下面来研究一下两个函数的实现，Vue.set最终会调用到util/lang.js下的set方法： 12345678910111213141516171819202122232425exports.set = function set (obj, key, val) { if (obj.hasOwnProperty(key)) { obj[key] = val return } if (obj._isVue) { set(obj._data, key, val) return } var ob = obj.__ob__ if (!ob) { obj[key] = val return } ob.convert(key, val) ob.notify() if (ob.vms) { var i = ob.vms.length while (i--) { var vm = ob.vms[i] vm._proxy(key) vm._digest() } }} 如果设置的属性之前已经有了，这个时候直接设置就行，会促发相应的更新逻辑。如果是Vue对象则设置到_data属性内。如果数据对象不是响应式的则直接新增数据属性。这个时候不会触发视图更新等操作。反之通知相应的监听方，并且递归追踪新增的数据值。Vue官方文档有如下提示： 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性。 Vue.delete最终调用util/lang.js下的delete方法。 12345678910111213141516171819exports.delete = function (obj, key) { if (!obj.hasOwnProperty(key)) { return } delete obj[key] var ob = obj.__ob__ if (!ob) { return } ob.notify() if (ob.vms) { var i = ob.vms.length while (i--) { var vm = ob.vms[i] vm._unproxy(key) vm._digest() } }} 被删除的属性如果不是响应式的，则直接删除然后退出函数。反之，通知各个监听对象，并且通过_unproxy方法把挂在Vue实例上的属性删除。","link":"/2018/07/09/Vue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A(%E4%B8%80)/"},{"title":"electron-打包web应用","text":"时下流行的web app打包工具主要有两个，一个是国内开发者主导的nw.js，另一个是国外大厂支撑的electron。对比了nw.js以及electron之后还是选择了electron，原因主要有以下几点： 1、基于该工具已有广泛被使用的产品，如：atom、vs code等。 2、在开发者中口碑比较好，有大公司参与进来，遇到问题，提个issue能很快得到响应。 下载基于electron打包的HolaStudio。 使用webpack编译项目HolaStudio离线版本打包的时候需要把服务器、客户端打包到一个安装包内。所以第一步首先要把服务器代码混淆，为接下来打包做准备。 构建工具选择了webpack, 关于构建工具没有做很细致的筛选，因为我都不熟悉：）。所以就听从朋友建议，选择了入了webpack的坑。 关于webpack的使用，官方有详细的文档说明,github自行搜索。 webpack需要一个配置文件(webpack.config.js)，用来描述项目的环境，以及第三方插件的集成等信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144var webpack = require('webpack');var path = require('path');var fs = require('fs-extra');var packageJSON = fs.readJsonSync('./package.json');var nodeModules = {};fs.readdirSync('./node_modules') .filter(function(x) { return ['.bin', '.npminstall'].indexOf(x) === -1; }) .filter(function(y) { return !(y in packageJSON.devDependencies); }) .forEach(function(mod) { nodeModules[mod] = 'commonjs ' + mod;});module.exports = { entry: './app.js', target: 'node', context: __dirname, node: { __dirname: false, __filename: false }, output: { path: path.join(__dirname, 'output'), filename: 'output.js', externals: nodeModules, }, externals: nodeModules, plugins: [ new webpack.optimize.UglifyJsPlugin({compress: {warnings: false}}), new webpack.IgnorePlugin(/\\.(css|less)$/) ]}``` 简要的说明： - entry: 指定项目的入口文件，即启动`node`服务指定的文件 - target: 指定当前的编译环境为`node`, 其他选择有`web`、`webworker`等 - context: 指定一个路径找到`entry`文件 - node: 用于指定一些`nodejs`环境配置 __dirname=false 表示启用__dirname 变量(默认为'/'), __filename=false 表示启用__filename 变量(默认为'/index.js')。 - output: 指定编译输出文件及目录 - externals: 指定外部依赖库文件 - plugins: `webpack`插件集成，这里主要用到了一个混淆插件 运行 `webpack .` 会在当前目录下的`output` 文件夹得到编译输出文件。--- ### 安装`electron`以及相关工具 - 运行命令`npm i -g electron-prebuilt` 安装`electron`。简要说说关于`electron`的设计理念：`electron`打包的应用分为主进程和渲染进程，渲染进程使用`Chromium`来展示页面，主进程以类似创建窗口的方式创建网页。主进程具备调用系统相关服务的功能，主进程和渲染进程之间以`进程间通信`的方式交互。 更详细的`electron`[说明文档](https://github.com/electron/electron/blob/master/docs-translations/zh-CN/). *在打包`HolaStudio`的过程中，选择把`node`服务端代码放在主进程，编辑器放在一个渲染进程。* `electron`项目的构建目录结构： ![图1](http://7xsec6.com1.z0.glb.clouddn.com/electron-release.png) 在该目录下运行`electron .`即可调式`electron`应用。 所以在启动`electron`应用的过程中，需要启动`node`后台的同时创建一个渲染窗口显示编辑器。 ```javascript//处理windows 应用安装以及更新时刻的默认事件 if(require('electron-squirrel-startup')) return;var app = require('app');var path = require('path');var electron = require('electron');var BrowserWindow = require('browser-window');var globalShortcut = require('global-shortcut');var mainWindow = null;var webContents = null;//所有窗口被关闭app.on('window-all-closed', function() { // 在 OS X 上，通常用户在明确地按下 Cmd + Q 之前 // 应用会保持活动状态 if(process.platform != 'darwin') { app.quit(); }});//当前应用准备退出app.on('will-quit', function() { globalShortcut.unregisterAll();});// 当 Electron 完成了初始化并且准备创建浏览器窗口的时候app.on('ready', function() { global.mainProcess = app; require('./hola_studio.js'); registerShortcut();});//hola_studio 服务器发出`done`事件后，准备渲染编辑器界面app.on('done', function(url) { var electronScreen = electron.screen; var size = electronScreen.getPrimaryDisplay().workAreaSize; mainWindow = new BrowserWindow({resizable: true, width: size.width, height: size.height, title: 'HolaStudio'}); mainWindow.loadURL(url); webContents = mainWindow.webContents; mainWindow.on('closed', function() { mainWindow = null; webContents = null; });});//注册快捷键用于打开开发者工具以及刷新当前页面function registerShortcut() { function doRegister(cmd, callback) { globalShortcut.register(cmd, callback); } doRegister('F12', function() { var win = BrowserWindow.getFocusedWindow(); win.webContents.toggleDevTools(); console.log(\"toggleDevTools F12\"); }); //windows 平台下`F12`按键按下收不到消息(貌似还没有解决方案)，所以写了一个替代按键 doRegister('F6', function() { var win = BrowserWindow.getFocusedWindow(); win.webContents.toggleDevTools(); console.log(\"toggleDevTools F6\"); }); doRegister('F5', function() { var win = BrowserWindow.getFocusedWindow(); win.reload(); console.log(\"refresh\"); }); return;} 如果之前有做过MFC、QT类GUI的开发，对electron这样的工作流程一定非常熟悉。 安装electron-builder工具来编译安装包electron-builder把几个不同平台的安装包编译工具集成到一起，得到一个统一的接口，方便使用。 electron-builder 建议把构建目录分为两层，上面一层主要管理编译工具、构建所需的资源以及构建的输出，称之为dev 目录。下面一层则为以electron为入口的工程目录，称之为app 目录。 dev目录预览： app目录预览： 需要做的工作很简单： 安装构建工具(electron、electron-prebuilder) 修改dev目录下package.json指定编译脚本 修改app目录下package.json指定编译选项 运行脚本编译安装包 dev 目录下package.json预览: { \"name\": \"HolaStudio\", \"version\": \"0.0.1\", \"homepage\": \"http://studio.holaverse.cn\", \"description\": \"HolaStudio Release Version.\", \"scripts\": { \"dist\": \"npm run dist:linux &amp;&amp; npm run dist:win\", \"dist:osx\": \"build --platform darwin --arch all -d\", \"dist:win\": \"build --platform win32 --arch all -d\", \"dist:linux\": \"build --platform linux --arch all -d\" }, \"keywords\": [ \"HolaStudio\" ], \"author\": \"holaverse Tech Inc.\", \"license\": \"ISC\", \"devDependencies\": { \"electron-builder\": \"^2.11.0\", \"electron-prebuilt\": \"^0.37.2\" }, \"build\": { \"osx\": { \"title\": \"HolaStudio\", \"background\": \"build/background.png\", \"icon\": \"build/icon.icns\", \"icon-size\": 128, \"contents\": [ { \"x\": 355, \"y\": 125, \"type\": \"link\", \"path\": \"/Applications\" }, { \"x\": 155, \"y\": 125, \"type\": \"file\" } ] } } } scripts字段指定npm编译不同平台的运行脚本。 build指定编译时载入的资源配置 app 目录下package.json增加编译时配置选项(最新版本electron-builder已经把它提出到dev目录下的package.json) \"build\": { \"asar\": false, \"iconUrl\": \"http://7xsec6.com1.z0.glb.clouddn.com/icon.ico\", \"app-bundle-id\": \"holaverse.studio\", \"app-category-type\": \"public.app-category.productivity\" }, asar告诉打包工具，不要压缩资源文件，因为在HolaStudio运行过程中，需要频繁改动项目路径下文件。 iconUrl指定windows安装包icon url app-bundle-id/public.app-category.productivity,mac平台下编译选项 更详细的配置文档请看这里。 成功打包了各种平台的安装包后，后续需要做的是阅读electron文档，在有新需求的时候能够很快的处理掉。","link":"/2016/05/22/electron-%E6%89%93%E5%8C%85web%E5%BA%94%E7%94%A8/"},{"title":"nodejs-Modules-(一)","text":"Nodejs拥有一套简单的模块加载系统，在Nodejs里面文件和模块是一一对应的关系。例如：foo.js加载了同一个目录下的circle.js文件。 circle.js文件内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116const PI = Math.PI; exports.area = (r) =&gt; PI*r*r; exports.circumference = (r) =&gt; 2*PI*r; ``` `foo.js`文件内容： ```javascript const circle = require('./circle.js'); console.log(`the area of radius 4 is ${circle.area(4)}`);``` `circle`模块导出了`area`和`circumference`函数，为了根模块能够引用到它，你可以把它们添加到`exports`对象上。 **模块内部的局部变量都是私有的, 因为每个模块都被封装在一个函数内部。**上面的例中`PI`就是属于`circle`模块的局部变量。 **如果你希望导出一个函数或者一个对象，你应该把该函数或者对象赋值给`module.exports`而不是`exports`**。 --- ### 访问主模块 如果一个模块直接通过`Node.js`启动运行，`require.main`将会设置为该模块。你可以通过如下方式测试当前模块是否为主模块： ```javascript console.log(require.main === module);``` 举个例子，对于`foo.js`文件，如果通过`nodejs foo.js`运行，那么该测试将会输出`true`, 如果通过`require('foo.js')`，测试将输出`false`。 由于每个`module`对象都有一个`filename`属性，也可以通过`require.main.filename`查看主模块文件名。 --- ### 模块加载 当我们调用`require`加载外部文件的时候，将会调用`require.resolve`函数。具体的解析规则如下： ``` 在Y目录下的模块调用require(X) - 1. 如果X是一个内建核心模块， a. 返回该模块 b. 停止执行 - 2. 如果X使用`./`或者`/`或者`../`开头 a. 把(Y+X)作为文件路径来加载(LOAD_AS_FILE) b. 把(Y+X)作为目录路径来加载(LOAD_AS_DIRECTORY) - 3. 加载`node_modules(X, dirname(Y))`(LOAD_NODE_MODULES) - 4. 抛出`not found`异常 ``` **LOAD_AS_FILE(x)** - A. 如果`x`是一个文件则把`x`作为`javascript`文本文件加载。 停止 - B. 如果`x.js`是一个文件则把`x.js`作为`javascript`文本文件加载。 停止 - C. 如果`x.json`是一个文件则把`x.json`作为一个`javascript`对象来解析。 停止 - D. 如果`x.node`是一个文件则把`x.node`作为一个二进制插件。停止 **LOAD_AS_DIRECTORY(x)** - A. 如果`x/package.json`是一个文件 a. 解析`package.json`读取`main`字段. b. let m = x + `main`字段值 c. LOAD_AS_FILE(m) - B. 如果`x/index.js`是一个文件，则把`x/index.js`作为`javascript`文本文件加载。 停止 - C. 如果`x/index.json`是一个文件，则把`x/index.json`作为`js`对象来解析。停止 - D. 如果`x/index.node`是一个文件， 则把`x/index.node`作为二进制插件加载。停止 **NODE_MODULES_PATHS(START)** - 1. let PARTS = path split(START) - 2. let I = count of PARTS - 1 - 3. let DIRS = [] - 4. while I &gt;= 0, a. if PARTS[I] = \"node_modules\" CONTINUE c. DIR = path join(PARTS[0 .. I] + \"node_modules\") b. DIRS = DIRS + DIR c. let I = I - 1 - 5. return DIRS --- ### 模块缓存 模块在首次加载完毕之后会被缓存， 这意味着`require('foo.js')`不会导致`foo.js`被执行两次。 如果希望多次执行模块代码，可以导出`export`一个函数，该函数负责执行代码。 #### 模块缓存警告 + 1、模块基于被解析的名字来缓存，由于同一个模块在不同目录被加载可能会得到不同的文件名，所以`require('foo')`，不能保证总是得到相同的对象。 + 2、在一些大小写不敏感的系统，不同的文件名被系统指向同一个文件，但是缓存模块依旧认为它们是两个不同的模块，也就是说，`require('foo')`和`require('FOO')`将会得到两个不同的对象，而不考虑，`foo`和`FOO`是否是同一个文件。 --- ### 核心模块 `Nodejs`内置几个被打成二进制形式的包。内置模块将会被优先加载，例如`require('http')`将会加载内置的`http`模块，即使有一个文件名也为`http`。 **需要注意的是：核心模块在安装的时候已经和`node`可执行程序打包到一起了。** --- ### 循环加载 考虑有这样几个模块： `a.js` ```javascript console.log('a starting');exports.done = false;const b = require('./b.js');console.log('in a, b.done = %j', b.done);exports.done = true;console.log('a done'); ``` `b.js` ```javascriptconsole.log('b starting');exports.done = false;const a = require('./a.js');console.log('in b, a.done = %j', a.done);exports.done = true;console.log('b done'); main.js1234console.log('main starting');const a = require('./a.js');const b = require('./b.js');console.log('in main, a.done=%j, b.done=%j', a.done, b.done); 但main.js开始加载a.js而，a.js开始加载b.js，而b.js又开始加载a.js。为了阻止无限循环模块加载，一个未加载完成的a模块将会返回给b.js，接着b.js模块加载完毕，把exports对象返回给a.js。 于此同时main.js两个模块都加载完毕了，运行main.js输出如下： 123456789$ node main.jsmain startinga startingb startingin b, a.done = falseb donein a, b.done = truea donein main, a.done=true, b.done=true 文件模块如果指定的文件名文件不存在，那么Node.js将会尝试加载不同后缀名的文件主要有：(.js, .json, .node)。.js后缀被解析为js文本文件，.json文件被解析文js对象，.node文件被解析为node插件，通过dlopen加载。 文件夹作为模块使用文件夹是一个非常便捷的代码管理方式，提供一个统一的外部入口，供外部调用该文件夹。主要有三种方式可以达到该目的： 在文件夹的根目录建立一个package.json，使用main字段指定入口脚本文件，例如： 12345{ \"name\" : \"some-library\", \"main\" : \"./lib/some-library.js\" }``` 在当前目录下有一个`some-library`文件夹，此时调用`require('./some-library')`将会尝试加载`./some-library/lib/some-library.js`文件。如果`main`字段指定的文件找不到，`Node.js`将会报错： Error: Cannot find module ‘some-library’``` 如果在该文件夹下没有package.json,Node.js将会尝试加载： ./some-library/index.js ./some-library/index.json ./some-library/index.node 从node_modules文件夹加载如果传递给require的参数既不是内置模块，模块名称也不是以./、/、../开头，那么Node.js将会尝试寻找父目录下的node_modules文件夹。如果没有找到就再往上面一层查找，直到退回系统根目录。 举个例子：文件/home/ry/project/foo.js，调用require('bar.js')，将会查找以下node_modules文件夹： /home/ry/project/node_modules/bar.js /home/ry/node_modules/bar.js /home/node_modules/bar.js /node_modules/bar.js 从全局文件夹加载模块NODE_PATH环境变量被配置为用一系列冒号分隔的绝对路径，Nodejs将会去这些目录下寻找模块。NODE_PATH最初在前面的一些模块加载方法都没有出现的时候使用，现在慢慢变得没那么必要了。除此之外Node.js还会查找以下目录： $HOME/.node_modules $HOME/.node_libraries $PREFIX/lib/node_modules $HOME为当前用户的根目录，$PREFIX通过node_prefix来配置。 基于一些历史方面的原因，建议把模块安装在本地的node_modules文件夹下，这一加载速度最快也最可靠。 模块包装在模块执行之前，Node.js把它包装成一个函数的形式，看起来像这样： (function (exports, require, module, __filename, __dirname) { // Your module code actually lives in here }); 通过这种做法带来以下好处： 保证被let,var,const定义的变量作用域局限于模块内部，而不是全局变量。 包装了几个看起来类似于全局变量来指定该模块，例如： module和exports变量，用于从该模块导出数据到其他模块。 __filename,__dirname,指向该模块的文件绝对路径以及文件夹路径。 module对象 module.children一个数组指定了当前模块引用的其他模块。 module.exports一个对象，用于导出数据，如果希望导出的是一个函数，则应该给module.exports赋值，而不是给exports。否则会造成意想不到的后果。 exports一个对象，最初指向module.exports，如果你给它赋值，它将会指向对象，而不是最初的module.exports。类似于： function require(...) { // ... ((module, exports) =&gt; { // Your module code here exports = some_func; // re-assigns exports, exports is no longer // a shortcut, and nothing is exported. module.exports = some_func; // makes your module export 0 })(module, module.exports); return module; } module.filename模块的绝对路径名称 module.id模块id通常等于module.filename module.loaded用于判断模块是否加载完毕，或者正在加载中。 module.parent指向首次加载本模块的模块。 module.require(id) id: String 返回一个module.exports导出的对象。","link":"/2015/12/07/nodejs-Modules-(%E4%B8%80)/"},{"title":"使用passport管理第三方授权认证","text":"passport是一个为Nodejs设计的，兼容Express的认证中间件。通过第三方插件的形式(以下称为strategy)，可以应对各式各样的认证请求。passport具有高度的灵活性，并不依赖于任何一个路由，或者指定的数据存储，这样给上层开发者提供的极大的便利性。passport提供的接口也相对简单，只需要给它一个认证请求，passport会提供一个钩子函数(hook)告诉你请求失败了或者成功了。 1. passport的设计思路passport基于一个高度灵活的设计结构，主要由四个模块组成：passport插件(strategy)管理模块、执行认证操作的授权模块、framewark适配模块、session管理模块。其结构框图如下： 授权流程(引用github oath2.0来举例) 1.授权插件体系所有的passport插件都继承自passport-strategy，紧接着根据不同的授权流程又细分为OAuth2.0授权中间件、OPENID类的授权中间件、以及帐号密码类的授权中间件。这些基本的中间件官方已经有了标准的实现。开发者需要做的是去继承这些授权中间件，针对不同的业务需求，配置特定的部分参数。就可以完成一整个授权的流程。常见的OAth2.0标准的授权插件有：passport-github、passport-twitter。这些针对不同厂商的第三方Strategy体量都非常小，基本在100行代码内可以搞定，因为大部分工作都交给标准的strategy来做了。 2.framework适配passport官方的实现基于标准的Express形式的风格，也就是说，中间件的函数风格类似于： function authenticate(req, res, next)//如果需要适配其他的框架需要实现特定风格的authenticate函数。 3.session管理passport提供session的功能，如果开启该功能，则需要提供序列化，以及反序列化接口。express-session是一个很好的session管理包，所以还是让passport专注于授权认证吧！ 2. passport使用 注入第三方strategy 1234567891011121314151617181920212223242526272829303132333435function verifyProfile(accessToken, refreshToken, profile, done) { profile.accessToken = accessToken; done(null, profile);}passport.use(new GithubStrategy({clientID: '123-456-789',clientSecret: 'easdasjdklasjd',callbackURL: 'http://www.example.com/auth/github/callback'}), verifyProfile);``` passport提供`use`函数用于注入授权认证的插件、`unuse`用于注销认证插件。`verifyProfile`接口是一个`hook`，用来验证用户信息的有效性。+ 2. 授权认证 ```javascript //请求授权码app.get('/user/login/github', passport.authenricate('github', {scope: 'wl_scope'}));//获取accessToken以及请求用户信息，关闭session功能app.get('/auth/github/callback', passport.authenricate('github', {session: false, failureRedirect: '/'}));``` ---### 3. passport源码分析+ 1. 授权认证入口函数 ``` javascriptAuthenticator.prototype.authenticate = function(strategy, options, callback) { return this._framework.authenticate(this, strategy, options, callback);}; express 风格的认证函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657module.exports = function authenticate(passport, name, options, callback) { if (typeof options == 'function') { callback = options; options = {}; } return function authenticate(req, res, next) { function allFailed() { if (callback) { if (!multi) { return callback(null, false, failures[0].challenge, failures[0].status); } else { var challenges = failures.map(function(f) { return f.challenge; }); var statuses = failures.map(function(f) { return f.status; }); return callback(null, false, challenges, statuses); } } .... } (function attempt(i) { var layer = name[i]; // If no more strategies exist in the chain, authentication has failed. if (!layer) { return allFailed(); } var prototype = passport._strategy(layer); if (!prototype) { return next(new Error('Unknown authentication strategy \"' + layer + '\"')); } var strategy = Object.create(prototype); strategy.success = function(user, info) { if (callback) { return callback(null, user, info); } .... req.logIn(user, options, function(err) { if (err) { return next(err); } function complete() { if (options.successReturnToOrRedirect) { var url = options.successReturnToOrRedirect; if (req.session &amp;&amp; req.session.returnTo) { url = req.session.returnTo; delete req.session.returnTo; } return res.redirect(url); } if (options.successRedirect) { return res.redirect(options.successRedirect); } next(); } complete(); } .... //调用oauth2.0认证函数 strategy.authenticate(req, options); })(0); Oauth2.0 认证函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182OAuth2Strategy.prototype.authenticate = function(req, options) { options = options || {}; var self = this; if (req.query &amp;&amp; req.query.error) { if (req.query.error == 'access_denied') { return this.fail({ message: req.query.error_description }); } else { return this.error(new AuthorizationError(req.query.error_description, req.query.error, req.query.error_uri)); } } var callbackURL = options.callbackURL || this._callbackURL; if (callbackURL) { var parsed = url.parse(callbackURL); if (!parsed.protocol) { // The callback URL is relative, resolve a fully qualified URL from the // URL of the originating request. callbackURL = url.resolve(utils.originalURL(req, { proxy: this._trustProxy }), callbackURL); } } if (req.query &amp;&amp; req.query.code) { //根据授权码获取accessToken以及用户信息 var code = req.query.code; var params = this.tokenParams(options); params.grant_type = 'authorization_code'; params.redirect_uri = callbackURL; this._oauth2.getOAuthAccessToken(code, params, function(err, accessToken, refreshToken, params) { if (err) { return self.error(self._createOAuthError('Failed to obtain access token', err)); } self._loadUserProfile(accessToken, function(err, profile) { if (err) { return self.error(err); } function verified(err, user, info) { if (err) { return self.error(err); } if (!user) { return self.fail(info); } self.success(user, info); } try { //_verify 就是注入插件的时候指定的用户信息校验函数只有通过该函数校验，认证才算完成，用户信息被`success`挂在req.user。 if (self._passReqToCallback) { var arity = self._verify.length; if (arity == 6) { self._verify(req, accessToken, refreshToken, params, profile, verified); } else { // arity == 5 self._verify(req, accessToken, refreshToken, profile, verified); } } else { var arity = self._verify.length; if (arity == 5) { self._verify(accessToken, refreshToken, params, profile, verified); } else { // arity == 4 self._verify(accessToken, refreshToken, profile, verified); } } } catch (ex) { return self.error(ex); } }); } ); } else { //获取授权码 var params = this.authorizationParams(options); params.response_type = 'code'; params.redirect_uri = callbackURL; var scope = options.scope || this._scope; if (scope) { if (Array.isArray(scope)) { scope = scope.join(this._scopeSeparator); } params.scope = scope; } var location = this._oauth2.getAuthorizeUrl(params); this.redirect(location); }}; 获取用户信息1234567891011121314151617181920212223242526272829OAuth2Strategy.prototype._loadUserProfile = function(accessToken, done) { var self = this; function loadIt() { return self.userProfile(accessToken, done); } function skipIt() { return done(null); } //通过_skipUserProfile参数跳过不需要获取用户信息的认证。 if (typeof this._skipUserProfile == 'function' &amp;&amp; this._skipUserProfile.length &gt; 1) { // async this._skipUserProfile(accessToken, function(err, skip) { if (err) { return done(err); } if (!skip) { return loadIt(); } return skipIt(); }); } else { var skip = (typeof this._skipUserProfile == 'function') ? this._skipUserProfile() : this._skipUserProfile; if (!skip) { return loadIt(); } return skipIt(); }};//第三方插件需要重载该接口实现用户信息的获取，`passport`把该接口完全开放给开发者。OAuth2Strategy.prototype.userProfile = function(accessToken, done) { return done(null, {});}; 4. 实现自己的strategy实现实现自己的第三方passport-strategy主要有三个步骤： 继承passport-oauth2123456789101112131415161718192021function Strategy(options, verify) { options = options || {}; options.authorizationURL = options.authorizationURL || 'https://github.com/login/oauth/authorize'; options.tokenURL = options.tokenURL || 'https://github.com/login/oauth/access_token'; options.scopeSeparator = options.scopeSeparator || ','; options.customHeaders = options.customHeaders || {}; if (!options.customHeaders['User-Agent']) { options.customHeaders['User-Agent'] = options.userAgent || 'passport-github'; } OAuth2Strategy.call(this, options, verify); this.name = 'github'; this._userProfileURL = options.userProfileURL || 'https://api.github.com/user'; this._oauth2.useAuthorizationHeaderforGET(true);}/** * Inherit from `OAuth2Strategy`. */util.inherits(Strategy, OAuth2Strategy); 实现获取用户信息接口12345678910111213141516171819202122Strategy.prototype.userProfile = function(accessToken, done) { this._oauth2.get(this._userProfileURL, accessToken, function (err, body, res) { var json; if (err) { return done(new InternalOAuthError('Failed to fetch user profile', err)); } try { json = JSON.parse(body); } catch (ex) { return done(new Error('Failed to parse user profile')); } var profile = Profile.parse(json); profile.provider = 'github'; profile._raw = body; profile._json = json; done(null, profile); });} 解析用户信息函数实现12345678910111213141516var parse = function(json) { if ('string' == typeof json) { json = JSON.parse(json); } var profile = {}; profile.id = String(json.id); profile.displayName = json.name; profile.username = json.login; profile.profileUrl = json.html_url; if (json.email) { profile.emails = [{ value: json.email }]; } return profile;}; 只需要三步骤，轻松实现授权认证！，passport官网已经有非常多的第三方认证实现，为了避免重复造轮子，请先查找是否有你要的插件: Search Strategy","link":"/2016/01/07/%E4%BD%BF%E7%94%A8passport%E7%AE%A1%E7%90%86%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81/"},{"title":"译-视觉格式化模型的细节","text":"123包含块的定义元素位置以及尺寸的计算有时候涉及到一个固定的矩形，这个矩形称之为元素的包含块。元素的包含块定义如下： 1、根元素所在的包含块是一个矩形，称之为：初始包含块。对于连续介质或页面媒体，有包含尺寸大小的视口，锚定在画布的初始位置。初始包含块的方向属性等同于根元素。 2、对于其他元素，如果元素的position属性是relative或static,那么它的包含块被放置在最近的块容器祖先盒子的内容区边缘。 3、如果元素的position属性设置为fixed，那么它的包含块依据在连续介质的情况下或在页面媒体的情况下的页区域的视口来建立。 4、如果元素的position属性设置为absolute，那么它的包含块依据最近的，且positon属性被设置为absolute、relative、fixed,的祖先来建立。步骤如下： 1、如果祖先是一个行内元素，那么它的包含块是一个边界盒子包围第一个以及最后一个元素的内边距。在CSS2.1,如果行内元素跨多行，那么其包含块是未定义的。 2、否则，包含块根据其祖先的padding edge来格式化。 3、如果没有找到这样的祖先元素，那么其包含块就是最初的包含块。 在页面媒体下，一个绝对定位元素的位置关联到它的包含块，忽略任何的分页(好像页面是连续的)，元素可能被分到多个页面。 对于绝对定位的内容，被解析到页面的某个位置，而不是页面被布局的位置，或者解析到当前已经被渲染或者打印的页面，打印机或许会放置内容。 当前页面的其他位置 在随后的页面，或者 省略它 注意：一个块级元素超过了多个页或许会在不同的页有不同的宽度，或许会设备自身的限制。 12345678910111213&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"&gt;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Illustration of containing blocks&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY id=\"body\"&gt; &lt;DIV id=\"div1\"&gt; &lt;P id=\"p1\"&gt;This is text in the first paragraph...&lt;/P&gt; &lt;P id=\"p2\"&gt;This is text &lt;EM id=\"em1\"&gt; in the &lt;STRONG id=\"strong1\"&gt;second&lt;/STRONG&gt; paragraph.&lt;/EM&gt;&lt;/P&gt; &lt;/DIV&gt; &lt;/BODY&gt;&lt;/HTML&gt; 没有定位，上面文档将建立如下的包含块： For box generated by C.B is established by html initial C.B(UA-dependent) body html div1 body p1 div1 p2 div1 em1 p2 strong1 p2 如果我们修改div1的position属性： 1#div {positon: absolute; left: 50px; top: 50px} 那么它的包含块将不再是body,而是变成了最初的包含块(因为没有被定位的祖先盒子)。 如果我们把em1的position属性也修改了： 12#div {position: absolute; left: 50px; top: 50px}#em1 {position: absolute; left: 100px; top: 100px} 包含块表格现在变成了： For box generated by C.B is established by html initial C.B(UA-dependent) body html div1 initial C.B p1 div1 p2 div1 em1 div1 strong1 em1 通过修改em1的positon属性，它的包含块变成了最近的已经定位的祖先盒子(这里是div1生成的盒子)。 内容区的宽度：width属性width 可选值: \\&lt;length>|\\&lt;percentage>|auto|inherit 初始值: auto 适用对像: 所有除了行内非替换元素的对象,包括表格行、和表格行组。 百分比: 根据包含块的宽度计算 媒体: 视觉的 计算值: 百分比或者auto或者绝对长度 该属性指定了盒子的内容区域宽度。 这个属性不适用于行内非替换元素。行内非替换元素的盒子宽度将由其绘制的内容决定。顺便说一下，行内盒子依照多个盒子的行线摆放。在同一行的多个盒子的宽度通过包含块指定，但是也可以通过浮动来设置。 属性值有如下含义： length指定内容区域长度，使用一个长度单位。 percentage指定一个百分比宽度，百分比依照生成元素盒子的包含块的宽度计算。如果包含块宽度依赖于元素宽度，那么布局是未定以的。 auto宽度依赖于其他属性，下面会讨论。 给width属性设置负数是非法的。 计算宽度以及外边距元素的width、margin-right、margin-left和left、right属性用于布局，取决于生成盒子的类型。(属性值用于布局，有时被称之为被使用的值。)原则上，属性值和计算值类似，通过auto替换为恰当的值，百分比基于包含块来计算，但是它们是特殊的。以下情况需要被区分开来： 1、行内非替换元素 2、行内替换元素 3、在正常流中的块级非替换元素 4、在正常流中的块级替换元素 5、浮动非替换元素 6、浮动替换元素 7、绝对定位，非替换元素 8、绝对定位，替换元素 9、在正常流中的inlin-block,非替换元素 10、在正常流中的inline-block,替换元素 对于1-6和9-10,left和right属性值，如果是相对请为的情况下，由section 9.4.3.,定义。 行内非替换元素width属性不起作用，如果给margin-left、margin-right设置为auto,将会计算为0. 行内替换元素如果给margin-left、margin-right设置为auto,将会计算为0.如果height和width属性都设置为auto,并且元素有固有宽度，那么固有宽度作为width属性的值。 如果height和width设置为auto,并且元素没有固有宽度，但是元素有固有高度以及固有比率；或者如果width属性值设置为auto,height有其他计算值，并且元素有固有比率，那么元素宽度计算为： (used height) * (intrinsic ratio) 如果height和width属性都设置为auto,并且元素有固有比率，但是没有固有的宽度或者高度，CSS2.1定义该情况下width的值未定义。但是其建议如下：如果包含块宽度本身并不依赖于替换元素的宽度，那么width的值的计算和正常流中的块级非替换元素类似。 否则，如果width的值设置为auto,元素有固有宽度，那么固有宽度作为元素宽度。 否则，如果width的值设置为auto,但是以下情况都不满足，width属性值为300px,如果300px对于设备来说太宽，用户代理将使用最大矩形的宽度：比率为2:1，适配设备。 正常流中的块级非替换元素下面的约束必须配置其他属性进行： ‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ = width of containing block 如果width不是auto,并且’border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ + ‘border-right-width’ (加上 不为auto的 ‘margin-left’ 或者 ‘margin-right’ 的值)。大于包含块的宽度，那么任何属性值设置为auto的margin-left或者margin-right, 遵循以下规则，设置为0. 如果以上属性有一个计算值，而不是auto,这被称之为超过限制，那么其中一个属性值必须调整不同于其计算值。如果包含块的方向从左到右，那么指定给margin-right的特定值会被忽略，重置一个值，以适配等式成立。反之，如果包含块的方向从右到左，同理。 如果有一个值被指定为auto,其值根据等式计算。 如果width设置为auto,任何其他设置为auto的属性值变为auto,并且width属性值根据等式计算。 如果margin-left和margin-right设置为auto,那么它们实际的值是相等的，用于把元素相对于包含块水平居中。 正常流中的块级替换元素width属性的实际值类似于：行内替换元素.而外边距的值依据:非替换块级元素决定。 浮动，非替换元素如果margin-left或者margin-right设置为auto,那么世纪值计算为0.如果width设置为auto,那么实际值将收缩适应元素. 计算收缩适应的宽度类似于计算table cell的宽度，使用自动表布局算法。粗略的说：通过格式化内容区不换行，除非遇到换行符，得到一个优选宽度，并且计算一个恰当的最小宽度，例如：尝试任何可能的换行.CSS2.1没有定义具体的算法.第三，找到可用的宽度：在这种情况下，宽度为包含块减去另外六个盒模型属性以及可能的滚动条的宽度。 自适应宽度取: min(max(最小宽度，可用宽度)，自适应宽度). 浮动，替换元素如果margin-left或者margin-right设置为auto,实际值为0.width属性的实际值参照行内替换元素。 绝对定位，非替换元素这个章节和下面一个章节的目的，术语静态位置参考，粗略的说，一个元素的位置必须在正常流中.清晰的定义： 静态位置的包含块是一个假想的盒子，如果position属性设置为static，并且float属性设置为none,那么将作为元素的第一个盒子。(由于section 9.7的限制，这个假想计算或许需要给display属性指定一个特殊值.) 如果position属性设置为static，并且float属性设置为none, 静态位置的left属性计算从包含块的左边缘到假想外边距的左边,这将作为元素的第一个盒子。其值将是负数，如果假想盒位于包含块的左边。 静态位置的right属性计算从包含块的右边缘到假想盒的右边缘，同上。如果假想盒子位于包含块的左边，其值将会是正数。 但不是实际的计算假想盒子的尺寸，用户代理会自由猜测其可能的位置。","link":"/2016/09/05/%E8%AF%91-%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82/"},{"title":"浅析C语言数据内存布局","text":"对于程序员而言，详细了解数据内存布局十分必要，否则自己常常犯一些错误却不知为什么。只有做到对内存布局心中有数，编写程序才会游刃有余。遇到问题也能想对方向。下面就C语言内存布局做简要分析。 一.几个主要的位置段 .bss段，之前看过书上解释其为blocked started by symbol。不去追究具体含义，简单而言bas段放的是未初始化的和初始化为 0 的生命周期为全局性质的变量。先通过一段实例代码来探个究竟。 123456789101112131415161718lc@lc-Lenovo:~/work/test/demo$ cat test.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char anArray1[1024*1024];char anArray2[1024*1024] = {0};int main(int argc, char* argv[]){ static char anArray3[1024*1024]; static char anArray4[1024*1024] = {0}; return (0);}lc@lc-Lenovo:~/work/test/demo$ gcc test.c lc@lc-Lenovo:~/work/test/demo$ ls -l a.out -rwxrwxr-x 1 lc lc 7438 8月 20 15:42 a.out 可以看到可执行文件7k 12lc@lc-Lenovo:~/work/test/demo$ objdump -h a.out | grep bss 24 .bss 00400020 0804a020 0804a020 0000101c 2**5 可以看到bss段在4M. 如果我们初始化为1而不是0看结果为： 123456789101112131415161718lc@lc-Lenovo:~/work/test/demo$ cat test.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char anArray1[1024*1024];char anArray2[1024*1024] = {1};int main(int argc, char* argv[]){ static char anArray3[1024*1024];// static char anArray4[1024*1024] = {0}; return (0);}lc@lc-Lenovo:~/work/test/demo$ vim test.c lc@lc-Lenovo:~/work/test/demo$ objdump -h a.out | grep bss 24 .bss 00200020 0814a040 0814a040 00101040 2**5 这里可以验证了我们的想法，bss段只占用运行时候内存空间。 现代大多数操作系统, 在加载程序时,会把所有的 bss 全局变量清零。(在一些嵌入式设备上，我们在编写启动代码的时候，需要手动执行bss段清0.)但为保证程序的可移植性,手工把这些变量初始化为 0 也是一个好习惯,这样这些变量都有个确定的初始值。当然作为全局变量,在整个程序的运行周期内,bss 数据是一直存在的。 .data段data段主要放的是初始化为非0的生命周期为全局性质的变量。上面的例子上，我们把数组的初始化修改为非0值，可以看到数据从bss转移到data段. 123456789101112131415161718192021lc@lc-Lenovo:~/work/test/demo$ cat test.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char anArray1[1024*1024];char anArray2[1024*1024] = {0};int main(int argc, char* argv[]){ static char anArray3[1024*1024] = {1}; static char anArray4[1024*1024] = {0}; return (0);}lc@lc-Lenovo:~/work/test/demo$ objdump -h a.out |grep bss 24 .bss 00300020 0814a040 0814a040 00101040 2**5lc@lc-Lenovo:~/work/test/demo$ objdump -h a.out |grep .data 14 .rodata 00000008 08048480 08048480 00000480 2**2 23 .data 00100020 0804a020 0804a020 00001020 2**5 可以看到data段放置了初始化为非0 的变量。 12lc@lc-Lenovo:~/work/test/demo$ ls -l a.out -rwxrwxr-x 1 lc lc 1056050 8月 20 16:04 a.out 通过观察可执行文件大小我们可以发现data段即占用可执行文件空间，又占用运行时候内存空间。而bss段只占用运行时候内存空间。 .rodata段rodata 的意义同样明显,ro 代表 read only,rodata 就是用来存放常量数据的。关于 rodata 类型的数据,要注意以下几点:o 常量不一定就放在 rodata 里,有的立即数直接和指令编码在一起,存放在代码段(.text)中。o 对于字符串常量,编译器会自动去掉重复的字符串,保证一个字符串在一个可执行文件(EXE/SO)中只存在一份拷贝。o rodata 是在多个进程间是共享的,这样可以提高运行空间利用率。o 在有的嵌入式系统中,rodata 放在 ROM(或者 norflash)里,运行时直接读取,无需加载到RAM 内存中。o 在嵌入式 linux 系统中,也可以通过一种叫作 XIP(就地执行)的技术,也可以直接读取,而无需加载到 RAM 内存中。o 常量是不能修改的,修改常量在 linux 下会出现段错误。由此可见,把在运行过程中不会改变的数据设为 rodata 类型的是有好处的:在多个进程间共享,可以大大提高空间利用率,甚至不占用 RAM 空间。同 时由于 rodata 在只读的内存页面(page)中,是受保护的,任何试图对它的修改都会被及时发现,这可以提高程序的稳定性。字符串会被编译器自动放到 rodata 中,其它数据要放到 rodata 中,只需要加 const 关键字修饰就好了。 123456789101112131415161718192021222324lc@lc-Lenovo:~/work/test/demo$ cat test.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;const char anArray1[1024*1024] = {1};char anArray2[1024*1024] = {0};int main(int argc, char* argv[]){ const static char anArray3[1024*1024] = {1}; static char anArray4[1024*1024] = {0}; return (0);}lc@lc-Lenovo:~/work/test/demo$ objdump -h a.out |grep rodata 14 .rodata 00200020 08048480 08048480 00000480 2**5lc@lc-Lenovo:~/work/test/demo$ ls -l a.out -rwxrwxr-x 1 lc lc 2104590 8月 20 16:15 a.outlc@lc-Lenovo:~/work/test/demo$ objdump -h a.out |grep bss 24 .bss 00200020 0824a020 0824a020 0020101c 2**5lc@lc-Lenovo:~/work/test/demo$ objdump -h a.out |grep data 14 .rodata 00200020 08048480 08048480 00000480 2**5 23 .data 00000008 0824a014 0824a014 00201014 2**2 text 段 text 段存放代码(如函数)和部分整数常量,它与 rodata 段很相似,相同的特性我们就不重复了,主要不同在于这个段是可以执行的。 stack段 栈用于存放临时变量和函数参数。栈作为一种基本数据结构,我并不感到惊讶,用来实现函数调用,这也司空见惯的作法。直到我试图找到另外一种方式实现递归操作时,我才感叹于它的巧妙。要实现递归操作,不用栈不是不可能,只是找不出比它更优雅的方式。尽管大多数编译器在优化时,会把常用的参数或者局部变量放入寄存器中。但用栈来管理函数调用时的临时变量(局部变量和参数)是通用做法,前者只是辅助手段,且只在当前函数中使用,一旦调用下一层函数,这些值仍然要存入栈中才行。通常情况下,栈向下(低地址)增长,每向栈中 PUSH 一个元素,栈顶就向低地址扩展,每从栈中 POP 一个元素,栈顶就向高地址回退。一个有兴趣的问 题:在 x86 平台上,栈顶寄存器为 ESP,那么 ESP 的值在是 PUSH 操作之前修改呢,还是在 PUSH 操作之后修改呢?PUSH ESP 这条指令会向栈中存入什么数据呢?据说 x86 系列 CPU 中,除了 286 外,都是先修改 ESP,再压栈的。由于 286 没有 CPUID 指令,有的 OS 用 这种方法检查 286 的型号。要注意的是,存放在栈中的数据只在当前函数及下一层函数中有效,一旦函数返回了,这些数据也自动释放了,继续访问这些变量会造成意想不到的错误。 堆(heap) 堆是最灵活的一种内存,它的生命周期完全由使用者控制。标准 C 提供几个函数: malloc 用来分配一块指定大小的内存。 realloc 用来调整/重分配一块存在的内存。 free 用来释放不再使用的内存。 … 使用堆内存时请注意两个问题:alloc/free 要配对使用。内存分配了不释放我们称为内存泄露(memory leak),内存泄露多了迟早会出现 Out of memory 的错误,再分配内存就会失败。当然释放时也只能释放分配出来的内存,释放无效的内存,或者重复 free 都是不行的,会造成程序 crash。分配多少用多少。分配了 100 字节就只能用 100 字节,不管是读还是写,都只能在这个范围内,读多了会读到随机的数据,写多了会造成的随机的破坏。这种情况我们称为缓冲区溢出(buffer overflow),这是非常严重的,大部分安全问题都是由缓冲区溢出引起的。手工检查有没有内存泄露或者缓冲区溢出是很困难的,幸好有些工具可以使用,比如 linux下有 valgrind,它的使用方法很简单,大家下去可以试用一下,以后每次写完程序都应该用valgrind 跑一遍.","link":"/2014/01/21/%E6%B5%85%E6%9E%90C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"title":"基于Jaeger的分布式监控系统实践","text":"基于Jaeger的分布式监控系统实践为什么要引入监控系统微服务架构消除了传统SOA架构服务之间的耦合性，降低系统的复杂度，单个服务可以独立运行部署也提升了产品迭代速度。但是，衍生出来的问题是如何才能够有效监控每一个服务，多个服务之间互相调用如何被监控，如何更快的发现系统故障，消除系统瓶颈。随着微服务数量增多，系统并发量上升通过传统log来定位问题变得比较困难，这个时候分布式监控系统变得非常重要。 监控系统实现的理论基础现代流行的监控系统实现的理论依据主要来源于Google Dapper paper。该论文中提出了trace、span、annotations、log、采样、服务依赖分析等概念。 一个完整的客户端请求可以被称为一个trace, span是指调用过程中的一个时间区间, 也就是这个英文名的由来，一般对应一个方法或者代码块的执行。服务端收到请求后需要做相应的处理，可能是调用内部函数，也可能是通过RPC调用其他服务的功能。这些调用过程都可以被称为span。而这些span之间会有依赖关系，从而构成了一条完整的\btrace tree。为了方便应用程序开发者追踪调试问题，trace系统在实现的还应该提供相应的API方便开发者写入数据，也就是给span注入一些annotations或者log。trace系统在设计的时候必须考虑到不能影响应用系统的吞吐效率，特别是对于高并发系统需要特别注意，这个时候采样的策略变得尤其关键。在系统并发量小的时候提高采样频率、并发量上升的时候降低采样频率是一个比较好的选择。 现代监控系统的实现都在该论文基础上或多或少做了一定的修改。目前云计算基金会CNCF下的OpenTracing项目是一个厂商中立语言无关的分布式trace标准。而本文后续介绍的Jaeger分布式监控系统正是基于该标准来实现。 OpenTracing标准明确了三个重要的互相关联的类型：Tracer、Span、SpanContext。Tracer主要负责： Span创建 Tracer创建Span的时候需要指定一个名称,表明Span的含义,以及该Span之间的引用关系。 SpanContext的注入和提取 在跨进程追踪的时候,需要利用注入接口把当前trace和span的信息传递给目标进程。而目标进程需要调用提取接口取得信息。这中间的可能是通过HTTP请求、或者其他RPC框架。OpenTracing不对通信协议限制，只是提出三个注入和提取的时候需要满足指定的数据格式。 Span的实现除了必须支持应用程序设置tag、写入调试log信息，还必须支持设置用户自定义数据，该数据会随着系统调用而传递。OpenTracing标准对span常用的tag以及log信息有规范推荐。应用程序代码在接入的时候，建议遵循该规范。 SpanContext存放的是Span上下文相关的数据, 如：当前tracer id, span id, 用户自定义数据等。 关于OpenTracing更加详细的描述，可以参考官方文档。 Jaeger监控系统介绍Jaeger分布式监控系统由Uber设计并实现，现已捐赠给CNCF基金会,作为分布式环境下推荐的监控系统。Jaeger系统架构如下： 和其他监控系统类似，Jaeger主要包含一下几个模块： 应用程序探针SDK(jaeger-client) jaeger-client实现了特定语言相关的opentracing-api，应用程序调用api写入数据，client把trace信息按照应用程序指定的采样策略传递给jaeger-agent。这里用的是Thrift序列化协议,采用UDP通信。 数据传输代理(jaeger-agent) agent作为一个代理，负责把client传递上来的数据，批量发送给jaeger-collector。如图所示这里采用的是Uber自己研发的TChannal RPC框架。 数据处理中心(jaeger-collector) collector负责对agent发上来的数据进行校验、创建索引、分析、汇总、存储。从图示可以看到collector还有一个功能是控制agent的采样频率。从而降低对应用程序系统的影响。 UI(jaeger-ui) ui模块负责从持久化存储中读取数据，在前端页面展示出来。除此之外jaeger-ui还能展现系统依赖拓扑图。 Jaeger监控系统部署Jaeger在部署过程中需要用到以下包几个镜像。 组件名称 镜像地址 jaeger-agent hub.docker.com/r/jaegertracing/jaeger-agent/ jaeger-collector hub.docker.com/r/jaegertracing/jaeger-collector/ jaeger-query hub.docker.com/r/jaegertracing/jaeger-query/ jaegertracing/jaeger-cassandra-schema hub.docker.com/r/jaegertracing/jaeger-cassandra-schema/ cassandra https://hub.docker.com/r/library/cassandra/ 我们可以通过docker命令依次启动组件镜像，或者通过docker-compose来部署。 通过docker命令部署 启动cassandra数据库 docker run –rm -it –name cassandra -v /Users/ytx/cassandra/datadir:/var/lib/cassandra -p 9042:9042 cassandra:3.11 初始化数据库表结构 docker run –link cassandra –rm jaegertracing/jaeger-cassandra-schema 启动jaeger-collector连接到数据库 docker run –rm -it \\ -p 14267:14267/tcp \\ -p 14268:14268/tcp \\ -p 9411:9411/tcp \\ -e CASSANDRA_KEYSPACE=jaeger_v1_dc1 \\ -e CASSANDRA_SERVERS=192.168.33.99 jaegertracing/jaeger-collector 这里14267端口用于接受Agent发送上来的数据。14268端口用于接受Client直接发送上来的数据。在实际部署的时候CASSANDRA_SERVERS配置要做相应修改。 启动Agent docker run –rm -p5775:5775/udp -p6831:6831/udp -p6832:6832/udp -p5778:5778/tcp jaegertracing/jaeger-agent /go/bin/agent-linux –collector.host-port=192.168.33.99:14267 Agent 5778端口用于接受Collector控制，如：采样频率变更、配置变更等。6831和6832端口表示jaeger.thrift分别通过compact thrift protocol和binary thrift protocol协议传输。5775端口用于接受zipkin.thrift数据结构。 Client默认通过6832端口发送数据。 启动JaegerUI docker run –rm -e CASSANDRA_KEYSPACE=jaeger_v1_dc1 -e CASSANDRA_SERVERS=192.168.33.99 -it -p 16686:16686/tcp jaegertracing/jaeger-query JaegerUI需要连接到cassandra数据查询数据。同时提供提供前端页面展示数据。 Jaeger目前支持cassandra和ElasticSearch作为数据持久化系统，后续会有对MySQL等支持。 通过docker-compose命令部署123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869version: '2'services: cassandra: image: cassandra:3.11 container_name: cassandra environment: - CASSANDRA_DC=dc1 - MAX_HEAP_SIZE=512M - HEAP_NEWSIZE=100M ports: - 9042:9042 restart: on-failure volumes: - /Users/ytx/cassandra/logs:/var/log/cassandra - /Users/ytx/cassandra/data:/var/lib/cassandra jaeger-cassandra-schema: image: jaegertracing/jaeger-cassandra-schema:0.9 container_name: cassandra-schema links: - cassandra environment: - MODE=test - DATACENTER=dc1 jaeger-collector: image: jaegertracing/jaeger-collector:0.9 container_name: jaeger-collector restart: on-failure links: - cassandra environment: - CASSANDRA_SERVERS=cassandra - CASSANDRA_KEYSPACE=jaeger_v1_dc1 - CASSANDRA_PORT=9042 ports: - 14267:14267/tcp - 14268:14268/tcp - 9411:9411/tcp jaeger-agent: image: jaegertracing/jaeger-agent:0.9 container_name: jaeger-agent restart: on-failure links: - jaeger-collector environment: - COLLECTOR_HOST_PORT=jaeger-collector:14267 ports: - 5775:5775/udp - 6831:6831/udp - 6832:6832/udp - 5778:5778/tcp jaeger-query: image: jaegertracing/jaeger-query:0.9 container_name: jaeger-query restart: on-failure links: - cassandra environment: - CASSANDRA_KEYSPACE=jaeger_v1_dc1 - CASSANDRA_SERVERS=cassandra ports: - 8003:16686/tcpnetworks: default: driver: bridge Jaeger集成到应用程序jaeger团队提供了针对Node.js环境的工具包jaeger-client-node。如何能够跟团队项目代码更好的契合是接下来要考虑的点。针对现有的项目，在接入Jaeger的时候是一个渐进的过程，希望能够做尽量少的修改代码。 针对Node.js生态下web服务器的路由都是采用类似connect风格，我们对常用的web框架路由做相应的包装： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function RouterProxy(router, config) { this.config = config this.proxyInstance = router }RouterProxy.create = function (config, tracer = null) { if (!config.router) { throw new Error(\"Not Setup Router\") } if (!config.proxy) { throw new Error(\"Not Setup Proxy\") } const proxyInstance = RouterCreator(config.proxy) const instance = new RouterProxy(proxyInstance, config) instance.wrap(config.router, tracer) return instance}RouterProxy.prototype.wrap = function (router, tracer = null) { if (!tracer) { tracer = opentracing.globalTracer() } constants.PROXY_NAMES.forEach(method =&gt; { this.wrapRouterMethod(router, method, tracer) }) return router}RouterProxy.prototype.wrapRouterMethod = function (router, method, tracer) { if (typeof router[method] !== 'function') { return } const that = this const doit = router[method].bind(router) router[method] = function (...args) { const length = args.length if (length &lt;= 1 || typeof args[length-1] !== 'function') { return doit(...args) } const uri = args[0] const handler = that.wrapRouterMethodHandler(args[args.length - 1], uri, tracer) args.splice(length -1, 1, handler) return doit(...args) } return}RouterProxy.prototype.wrapRouterMethodHandler = function (handler, uri, tracer) { const that = this return function (...args) { const req = that.proxyInstance.request(...args) const res = that.proxyInstance.response(...args) const url = that.proxyInstance.url(...args) const method = that.proxyInstance.method(...args) const span = extractOrCreateSpan(req, uri, tracer) span.setTag(opentracing.Tags.HTTP_METHOD, method) span.setTag(opentracing.Tags.HTTP_URL, url) span.setTag(opentracing.Tags.SPAN_KIND, 'server') const traceCtx = { span, tracer } if (that.config.customizeTags) { that.config.customizeTags(traceCtx, ...args) } args[0].traceCtx = traceCtx function spanFinised () { span.finish() } onFinished(res, spanFinised) return handler(...args) }} 通过以上方式在每个路由到达正式处理函数之前，opentracing-connect类库记录当前的http请求基本信息并把数据通过上下文参数暴露给用户处理函数，在处理完毕之后类库自动调用finish函数表示一次请求结束。需要注意的是：如果实际过程中希望记录更多的信息\b或者调用关系，需要用户参照API自己\b实现。 JaegerUI基本使用假定现有如下两个服务： Service One 12345678910111213141516171819202122232425262728293031323334353637383940const express = require('express')const request = require('request-promise')const { Tracer, RouterProxy } = require('opentracing-connect')const app = new express()const serviceName = 'One'Tracer.createGlobalTracer(serviceName, { logger: console })const Router = RouterProxy.create({ router: { type: \"express\" }}).routerProxy(express.Router())Router.get('/one', async (request, response, next) =&gt; { const result = await requestServiceTwo(request.traceCtx.span) response.json(result)})async function requestServiceTwo(span) { const peerServiceName = 'Two' span.setTag(Tracer.opentracing.Tags.PEER_SERVICE, peerServiceName) let result try { const carrier = {} const uri = 'http://localhost:8020/two' span.tracer().inject(span.context(), Tracer.opentracing.FORMAT_HTTP_HEADERS, carrier) result = await request({ uri, headers: carrier }) console.dir(result) span.log({'event': 'request_end'}) } catch(err) { span.setTag(Tracer.opentracing.Tags.ERROR, true) span.log({ 'event': 'error', 'message': err.message }) } return result}app.use(Router)app.listen(8010) Service Two 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const Koa = require('koa')const KoaRouter = require('koa-router')const request = require('request-promise')const { Tracer, RouterProxy } = require('opentracing-connect')const Redis = require('./redis')const app = new Koa()const serviceName = 'Two'const tracer = Tracer.createGlobalTracer(serviceName, { logger: console })const Router = RouterProxy.create({ router: { type: \"koa2\" }}).routerProxy(KoaRouter())Router.get('/two', async (ctx, next) =&gt; { try { const userId = 1 const result = await getUserInfo(userId, { span: ctx.traceCtx.span }) ctx.traceCtx.span.log({'event': 'request_end'}) ctx.body = { a: 1, b: 2, c: 3 } } catch(err) { ctx.traceCtx.span.setTag(Tracer.opentracing.Tags.ERROR, true) ctx.traceCtx.span.logEvent('error', { message: err.message }) } return })async function getUserInfo(id, ctx) { const span = tracer.startSpan(\"getUserInfo\", { references: [Tracer.opentracing.childOf(ctx.span.context())] }) let result try { result = await Redis.getRedisUser(id, { span }) } catch(err) { span.setTag(Tracer.opentracing.Tags.ERROR, true) span.logEvent('error', { message: err.message }) } span.finish() return result}app.use(Router.routes())app.listen(8020) 在两个服务启动的时候，分别创建了一个tracer对象，写入当前服务的名称，以及一个logger对象用于追踪\bjaeger-client的行为。 ServiceOne提供了一个请求处理函数，该处理函数接收到请求之后向ServiceTwo发起请求，而ServiceTwo向Redis服务发起请求读取用户信息，并返回给客户端。 通过POSTMAN向ServiceOne发起一个请求： 打开Jaeger-UI页面： 在Jaeger-UI页面左侧可以看到所有的服务列表，以及服务的endpoint列表。可以通过我们给应用程序设置的tag来搜索指定的trace。在POSTMAN页面可以看到响应时间为114ms,在Jaeger-UI看到此次trace有三个服务，包含四个span, trace的持续时间是78ms比POSTMAN检测到的时间要小，这是因为从服务器到POSTMAN客户端有网络延迟的缘故。 点击trace条目： 可以看到整个调用链路： ServiceOne收到一个GET请求，endpoint为/one ServiceOne向ServiceTwo发送一个请求，endpoint为/two Servicetwo调用getUserInfo函数 getUserInfo函数向Redis服务发送一个get请求获取用户信息, 用户id为1 最终Redis服务返回用户信息,ServiceTwo将用户信息返回给ServiceOne,ServiceOne把数据返回给客户端 单击每个span条目，可以看到tag、log等信息。opentracing对span内常使用的tag以及log字段有相应的推荐。 参考文献 Google Dapper paper OpenTracing Best Pratices OpenTraing Specification OpenTracing Semantic Conventions Jaeger, a distributed tracing system Jaeger Client Node OpenTracing API for Javascript –EOF–","link":"/2017/09/10/jaeger/"},{"title":"nginx服务器完整配置","text":"基本参数配置 main context配置: worker进程启动用户、用户组1user nginx nginx; worker进程数量1worker_processes 2; master进程id存放的文件位置1pid /home/www/nginx/nginx.pid; 错误日志1error_log /home/www/nginx/log/error.log warn; 前面是文件存放的位置，后面是日志的错误等级。如果要设置为debug需要在编译nginx的时候加上--with-debug选项。 设置单个worker进程的最大连接数123events { worker_connections 512;} 这里的最大连接数\b包括了，和代理服务器的连接、和客户端的连接等。另外需要注意的是，实际同时建立的最大连接数不能超过最大允许打开的文件数量。可以通过worker_rlimit_nofile选项来配置。 设置单个worker进程最大允许打开文件数量1worker_rlimit_nofile 8192; main context配置预览: 12345678user nginx nginx;worker_processes 2;pid /home/www/nginx/nginx.pid;error_log /home/www/nginx/log/error.log warn;worker_rlimit_nofile 2048;events { worker_connections 1024;} main context的配置可以参考ngx_core_module。 http block配置: 设置http请求日志1234log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"';access_log /home/www/nginx/log/access.log main; 定义MIME type 到文件拓展\b名的映射123include /etc/nginx/mime.types;#默认的MIME typedefault_type application/octet-stream; 优化文件传送12345#磁盘文件从内核态直接发送到网卡设备，避免了拷贝到用户态的开销。sendfile on;#开启TCP_CORK选项，当数据包达到固定大小才开始传送。tcp_nopush on; 设置客户端连接超时时间1keepalive_timeout 65s; 当时间超过65秒，客户端到服务器的连接将会断开。可以把时间设置的稍微短一些，加快无用连接的回收。 开启基本文件目录功能1autoindex on; autoindex依赖于ngx_http_autoindex_module。 http block配置预览： 123456789101112131415http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /home/www/nginx/log/access.log main; sendfile on; tcp_nopush on; keepalive_timeout 65s;} 反向代理配置反向代理相关的配置一般都放置在nginx/conf.d目录下，以hostname命名。 虚拟主机与请求的分发12listen 443 ssl default_server;server_name bitsum.pro *.bitsum.pro; \b一个server block对应一个虚拟主机的配置，default_server当请求找不到虚拟主机的时候，该虚拟主机作为默认的虚拟主机接受请求。 定义反向代理的host、负载均衡123upstream backend_hosts { server 47.75.216.4;} upstreamblock里面可以配置负载均衡算法、权重等信息。 几种负载均衡算法： round robin 默认的均衡算法，客户端请求被\b轮流分配到上游服务器。 least_conn 新的客户端连接被分配到最少活跃连接数的上游服务器。 ip_hash 用客户端ip做为hash的key，前三位8字节决定哪一个服务器处理这个客户端请求。这种算法可以保证session一致性。 hash 基于客户端传递的数据做hash。 设置服务器权重:1234upstream backend_hosts { server host1.example.com weight=3; server host2.example.com;} 默认每一个host的权重都是1，host1接受的请求量将会是host2的三倍。 指定上游被代理的服务器、设置额外的请求头123456789101112location / { #所有请求都被转发到`backend_hosts` proxy_pass http://backend_hosts; #设置客户端请求host proxy_set_header HOST $host; #设置客户端请求协议(http、https) proxy_set_header X-Forwarded-Proto $scheme; #把客户端的真实ip通过`X-Real-IP`透传到上游服务器 proxy_set_header X-Real-IP $remote_addr; #代理服务器地址列表、上层代理服务器地址添加到后面 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;} 使用Buffer缓存数据为什么buffer能优化代理\b请求呢？ 当没有开启buffer的时候，被代理的上游服务器的数据立刻被代理服务器转送到客户端。如果客户端处理的足够快，可以关闭\bbuffer的功能，以便客户端尽可能快的获得数据。当buffer功能开启的时候，代理服务器会暂存上游服务器返回的数据，然后再反馈给客户端。如果客户端接受数据的速度过慢，nginx会关闭到代理服务器的连接。然后以适合的速度发送数据给客户端。 Buffer相关配置命令: proxy_buffering 控制是否开启buffering功能。 proxy_buffers 控制缓存代理响应的块的个数以及大小。 proxy_buffer_size 控制缓存代理响应头部的大小, 默认等于proxy_buffers配置的size大小，\b由于响应头比较小，可以适当设置小一点。(当proxy_buffering关闭的时候，依然可以使用。) proxy_busy_buffers_size 控制发送数据给客户端的缓存的大小。 proxy_max_temp_file_size 当上游服务器的响应过大的时候，会被缓存在一个临时的磁盘文件里面。该指令配置缓存文件的大小。 proxy_temp_file_write_size 当上游服务器的响应过大的时候，会被缓存在一个临时的磁盘文件里面。该指令配置一次写入缓存文件的数据大小。 proxy_temp_path 缓存临时文件存放目录。 设置Cache缓存静态数据Cache相关配置命令: proxy_cache_path基本格式：proxy_cache_path /home/www/nginx/cache levels=1:2 keys_zone=backcache:8m max_size=50m use_temp_path=off; /home/www/nginx/cache作为缓存路径，如果不存在需要新建，并且设置好目录的权限： 1234mkdir -p /home/www/nginx/cache#根据启动worker进程的用户, 这里设置为对应的用户sudo chown nginx.nginx /home/www/nginx/cachesudo chmod 700 /home/www/nginx/cache levels设置缓存的目录结构层次，缓存key的最后一个字节作为一级子目录的名称，倒数二三两个字节作为二级缓存子目录的名称。 keys_zone定义缓存区域的名称，这里称之为backcache。最多有8m的缓存key，缓存数据的最大大小为50m。 proxy_cache_key(定义缓存key的格式)基本格式：proxy_cache_key &quot;$scheme$request_method$host$request_uri$is_args$args&quot;; proxy_cache_valid基本格式：proxy_cache_valid 404 1m; 根据状态码来控制缓存的有效时间，上例中，缓存404响应的有效时间为1分钟。 启用Cache上面定义了cache的基本配置，现在要告诉nginx那里应该开启cache。 123456789101112location ~ ^/(admin|download|miner-client|mobile|static|website)/ { #使用backcache这个cache zone proxy_cache backcache; #允许客户端通过http请求头\b控制跳过缓存请求最新的数据 proxy_cache_bypass $http_cache_control; #添加一个头部信息，对于一个请求可以清晰的看到，是被缓存了、缓存失效等状态信息。 add_header X-Proxy-Cache $upstream_cache_status; proxy_pass http://backend_hosts;} 开启gzip压缩 12345678910111213141516171819202122232425262728293031323334353637server { #开启gzip压缩功能 gzip on; #设置启用gzip的http版本信息 gzip_http_version 1.0; #设置gzip压缩等级 gzip_comp_level 5; #设置当Content-Length大于256的时候启用gzip配置 gzip_min_length 256; #对所有的代理请求都启用gzip gzip_proxied any; #添加“Vary: Accept-Encoding”到请求头部告知代理服务器是否支持gzip压缩 gzip_vary on; #设置需要压缩的MIME types gzip_types application/atom+xml application/javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/svg+xml image/x-icon text/css text/plain text/x-component;} 给你的网站加上https证书要给网站开启https，那么\b你需要从证书颁发机构(CA)获得一个证书文件，letsencrypt是一个免费开放的证书颁发机构。接下来，你需要证明这个域名你实际拥有控制权，这需要通过ACME protocol协议来保障。 certbot是一个ACME的客户端，在你的主机运行它自动生成证书文件，与此同时主机不需要停机。 letsencrypt原理图： LetEncrypt会发送请求到ACME运行的服务器，校验所有权是否合法。 接下来看看如何配置： 因为系统主机安装了docker，certbot刚好也有对应的镜像文件： 12345sudo docker run -it --name certbot -p 80:80 \\ -v /home/www/nginx/html:/usr/share/nginx/html \\ -v /home/www/mycertificate/letsencrypt:/etc/letsencrypt \\ -v /home/www/mycertificate/letsencrypt-lib/:/var/lib/letsencrypt \\ certbot/certbot certonly 允许上面命令的时候，会出现一系列交互提示出现： How would you like to authenticate with the ACME CA? 1: Spin up a temporary webserver (standalone)2: Place files in webroot directory (webroot) Select the appropriate number [1-2] then [enter] (press ‘c’ to cancel): 因为代理服务器还没有启动起来，这里选择standalone模式，就把ACME当作一个临时的web服务器。 Plugins selected: Authenticator standalone, Installer NoneEnter email address (used for urgent renewal and security notices) (Enter ‘c’ tocancel): 要求填写一个邮箱地址，接受证书过期的提示，以及一些安全提醒等。 Please read the Terms of Service athttps://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You mustagree in order to register with the ACME server athttps://acme-v02.api.letsencrypt.org/directory (A)gree/(C)ancel: A 同意letsencrypt这个组织的服务条款。 Would you be willing to share your email address with the Electronic FrontierFoundation, a founding partner of the Let’s Encrypt project and the non-profitorganization that develops Certbot? We’d like to send you email about our workencrypting the web, EFF news, campaigns, and ways to support digital freedom. (Y)es/(N)o: YPlease enter in your domain name(s) (comma and/or space separated) (Enter ‘c’to cancel): 提示输入\b要开启https的域名，多个域名用逗号或者空格分开。 证书生成完毕之后会在/home/www/mycertificate/letsencrypt目录下有相应的文件，值得注意的是，多个域名共用一个证书文件。所以如果你在上一步配置了多个域名，这里也只能看到一个证书文件。 nginx 配置https证书 123456789101112server { listen 443 ssl default_server; server_name bitsum.pro *.bitsum.pro; #PEM格式的证书文件 ssl_certificate /home/www/mycertificate/letsencrypt/live/dev.bitsum.pro/fullchain.pem; #证书文件的密钥 ssl_certificate_key /home/www/mycertificate/letsencrypt/live/dev.bitsum.pro/privkey.pem; #指定https的协议版本 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 启用指定的OpenSSL ciphers ssl_ciphers HIGH:!aNULL:!MD5;} 启动nginx服务： 1sudo nginx -c /home/www/nginx/nginx.conf 完整配置文件 nginx.conf: 1234567891011121314151617181920212223242526272829303132333435user nginx nginx;worker_processes 2;pid /home/www/nginx/nginx.pid;error_log /home/www/nginx/log/error.log warn;worker_rlimit_nofile 2048;events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /home/www/nginx/log/access.log main; sendfile on; tcp_nopush on; keepalive_timeout 65s; autoindex on; proxy_cache_path /home/www/nginx/cache levels=1:2 keys_zone=backcache:8m max_size=50m use_temp_path=off; proxy_cache_key \"$scheme$request_method$host$request_uri$is_args$args\"; proxy_cache_valid 302 10m; proxy_cache_valid 404 1m; include /home/www/nginx/conf.d/*.conf; } config.d/bitsum.pro.conf: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475server { listen 80; server_name bitsum.pro; return 301 https://bitsum.pro$request_uri;}upstream backend_hosts { server 47.75.216.4;}server { listen 443 ssl default_server; server_name bitsum.pro *.bitsum.pro; ssl_certificate /home/www/mycertificate/letsencrypt/live/dev.bitsum.pro/fullchain.pem; ssl_certificate_key /home/www/mycertificate/letsencrypt/live/dev.bitsum.pro/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; proxy_buffering on; proxy_buffer_size 2k; proxy_buffers 32 8k; proxy_busy_buffers_size 16k; proxy_max_temp_file_size 2048m; proxy_temp_file_write_size 32k; location ~ ^/(admin|download|miner-client|mobile|static|website)/ { proxy_cache backcache; proxy_cache_bypass $http_cache_control; add_header X-Proxy-Cache $upstream_cache_status; proxy_pass http://backend_hosts; } location / { proxy_pass http://backend_hosts; proxy_set_header HOST $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } #设置启用gzip的http版本信息 gzip_http_version 1.0; #设置gzip压缩等级 gzip_comp_level 5; #设置当Content-Length大于256的时候启用gzip配置 gzip_min_length 256; #对所有的代理请求都启用gzip gzip_proxied any; #添加“Vary: Accept-Encoding”到请求头部告知代理服务器是否支持gzip压缩 gzip_vary on; #设置需要压缩的MIME types gzip_types application/atom+xml application/javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/svg+xml image/x-icon text/css text/plain text/x-component;} 参考文献Docker NGINX and letsencryptletsencryptcertbotunderstanding-nginx-http-proxyingngx_http_proxy_modulengx_core_modulengx_http_ssl_modulenginx-caching-guide","link":"/2018/11/11/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE/"},{"title":"Mixed-Content-混合内容","text":"项目背景Linking项目里存在一项设备视频回放功能，回放的视频文件格式为m3u8。m3u8是一种基于HTTP Live Streaming协议的文件视频格式。对于该类型的视频文件解析步骤如下： HLS依赖浏览器提供的Media Source Extensions API来完成组合，使之能够使用&lt;audio&gt;和&lt;video&gt;来进行播放。所以第一步需要Browser API Check。可以通过caniuse来查询API的支持情况。 第二步加载视频文本文件Load Mainfile。文件内容大致如下： 123456789101112131415#EXTM3U#EXT-X-VERSION:3#EXT-X-PLAYLIST-TYPE:VOD#EXT-X-TARGETDURATION:11#EXTINF:10.000,url_462/193039199_mp4_h264_aac_hd_7.ts#EXTINF:10.000,url_463/193039199_mp4_h264_aac_hd_7.ts#EXTINF:10.000,url_464/193039199_mp4_h264_aac_hd_7.ts#EXTINF:10.000,url_465/193039199_mp4_h264_aac_hd_7.ts#EXTINF:10.000,url_466/193039199_mp4_h264_aac_hd_7.ts... ts文件存放的是视频分片的二进制内容，通过浏览器的XHR加载m3u8和ts文件。 Linking项目设备视频的ts文件存放在客户的存储空间bucket，而客户存储空间的外网域名往往不会绑定https证书。这个时候在播放视频的时候，浏览器会报出一个Mix-Content错误。 定义HTTPS网站中加载的HTTP资源被称之为Mixed Content。举个例子，如果你的网站地址是：https://www.example.com，该页面包含了一个图片资源：&lt;img src=&quot;http://external.com/resource.jpg&quot;/&gt;那么这个图片资源被称之为Mixed Content。 分类W3C标准组织按照混合内容被中间人篡改攻击时的损害程度分为两个类别： 被动内容(Passive content)指的是一些纯展示型的内容，这些内容往往不会修改网页的其他部分，危险比较小，即使被中间人攻击也无大碍，根据W3C的规定这类资源内容也被归类为Optionally-Blockable。主要包含以下几类： 通过img标签加载的图片或者CSS的backgrounng-image、border-image加载的图片 通过video、source标签加载的视频资源 通过audio、source标签加载的音频资源 目前由于改类型的资源使用过于广泛，浏览器默认允许加载该类型的资源。W3C希望尽可能缩小该类型资源的范围, 不过没有一个具体的roadmap。 活跃的内容(Active content)依据W3C的标准，任何不属于Optionally-Blockable的资源内容均归为此类型。这类资源也称之为Blockable。最典型的包含：脚本和CSS资源、通过XHR发送的数据请求等。 混合内容的strict mode现代浏览器默认允许加载Optionally-Blockable的内容，而阻止加载Blockable的内容。为了确保呈现给用户界面的安全性。网页开发者可以启用更加严格的策略来控制混合内容。 使用CSP开启严格模式 CSP全称：Content-Security-Policy。它是一个而外的安全层，用于检测并削弱特定类型的攻击，如XSS和数据注入等。 使用CSP控制混合内容有两种形式： HTTP 响应头方式 Content-Security-Policy: block-all-mixed-content meta标签 浏览器的行为 以下测试基于chrome 71, 不同的浏览器可能会有差异 :) 安全小锁如果站点所有的资源都是通过安全的https请求加载，那么在地址栏将会看到一个小锁：反之会看到小锁变成一个类似惊叹号的图标： 浏览器地址栏的小锁就像是一个指示器, 告知用户当前网页是否存在安全风险。地址栏的指示器主要有三个状态： 安全–小锁 网页下所有资源都是通过https请求返回，即理想状态。 信息或不安全–惊叹号 网页下部分资源通过http请求返回，例如加载了某些Optional-Blockable的图片资源等。 不安全或危险–红色警告 主要因为chrome验证https网站提供的证书过期或者网站提供的证书不是由受信任组织发放等。 修正安全指示: 惊叹号通过upgrade-insecure-requests这个 CSP 指令页面所有 HTTP 资源，会被替换为 HTTPS 地址再发起请求。这个时候可能会出现一些资源无法访问这个时候就需要通过一个支持https的域名做一次反向代理。 修正安全指示: 不安全或危险对于证书出现过期，或者无法获取有效的https。可以考虑使用letsencrypt这个免费提供证书的服务。 加载Optionally-Blockable资源浏览器默认加载Optionally-Blockable的资源，但是会给出一些警告，例如把全站https的网页内的某个图片换成http请求： 地址栏的小锁消失了。同时打开console，可以看到浏览器给出的一个警告： 加载Blockable资源把网页的一个css资源链接从https换成http: 可以看到，浏览器默认禁止加载此类资源。 严格模式编辑网页，加入启用严格模式的meta标签： 修改图片链接地址： 查看浏览器终端： 在启用严格模式情况下，全站资源都被当作Blockable类型处理，浏览器默认报错，不允许加载这些资源。 MixedContent vs SameOriginPolicyMixedContent和SameOriginPolicy都是浏览器基于安全的设计, MixedContent可以被认为是更加严格的模式，限制的范围更广。SameOriginPolicy并没有阻止通过html的tag加载第三方资源。而MixedContent限制的更加严格。而对于XHR和Fetch发起的请求，SameOriginPolicy可以通过CORS来控制，MixedContent默认禁止，也没有相应的配置, MixedContent依托于浏览器自身的限制，而SameOriginPolicy浏览器需要依赖服务器的响应作出判定。","link":"/2019/01/28/mixed-content/"},{"title":"React周期","text":"React 提供了多个生命周期函数, 不同的生命周期函数有着各自的职责，例如： constructor constructor 函数我们通常会在这里做初始化数据的工作，例如对于 class 组件而言，我们通常在这里初始化 state（如果有的话）； render 主要负责 create ReactElement, 描述 UI的组织结构，用于 React 构建 virtual Dom； componentDidMount 在组件输出的结果被挂载到 Dom Tree 之后运行，通常会在这里发送网络请求、 一些依赖于实际 Dom 节点的操作、Subscribe 操作等。 componentWillUnmount 和 didMount 的作用相反，Unmount 函数在组件卸载之前运行，这里主要运行一些清理资源的操作，比如 clearInterval 等。 单个组件的生命周期组件首次渲染先构建一个简单的组件，并在各个生命周期函数内加上日志： 1234567891011121314151617181920212223242526272829303132import * as React from &quot;react&quot;;import { render } from &quot;react-dom&quot;;interface IAppState { value: number;}class App extends React.Component&lt;{}, IAppState&gt; { constructor(props: {}) { super(props); this.state = { value: 1 }; console.log(&quot;App constructor&quot;); } componentDidMount() { console.log(&quot;App DidMount&quot;); } componentDidUpdate() { console.log(&quot;App DidUpdate&quot;); } public render() { console.log(&quot;App render&quot;); return ( &lt;div&gt; Application value: {this.state.value} &lt;/div&gt; ); }} 刷新浏览器，获得运行结果： 123App constructor App render App DidMount 组件更新内部状态先修改部分代码，加入一个按钮以及事件处理函数，在函数内部修改 state： 123456789101112131415161718192021222324//...componentDidUpdate() { console.log(&quot;App DidUpdate&quot;);}handleUpdateValue() { this.setState(state =&gt; ({ value: state.value + 1 }))}public render() { console.log(&quot;App render&quot;); return ( &lt;div&gt; value: {this.state.value} &lt;button onClick={() =&gt; this.handleUpdateValue()}&gt; update value &lt;/button&gt; &lt;/div&gt; );}//... 点击按钮，得到运行结果： 12App render App DidUpdate 可以看到，每次点击按钮调用函数更新组件的 state ，导致 React 重新调用了render 和 DidUpdate 函数。 注意： 并不是因为 render 里面没有用到 state 就不会出发这个流程。 修改部分代码，把 state 从 render 里面移除，并增加一个定时器，定时更新 state。 12345678910111213141516171819202122//... componentDidMount() { console.log(&quot;App DidMount&quot;); setInterval(() =&gt; { this.setState(state =&gt; ({ value: state.value + 1 })); }, 2000); } public render() { console.log(&quot;App render&quot;); return ( &lt;div&gt; value: {/* {this.state.value} */} &lt;button&gt;update value&lt;/button&gt; &lt;/div&gt; ); }//... 不出意外的话，在控制台每个两秒就会输入如下结果： 12App render App DidUpdate 默认情况下的 React 够无脑的，也足够简单。只要组件 state 发生了改变就执行 re-render … 父子组件的生命周期组件首次渲染新增一个子组件，这个组件有两个 props 属性：val1、val2。 12345678910111213141516171819202122232425262728293031323334353637interface IChildrenProps { val1: number; val2: number;}class Children1 extends React.Component&lt;IChildrenProps&gt; { constructor(props: IChildrenProps) { super(props); console.log(&quot;Children1 constructor&quot;); } componentDidMount() { console.log(&quot;Children1 DidMount&quot;); } componentDidUpdate() { console.log(&quot;Children1 DidUpdate&quot;); } render() { console.log(&quot;Children1 render&quot;); return &quot;Children1&quot;; }}// App render// ... public render() { console.log(&quot;App render&quot;); return ( &lt;div&gt; app value:{this.state.value} &lt;Children1 val1={1} val2={0} /&gt; &lt;/div&gt; ); }//... 运行结果： 123456App constructor App render Children1 constructor Children1 render Children1 DidMount App DidMount 可以看到父组件的生命周期函数 constructor、render 总是总是先于子组件运行、而 DidMount 却是子组件优先于父组件运行, 这是为了在父组件的 DidMount 函数内根据子组件再做一些初始化的行为, 这个时候子组件必须确保已经被挂载到 Dom tree。 更新父组件的状态修改部分父组件代码： 1234567891011121314151617181920//... componentDidMount() { console.log(&quot;App DidMount&quot;); setInterval(() =&gt; { this.setState(() =&gt; ({ value: 1 })) }, 2000) } public render() { console.log(&quot;App render&quot;); return ( &lt;div&gt; {/* app value:{this.state.value} */} &lt;Children1 val1={1} val2={0} /&gt; &lt;/div&gt; ); } //... 运行结果： 1234App renderChildren1 renderChildren1 DidUpdateApp DidUpdate 从这个运行结果可以看到两个结论：1、子组件的 DidUpdate 先于 父组件的 DidUpdate 执行，原因同 DidMount2、默认情况下，父组件的 state 的随着定时器更新，这会导致父组件 re-render(从前面的例子可以看出来)。 父尽管没有变更任何 props，子组件也执行 re-render 行为. 组件 Unmount先来构造一个组件 Unmount 的场景： 123456789// 在父子组件都加上 Unmount 操作componentWillUnmount() { console.log('Children1 Unmount')}componentWillUnmount() { console.log(&quot;App Will Unmount&quot;);} 123456789101112131415// 构造一个 MockApp 组件function MockApp() { return &lt;span&gt;MockApp&lt;/span&gt;;}// 定一个变量，放置要挂载的组件let AppView: (React.FunctionComponent) | typeof React.Component = App;render(&lt;AppView /&gt;, document.getElementById(&quot;root&quot;));// 定时 4 秒 卸载 App 组件setTimeout(() =&gt; { AppView = MockApp; render(&lt;AppView /&gt;, document.getElementById(&quot;root&quot;));}, 4000); 构造一个 MockApp 四秒钟之后被 ReactDom 渲染到 Dom tree，替换了 App，App 组件相当于执行了一次 Unmount。 运行结果： 12App Will UnmountChildren1 Will Unmount 对于父子组件，Unmount 的顺序刚好跟 DidMount 相反，这是有意为之的设计，因为假定父组件会在 DidMount 做一些依赖于子组件的初始化操作，那么在释放资源的时候可能还是会依赖于子组件。所以父组件的 Unmount 先于子组件运行。可以参考：componentWillUnmount calls not called before owning parent’s。 React 还有其他一些生命周期这里没有一一罗列，有些已经建议废弃了，另外一些就等有机会再深入研究研究吧！ 参考文档： react-component-apireact-state-and-lifecycle","link":"/2019/10/13/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"一个 snapshot line-break 引发的讨论","text":"事情背景: 我的一位细心同事在帮我 code review 的时候发现了如下问题： 我找到源代码，并且对比了一下 git 变更历史。新版本写法：123&lt;span className=&quot;radio-tip&quot;&gt; {props.discounts[year]}折&lt;/span&gt; 改动之前的写法：123&lt;span className=&quot;radio-tip&quot;&gt; {`${props.discounts[year]}折`}&lt;/span&gt; jsx 理论上会被 babel 转化成 React.createElement 的形式，所以到 babel-playground 写了一个 demo: 1234567function Haha1(props) { return &lt;span&gt;{`${props.x}折`}&lt;/span&gt;}function Haha2(props) { return &lt;span&gt;{props.x}折&lt;/span&gt;} 经过 babel 在线编译的输出结果： 123456789&quot;use strict&quot;;function Haha1(props) { return React.createElement(&quot;span&quot;, null, &quot;&quot;.concat(props.x, &quot;\\u6298&quot;));}function Haha2(props) { return React.createElement(&quot;span&quot;, null, props.x, &quot;\\u6298&quot;);} 可见对于 Haha2 这个组件的写法，babel 编译出来的 span 会多创建一个 children。接下来需要研究一下 element 输出到 snapshot 的过程： 我使用的测试工具是 jest，跑到 jest 官网，有如下的描述： Jest uses pretty-format to make snapshots human-readable during code review。 pretty-format 就是 jest 用来生成 snapshot 的工具： 来自官网 demo： 123456789101112131415161718const onClick = () =&gt; {};const element = React.createElement('button', {onClick}, 'Hello World');const formatted1 = prettyFormat(element, { plugins: [ReactElement], printFunctionName: false,});const formatted2 = prettyFormat(renderer.create(element).toJSON(), { plugins: [ReactTestComponent], printFunctionName: false,});/*&lt;button onClick=[Function]&gt; Hello World&lt;/button&gt;*/ 在 code-sand-box 自己上手试一试： 12345678910111213import * as React from &quot;react&quot;;import prettyFormat from &quot;pretty-format&quot;;const { ReactElement, ReactTestComponent } = prettyFormat.plugins;let x = 8.5;const element = React.createElement(&quot;div&quot;, null, &quot;&quot;.concat(x, &quot;\\u6298&quot;));const formatted1 = prettyFormat(element, { plugins: [ReactElement], printFunctionName: false});console.log(formatted1); console 输出： 123&lt;div&gt; 8.5折&lt;/div&gt; 换一个写法： 123//...const element = React.createElement(&quot;span&quot;, null, x, &quot;\\u6298&quot;)//... console 输出： 1234&lt;span&gt; 8.5 折&lt;/span&gt; 原因就出在这里，我在重构代码的时候，把这行代码的编写方式换了一下，所以导致 jest 生成的 snapshot 发生了变动。pretty-format 有一个配置可以控制这个行为： min: minimize added space: no indentation nor line breaks 这个选项默认是 false，我们只要在运行 prettyFormat 的时候，打开这个选项就好了： 1234567//...const formatted1 = prettyFormat(element, { plugins: [ReactElement], printFunctionName: false, min: true});//... 得到的结果： 1&lt;span&gt;8.5折&lt;/span&gt; 因为 pretty-format 是被集成到 jest 内部，默认这个选项没有暴露出来，貌似只能通过一个序列化选项来控制 snapshotSerializers，有兴趣再研究吧~ 最后补一张 jsx 到 snapshot 的转换过程：","link":"/2020/02/21/%E4%B8%80%E4%B8%AA-snapshot-line-break-%E5%BC%95%E5%8F%91%E7%9A%84%E8%AE%A8%E8%AE%BA/"},{"title":"React Context 的基本使用姿势","text":"以下示例代码，默认的环境是： typescript latest react 16.8+ 通过这篇文章，希望能够熟悉 Context 的各种使用姿势，以及消费 Context Value 的时候需要注意的点。 Context 定义 首先来定义一个 context context.ts: 123456789import React from \"react\";interface IValue { count: number;}const context = React.createContext&lt;IValue&gt;(null);export default context; createContext 接受一个泛形，表示 context 值的类型，这里还给出了默认值是 null。注意 tsconfig 的 strictNullChecks 要先关闭 :)。创建完毕，导出这个 context 实例。 再定义一个父组件： 1234567891011121314151617181920212223interface IState { count: number;}class App extends React.Component&lt;{}, IState&gt; { state = { count: 0 }; handleUpdateCount() { this.setState(({ count }) =&gt; ({ count: count + 1 })); } render() { return ( &lt;div&gt; &lt;button onClick={() =&gt; this.handleUpdateCount()}&gt;add Inc&lt;/button&gt; &lt;p&gt;Current Value: {this.state.count}&lt;/p&gt; &lt;MyContext.Provider value={{ count: this.state.count}}&gt; &lt;Children1 /&gt; &lt;/MyContext.Provider&gt; &lt;/div&gt; ); }} context 提供数据的使用姿势：MyContext.Provider, 通过固定属性 value 传入数据, 这里传入的是一个对象。每次点击按钮更新 count, context 传入新的值会导致 消费 context 的组件 重新渲染（该行为不会受到 shouldComponentUpdate 影响）。 render Props 消费 Context 定义一个普通函数组件： 123456789import MyContext from './context'const Children1: React.FC = () =&gt; { return ( &lt;MyContext.Consumer&gt; {value =&gt; &lt;span&gt;Children1 Catch Value: {value.count}&lt;/span&gt;} &lt;/MyContext.Consumer&gt; );}; MyContext.Consumer 是 context 的使用姿势之一 (render-props), 它接受一个函数，这个函数的参数是 Context.Provider 注入的值。 注意 这个例子中，消费 context 的实际上是 MyContext.Consumer。所以当 context 内容发生变化的时候，Children1 并不会 re-render。 使用 Hooks 消费 Context 再定义一个组件： 123456import MyContext from './context'function Children4() { const context = React.useContext(MyContext); return &lt;div&gt;Children4 Catch: {context.count}&lt;/div&gt;;} 使用 Hooks 来消费 context，相对更简单了，直接 React.useContext，类型也能完好的推倒出来。 在 Class 组件内消费 Context 先定义一个 Class 组件： 12345678910import MyContext from './context'class Children3 extends React.Component { static contextType = MyContext; context!: React.ContextType&lt;typeof MyContext&gt;; render() { return &lt;div&gt;Children3 Catch: {this.context.count}&lt;/div&gt;; }} Class 组件在使用的过程中需要定义两个属性：一个 contextType，是一个静态属性；另一个 context，context 的类型可以通过 ContextType 推导出来，这样可以避免把 context.ts 里面的 IValue 类型再 import 一次。这里 context 在声明的时候使用了 !: （称之为：definite assignment assertion）, 表明这个属性是 non-null。 Context 性能优化性能优化简单可以概括为一句话： 避免做重复的事情。 避免 Provider 的 value 重复产生新值贴一段父组件的代码： 12345678910111213//... render() { return ( &lt;div&gt; &lt;button onClick={() =&gt; this.handleUpdateCount()}&gt;add Inc&lt;/button&gt; &lt;p&gt;Current Value: {this.state.count}&lt;/p&gt; &lt;MyContext.Provider value={{ count: this.state.count }}&gt; &lt;Children1 /&gt; &lt;/MyContext.Provider&gt; &lt;/div&gt; ); } //... 由于React使用引用来判断对象类型的值，来决定是否需要 re-render 所有消费这个 context 的组件。 1value={{ count: this.state.count }} 这种写法每次 render 都会传给 context 一个新的 object。这样导致每次由于其他原因父组件 re-render 的时候，所有消费这个 context 的组件都会重新 re-render。 改进一下： 12345//...&lt;MyContext.Provider value={this.state}&gt; &lt;Children1 /&gt;&lt;/MyContext.Provider&gt;//... 这样就避免了每次给 value 赋值一个新的 object。 避免重新 createElement 再来新增一段代码： 12345678910111213141516171819202122// 注意：该组件没有消费 contextfunction Children5() { console.log(&quot;render Children5&quot;); return &lt;div&gt;Children5 empth&lt;/div&gt;;}// 调整一下父组件的 render//...render() { console.log(&quot;render&quot;); return ( &lt;div&gt; &lt;button onClick={() =&gt; this.handleUpdateCount()}&gt;add Inc&lt;/button&gt; &lt;p&gt;Current Value: {this.state.count}&lt;/p&gt; &lt;MyContext.Provider value={this.state}&gt; &lt;Children1 /&gt; &lt;Children5 /&gt; &lt;/MyContext.Provider&gt; &lt;/div&gt; );}//... 点击按钮，控制台输出： 123renderrender Children1render Children5 Children5 并没有消费 context。但是每次父组件 re-render 的时候，它也 re-render 了一次。 把父组件的 render 函数用 babel 编译一下得到： 1234567render() { return React.createElement(\"div\", null, React.createElement(\"button\", { onClick: () =&gt; this.handleUpdateCount() }, \"add Inc\"), React.createElement(\"p\", null, \"Current Value: \", this.state.count), React.createElement(MyContext.Provider, { value: this.state }, React.createElement(Children1, null), React.createElement(Children5, null)));} 可以看到： 每次父组件 re-render 的时候，都调用 createElement 函数重新创建了，Children1 和 Children5。 有没有什么办法可以避免这个行为呢？答案是有的： 把 Provider 的内容提到父组件之外，使用 children props 传入： 改写 Content 1234567891011const Content: React.FC = () =&gt; { return ( &lt;&gt; &lt;Children1 /&gt; &lt;Children5 /&gt; &lt;/&gt; );};//使用父组件：render(&lt;App children={&lt;Content /&gt;} /&gt;, document.getElementById(&quot;root&quot;)); 调整父组件的 render 函数 12345//...&lt;MyContext.Provider value={this.state}&gt; {this.props.children}&lt;/MyContext.Provider&gt;//... 点击按钮，控制台输出： 1render 使用 babel 在看一下结果： 1234567const Content = () =&gt; { return React.createElement(React.Fragment, null, React.createElement(Children1, null), React.createElement(Children5, null));};render(React.createElement(App, { children: React.createElement(Content, null)}), document.getElementById(\"root\")); 父组件的 children 是一个固定值。不会在父组件重新渲染的时候变更，从而避免了不必要的 re-render。 使用 React.memo/React.PureComponent 重写 Content 组件： 12345678910const Content: React.FC = React.memo(() =&gt; { console.log('render Content') return ( &lt;&gt; &lt;Children1 /&gt; &lt;Children5 /&gt; &lt;/&gt; )}) 还原父组件的 render 函数： 1234&lt;MyContext.Provider value={this.state}&gt; &lt;Content /&gt;&lt;/MyContext.Provider&gt; 点击按钮，控制台输出： 1render 总结使用 Content 的三种姿势 render props 的方式 Hooks 的方式 Class Component 的方式 性能优化 避免 context 每次创建一个 value 对象 使用 children props 替换 jsx 使用 PureFunction/React.memo 包装组件 参考： react-context （完）","link":"/2020/02/26/React-Context-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"},{"title":"React Context 性能优化","text":"背景context 的出现良好的解决了垮多个层级的组件传递 props 的问题。 但是在使用 context 的过程中，绝大多数开发者都发现 context 有一个不太优雅的点： 只要 context 的 value 发生变化，所有消费该 context 的组件都会 re-render。 举个例子定义一个父组件和 context12345678910111213141516171819202122232425262728293031323334353637interface IState { count1: number; count2: number;}interface IContextValue { state: IState; updateState: (s: IState) =&gt; void;}const MyContext = React.createContext&lt;IContextValue | null&gt;(null);class App extends React.Component { state: IState = { count1: 0, count2: 0 }; updateState(state: IState) { this.setState(prev =&gt; ({ ...prev, ...state })); } render() { return ( &lt;div&gt; &lt;MyContext.Provider value={{ state: this.state, updateState: state =&gt; this.updateState(state) }} &gt; &lt;Children1 /&gt; &lt;Children2 /&gt; &lt;/MyContext.Provider&gt; &lt;/div&gt; ); }}render(&lt;App /&gt;, document.getElementById(&quot;root&quot;)); 定义两个子组件 12345678910111213141516171819202122232425262728293031323334353637383940const Children1: React.FC = React.memo(() =&gt; { const value = React.useContext(MyContext); return ( &lt;div&gt; Children1 (time: {Date.now()}) got: {value!.state.count1} &lt;button onClick={() =&gt; value.updateState({ ...value.state, count1: value.state.count1 + 1 }) } &gt; Update Count1 &lt;/button&gt; &lt;hr /&gt; &lt;/div&gt; );});const Children2: React.FC = () =&gt; { const value = React.useContext(MyContext); return ( &lt;div&gt; Children2 (time: {Date.now()}) got: {value!.state.count2} &lt;button onClick={() =&gt; value.updateState({ ...value.state, count2: value.state.count2 + 1 }) } &gt; Update Count2 &lt;/button&gt; &lt;hr /&gt; &lt;/div&gt; );}; 在页面中，Children1 依赖于 count1、Children2 依赖于 count2。当点击 Children1 或者 Children2 的按钮时候，会导致对方也 re-render。即使使用了 React.memo 也不行 ( 从 Children1 可以看出来)。针对这种情况， 业界几种思路，下面来具体实践一下。 拆分 Context基本原则： 把需要频繁更新的 context 内的属性单独拆出来。从而避免了其他仅仅需要低频率刷新的组件 re-render。 通过上面的例子，把 count1、count2 分别放入各自的 Context。 1234567891011121314151617// 修正 Context 定义interface IState2 { count2: number;}interface IContext2Value { state: IState2; updateState: (s: IState2) =&gt; void;}const MyContext2 = React.createContext&lt;IContext2Value | null&gt;(null);//...// Children2 const value = React.useContext(MyContext2);//... 利用 memo or useMemo基本前提： 通过 「React Context 的基本使用姿势」了解到，context会强制无脑re-render消费context的组件。我们通过把组件的内容和消费context的行为分开，并且把组件内容使用memo包装起来即可(memo会比较props`)。 memo 的方式改写 Children11234567891011121314const Content = React.memo&lt;{ count1: number }&gt;(props =&gt; { console.log(&quot;render Children1&quot;); return ( &lt;div&gt; Children1 got: {props.count1} &lt;hr /&gt; &lt;/div&gt; );});const Children1: React.FC = () =&gt; { const value = React.useContext(MyContext); return &lt;Content count1={value.state.count1} /&gt;;}; 把 Children1 的 Content 单独提出来，并使用 memo 包装起来。 useMemo 的方式同样改写 Children1 123456789101112const Children1: React.FC = () =&gt; { const value = React.useContext(MyContext); return React.useMemo(() =&gt; { return ( &lt;div&gt; Children1 {Date.now()} got: {value.state.count1} &lt;hr /&gt; &lt;/div&gt; ); }, [value.state.count1]);}; 使用 useMemo 就不用把 content 单独提出来了。值得注意的是，通过对比，可以看到： useMemo 返回的是 JSX.Element，而 memo 返回的是 JSXConstructor。 使用位运算 calculateChangedBitscreateContext 有第二个参数不太常用： 123456function createContext&lt;T&gt;( // If you thought this should be optional, see // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106 defaultValue: T, calculateChangedBits?: (prev: T, next: T) =&gt; number): Context&lt;T&gt;; calculateChangedBits 是一个函数，这个函数用来判定到底是那个 context 内的属性发生了变化。 举个例子，改写createContext: 123456789101112131415// 0x01 表示更新 count1// 0x02 表示更新 count2const MyContext = React.createContext&lt;IContextValue | null&gt;(null, function( prev, next) { if (prev.state.count1 !== next.state.count1) { return 0x01; } if (prev.state.count2 !== next.state.count2) { return 0x02; } return 0;}); Context.Consumer 提供了另外一个配合使用的 props： 1234interface ConsumerProps&lt;T&gt; { children: (value: T) =&gt; ReactNode; unstable_observedBits?: number;} unstable_observedBits 标示了该组件关注的 provider 内的状态变更。 举个例子，改写 Children1： 123456789101112131415const Children1: React.FC = React.memo(() =&gt; { return ( &lt;div&gt; &lt;MyContext.Consumer unstable_observedBits={0b01} children={value =&gt; ( &lt;&gt; Children1 {Date.now()} got: {value.state.count1} &lt;hr /&gt; &lt;/&gt; )} /&gt; &lt;/div&gt; );}); 0b01 唯一标示了 count1 这个属性更新的行为，而 Children1 只关系 count1 的变更。目前该特性处于不稳定的状态， React 官方也没有对外宣布，连文档都还没有 :) 。有个开源的状态管理库：react-tracked 就是依赖于该特性来做的状态管理。 总结 为什么要对 context 做性能优化？ context 对于消费该 context 的组件无脑刷新，对消费context 的组件做类似于 pureComponent 的操作也无效，而这种刷新很大程度上是没有意义的。 context 性能优化的方式 context 拆分，把频繁更新的属性，单独拆到一个 context 使用 memo 或者 useMemo 的方式 使用 calculateChangedBits 每个消费组件，使用位运算标示自己关注的 context 内容。 首先推荐 1 的方式，因为这符合关注分离的模式，内容组件不需要关心数据来源。其次是 2，需要注意的是： useMemo 只能在 hooks 内使用。3 方案建议不要使用，因为很可能会废弃 ：） (完) 参考： react-memoreact-trackedPreventing rerenders with React.memo and useContext hook","link":"/2020/03/01/React-Context-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"基于 antd 的主题定制","text":"背景最近接到一个需求，需求方要求 UI 主题风格做一些定制。当前前端团队基础设施如下： 团队组件库底层基于 Antd 封装，针对样式以及组件能力提供了一定的定制。这部分的组件库跟具体的业务无关，也就是说，它会提供类似 Input 这种控件、但是不会提供 Singin 这类控件。这类组件是 基础设施 的职责(如果需要的话)。所以要支持主题功能，意味着要同时对底层组件库以及基础设施做定制。 方案约定可配置项支持主题功能，并不意味所有的样式皆可配置（那样就乱套了..）。首先研究了一下 Antd 官方的配置项： 12345678910111213@primary-color: #1890ff; // primary color for all components@link-color: #1890ff; // link color@success-color: #52c41a; // success state color@warning-color: #faad14; // warning state color@error-color: #f5222d; // error state color@font-size-base: 14px; // major text font size@heading-color: rgba(0, 0, 0, 0.85); // heading text color@text-color: rgba(0, 0, 0, 0.65); // major text color@text-color-secondary: rgba(0, 0, 0, 0.45); // secondary text color@disabled-color: rgba(0, 0, 0, 0.25); // disable state color@border-radius-base: 4px; // major border radius@border-color-base: #d9d9d9; // major border color@box-shadow-base: 0 2px 8px rgba(0, 0, 0, 0.15); // major shadow for layers 完整配置列表可以看：default-theme。 由于项目初期，底层组件库和基础设施没有考虑主题的概念。意味着库中，部分样式的组织方式、变量定义是不合规的, 难以满足定制需求。关于这部分，完全可以参考 antd 的主题可配置变量来实现，这部分不展开讲了… 配置方案研究了一圈关于主题定制的方案，包括 Antd 官方的方案。基本还是围绕样式变量替换这个主题，只是替换的方式不太一样。总结了一下，主要的方式如下： 通过 import override缺点： 修改面比较广，项目中所有使用到样式变量的地方都要替换 底层组件库部分样式固定/变量没有导出，难以完成替换 基础设施部分组件代码和样式没有分离，难以完成替换 缺点分析：override 的方式缺陷主要跟 webpack 对样式文件的处理有关系, 主要包含以下一个步骤： less-loader 把 less 转换成 css css-loader 把每个被转换的 css 文件转换成 webpack module，即：每个样式文件一个 module。 style-loader 在运行时把样式代码插入 html 的 head 标签下，顺序依赖于样式文件被 import 的顺序。 通过上述分析发现：样式文件并不能通过全局替换一次的方式来达成，几乎项目代码中每个组件的样式文件都要 import 一次 override 样式文件。 优势：暂时想不到：） 利用 less-loader 的 modifyVars 能力缺点： modifyVars 只能修改 global namespace 内的变量，而基础设施和组件库内部分配置变量没有放到 global namespace中 缺点分析：less 的 modifyVars 功能的作用类似于在 less 文件底部声明一个变量用于覆盖之前声明的变量，达到替换的效果。举个例子： 1234.component { @color: #333; color: @color;} 对于这种方式实现的样式实际上 modifyVars 是无能为力的，因为 modifyVars 做的事情类似于： 1234567.component { // 无法被替换 @color: #333; color: @color;}@color: #666; 优势： 对项目代码没有侵入性，只需要改 less-loader 的配置即可 对基础设施以及组件库的要求比较低，只需要把部分固定的或者是没有导出的配置导出即可 主题配置参考代码： 1234567891011121314151617181920212223242526// webpack.config.jsmodule.exports = { rules: [{ test: /\\.less$/, use: [{ loader: 'style-loader', }, { loader: 'css-loader', // translates CSS into CommonJS }, { loader: 'less-loader', // compiles Less to CSS options: { modifyVars: { 'primary-color': '#1DA57A', 'link-color': '#1DA57A', 'border-radius-base': '2px', // or 'hack': `true; @import \"your-less-file-path.less\";`, // Override with less file }, javascriptEnabled: true, }, }], // ...other rules }], // ...other config} 参考 antd 主题配置 less-loader webpack-loader-order css-loader vs style-loader","link":"/2020/03/07/%E5%9F%BA%E4%BA%8E-antd-%E7%9A%84%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B6/"},{"title":"typescript 类型判断","text":"javascript 是一门弱类型的语言，代码的健壮性一直被诟病。为了安全起见，每次在对变量做一些操作的时候，首先需要判断一下变量的类型，常见的方式如：in 操作符合、typeof 、instanceof 等。typescript 在完全兼容 js 的基础上，提出了更友好的类型检查机制，同时提供了严格的类型检查编译器，对整个程序的安全性有了极大的提升，对后续代码重构等也有很大的裨益。 常见的类型保护机制in 操作符in 操作符作用原理: The in operator returns true if the specified property is in the specified object or its prototype chain. 先定义基本类型供测试用。12345678// type definedinterface IFoo { foo: number}interface IBar { bar: string} 基本用法 12345678// in operationfunction testIn(arg: IFoo | IBar) { if ('foo' in arg) { console.log(arg.foo.toFixed(2)) } // Property 'foo' does not exist on type 'IBar' console.log(arg.foo)} 通过以上示例可以看到： 在 if 作用域里面，arg 变量类型被转换成，IFoo。所以我们可以执行：toFixed 这类 foo 属性上的操作。 在 if 作用域之外，直接使用 foo 这个属性是会报错的，因为这个时候 arg 的类型等于：IFoo | IBar。 in 操作符的缺陷 in 操作符会遍历对象和原型链上的属性，包括属性配置 enumerable 等于 false 的属性。比如：console.log('toString' in arg) 打印出 true in 操作符的优势 可以区分出，某个属性是被删除的，还是值等于 undefined 举个例子12345const obj = { a: 1, b: undefined }console.log('b' in obj) // trueconsole.log('c' in obj) // falseconsole.log(typeof obj.b) // undefinedconsole.log(typeof obj.c) // undefined typeof 操作符typeof 操作符的基本原理 typeof 操作符返回固定的几种类型。通过这种机制来做类型的判定。 基本用法 写一个 demo： 12345678// typeof operationfunction testTypeof(arg: number | string) { if (typeof arg === 'string') { console.log(arg.toUpperCase()) } // Property 'toUpperCase' does not exist on type 'number' arg.toUpperCase()} 通过以上示例可以看出： typeof 同 in 操作符，在 if 作用域区块内，保持 arg 是 string 类型。 typeof 同 in 操作符，在 if 之外的作用域类型等于，number | string typeof 的缺陷 只能做初略的判定，返回值固定 8 种类型，对于用户自定义类型的判定比较困难，比如对于属性值等于 undefined 和属性不存在的判定就是不合法的 存在 typeof null 等于 object 的问题 instanceof 操作符合instanceof 的基本原理 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 基本用法1234567891011class XX { a: number b: string}const inst = new XX()console.log(inst instanceof XX) // trueconsole.log(inst instanceof Object) // trueconsole.log(inst.__proto__ === XX.prototype) // trueconsole.log(XX.prototype.__proto__ === Object.prototype) // true通过以上示例可以看出： inst 指向的原型是 XX.prototype，而 XX.prototype 的上一级原型是 Object.prototype， instanceof 通过逐级查询原型链的方式来判定类型。 instanceof 的缺陷 逐级查询的方式有些情况是优势，某种情况也可能会导致误操作，导致判定出来的类型不是想要的 instanceof 操作符的右操作数要求是一个 Constructor，这就导致在 ts 环境下，interface 和 type 定义的类型等不能放在该位置 常量类型的判断基本原理： 通过 typescript 类型变量的值来做判定。 基本用法 12345678910// literal string typetype Foo = { k: 'foo', v: number }type Bar = { k: 'bar', v: string }function testLiteralString(arg: Foo | Bar) { if (arg.k === 'foo') { console.log(arg.v.toFixed(2)) } // Property 'length' does not exist on type 'number' arg.v.length} 通过以上示例可以看出： 和其他类型类似，常量类型的判断 只会对 if 区块生效。 用户自定义类型保护typescript 内置了一个 is 操作符，专门用于类型的判定。基本用法 12345678910111213141516// is operatortype Foo1 = { k: 'foo', hello: () =&gt; void }type Bar1 = { k: 'bar', v: string }function isFoo(arg: Foo1 | Bar1): arg is Foo1 { return arg.k === 'foo'}function testIs(arg: Foo1 | Bar1) { if (isFoo(arg)) { // ok arg.hello() } // Property 'hello' does not exist on type 'Bar1' arg.hello()} 通过以上示例可以看出： 同其他类型，只在 if 区块内生效 isFoo 函数的实现和 typeof 类似，但是返回值不是 Boolean 而是一个特殊的用法（arg is Foo1） 把 isFoo 函数返回值去掉试一下： 123456789101112function isFoo(arg: Foo1 | Bar1) { return arg.k === 'foo'}function testIs(arg: Foo1 | Bar1) { if (isFoo(arg)) { // Property 'hello' does not exist on type 'Bar1' arg.hello() } // Property 'hello' does not exist on type 'Bar1' arg.hello()} isFoo 的返回换成 Boolean 之后，if 区块内 arg 变量的类型并没有变成 Foo1 。这正是 is 操作符的威力所在。 其他建议开启 strictNullChecks在未开启 strictNullChecks 的情况下，typescript 里面可以给任意类型的变量赋值：null 或者 undefined。这通常是有好处的，因为我们的程序代码里面经常不需要区分 null 和 undefined 的情况。可以简单的使用：x != null 来判定这两种类型。 关于 null 有一个著名的 百万美金错误 故事，如果你不想重蹈覆辙，所以还是尽可能启用这个特性吧！：） 在开启 strictNullChecks 的情况下，程序代码会发生一些变化： 1234let x = 123x = null // Type 'null' is not assignable to type 'number'x = undefined // Type 'undefined' is not assignable to type 'number' 可以看到在这个时候 undefined 和 null 不能随意赋值给其他类型的变量。 再看一个例子：12345678910function testStrictNull(arg?: number) { //...}// oktestStrictNull(123)// Argument of type 'null' is not assignable to parameter of type 'number | undefined'testStrictNull(null)// oktestStrictNull(undefined)通过上面的例子可以发现，可选参数的类型其实隐含了 | undefined 的行为。所以传入 null 被认为是非法的，而 undefined 是没问题的。 使用 unknow 类型来替代 anyany 类型常常用于处理刚把 javascript 代码迁移到 typescript，一时半会没有稳定的类型可用。或是对于第三方库，我们不知道它的类型，所以我们只能通过 any 类型来标注它。换句话说，不是万不得已一般不建议使用这个类型，因为它会逃过 typescript 的类型检查。使得代码错误风险提升。 举个例子： 123456function testAny(arg: any) { // ok arg.toUpperCase()}testAny(123) 对于 number 类型，在 testAny 内调用该类型上不存在的方法也不会报错。 unknow 被称之为类型安全版本的 any 在绝大多数情况下，都可以使用 unknow 来替换 any。 在对 unknow 类型的变量做操作的时候，需要判定具体的类型： 12345function testUnknow(arg: unknown) { arg.toUpperCase() // Object is of type 'unknown'.}testUnknow(123) 总结 typescript 继承了 javascript 的三种类型判定方法，但这三种方式有一定的缺陷。同时 typescript 还提供了通过类型的判定机制，以及结合 is 关键字判定的方式。通常情况下，建议使用 typescript 提供的方式，这样对类型更加友好一些。 为了提高程序的健壮性，建议开启 strictNullChecker，同时尽量避免使用 any 来标注类型。如果确实有需要使用 any 的情形，也建议使用 unknown 类型来替换。 参考advanced types basarat type guard New unknown top type","link":"/2020/03/15/typescript-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"},{"title":"babel 研究- polyfill vs transpiler","text":"背景javascript 语言发展迅速，各种新特性层出不穷。与之相对应的各个 runtime 的支持程度各不相同。通过 Node Green 可以发现最新版本（Node 14）几乎完全支持了 ES2018、ES2019、ES2020 所有的特性。而在浏览器端，需要面对的环境差异比较大，因为用户留存的问题又不得不支持。在这样一种大环境下，bolyfill 和 transpiler 的作用就凸显出来了。 polyfill vs 语法转换(transpiler)polyfill 和语法转换（syntax transforms）是两个不同的功能。他们的目的都是相同的：项目代码中用了某些语言特性，但是这些特性在目标环境中没有实现，就需要通过 polyfill 或者 syntax transform 来达到这个目的。 polyfill 模拟特定的 API 实现，就好像它已经默认被支持了似的，起到一个模拟标准库(Standard Library)的作用。 syntax transform 语法转换强调的是转换语言特性，如：arrow-function、decorators、class-properties 等。把最终编译出来的代码替换成另外一个对应的代码片段。比如，babel-plugin-transform-arrow-functions 就提供了 箭头函数 的语法转换能力。 babel 对语法转换的支持preset-envbabel 的语法转换能力主要依赖于 babel-preset-env。该模块的工作原理为： 用户配置需要支持的环境（浏览器）版本信息 preset 借助 browserslist、compat-table、electron-to-chromium等工具查询不同环境对语法能力的支持程度，提供对应的 子模块 来完成编译。换句话说，如果浏览器版本越老旧，需要的 transform 子模块 也就越多，反之亦然。 preset-env 主要提供了如下一些转换转换功能： 12345678910111213141516\"dependencies\": { \"@babel/compat-data\": \"^7.9.0\", \"@babel/helper-compilation-targets\": \"^7.8.7\", \"@babel/helper-module-imports\": \"^7.8.3\", \"@babel/helper-plugin-utils\": \"^7.8.3\", \"@babel/plugin-proposal-async-generator-functions\": \"^7.8.3\", \"@babel/plugin-proposal-dynamic-import\": \"^7.8.3\", \"@babel/plugin-proposal-json-strings\": \"^7.8.3\", \"@babel/plugin-proposal-nullish-coalescing-operator\": \"^7.8.3\", \"@babel/plugin-proposal-numeric-separator\": \"^7.8.3\", \"@babel/plugin-proposal-object-rest-spread\": \"^7.9.0\", \"@babel/plugin-proposal-optional-catch-binding\": \"^7.8.3\", \"@babel/plugin-proposal-optional-chaining\": \"^7.9.0\", \"@babel/plugin-proposal-unicode-property-regex\": \"^7.8.3\", \"@babel/plugin-syntax-async-generators\": \"^7.8.0\", ... 前面提到了，我们面对的是很多个浏览器环境，那么 babel-preset 是怎么知道需要支持什么浏览器的版本呢？ 答案是通过 preset 配置项，如：12345{ targets: { browsers: \"last 2 versions\" }}表示项目需要支持，每个浏览器的最后两个版本。（last 2 version 的缺陷 ) 其他的配置项可以参考 preset-env 文档。 stagx-n 语法转换需要注意的是： It is important to note that @babel/preset-env does not support stage-x plugins. stag-x 阶段的语法功能是没法提供转换的，所以对于：class-properties 目前处于 Stage 3、和 decorators 目前处于 Stage 2 是不会默认转换的，所以需要我们安装额外的 transform-plugin。 特定环境的语法转换一些时候在特定环境下，需要特殊的转换模块，如： babel-preset-react 负责转换 react 相关的语法，如：jsx 等 延伸阅读：babel typescript 编译转换 babel 对 polyfill 的支持基础能力支持说到 polyfill 不得不提的是 corejs，corejs 扮演的是标准库的角色。绝大多数 polyfill 的能力由它来完成，只有一个例外：regenerator-runtime，用于转换 generator 函数。babel 7.4 之前的 polyfill 是通过 babel-polyfill 来完成，这个库其实没干其他事情，就是简单的把 corejs 和 regenerator-runtime 做了一层包装。7.4 版本之后该库已经不推荐使用了，原因在于： This behavior is deprecated because it isn’t possible to use @babel/polyfill with different core-js versions 建议直接使用 corejs 和 generator runtime 侵入式“侵入式” polyfill 的能力通过 babel-preset-env 来完成（前面提到的语法转换也是通过它来完成）。 默认情况下 preset-env 的 polyfill 能力是关闭的，若要开启 配置方式有三种： entry 模式 在项目入口文件 import corejs 和 generator runtime（如果想用 babel/polyfill 则在这里替换）。注意只能 import 一次，否则可能会报错：） preset-env 会依据环境不同，把 import corejs 这类的语法转换成 import 具体的文件，因为对于某一环境而言，一些 polyfill 是没有必要的。看一个例子： 12345// webpack entry src/index.jsimport 'core-js' // 引入 polyfillfunction component() { //...} webpack 配置1234567891011121314151617181920212223242526module.exports = { entry: './src/index.js', module: { rules: [ { test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: [ ['@babel/preset-env', { \"targets\": { browsers: 'last 2 versions' }, \"useBuiltIns\": \"entry\", \"corejs\": \"2\" }] ], plugins: [cssModulePlugin] } } }, //...} 启用 entry 模式，目标环境是 last 2 versions，告诉 babel 使用的 corejs2 的版本。 bundle.js 输出： 1234567891011121314151617181920//src/index.js/* harmony import */ var core_js_modules_es6_w//..../* harmony import */ var core_js_modules_es6_w//..../* harmony import */ var core_js_modules_es6_w//..../* harmony import */ var core_js_modules_es6_w//..../* harmony import */ var core_js_modules_web_t//..../* harmony import */ var core_js_modules_web_t//..../* harmony import */ var core_js_modules_web_i//..../* harmony import */ var core_js_modules_web_i//..../* harmony import */ var core_js_modules_web_d//..../* harmony import */ var core_js_modules_web_d//..../* harmony import */ var regenerator_runtime_r//..../* harmony import */ var regenerator_runtime_r//..../* harmony import */ var _button__WEBPACK_IMPO//..../* harmony import */ var _astyle_less_modules_//..../* harmony import */ var _astyle_less_modules_//....function component() { //...} 可以看到，在项目入口处，import corejs 被替换成了 import 具体的子模块。 usage 模式 项目中不需要显示的 import corejs，babel 会动态分析每个文件使用了哪些需要 polyfill 的特性，然后再自动 import。 看一个例子： 修改 webpack 配置： 1234567891011//...presets: [ ['@babel/preset-env', { \"targets\": { browsers: 'last 2 versions' }, \"useBuiltIns\": \"usage\", \"corejs\": \"2\" }]],//... 修改项目入口文件： 123456789import button from './button'import * as styles from './astyle.less'function component() { //这里用到了 `Set` 这个特性 const set = new Set([1, 2, 3, 4, 5]) //...} 编译结果 bundle 文件： 12345678/* harmony import */ var core_js_modules_es6_set__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es6.set */ \"./node_modules/core-js/modules/es6.set.js\");function component() { //这里用到了 `Set` 这个特性 const set = new Set([1, 2, 3, 4, 5]) //...} 可以看到，只对该文件使用到的特性（Set），import 了对应的polyfill。 false 当 useBuildIn 配置成 false 的时候，preset-env 默认将不会提供任何 polyfill 的功能。我们可以在 webpack 的 entry array 加入 polyfill 相关的文件，例如： 123module.exports = { entry: [\"@babel/polyfill\", \"./app/js\"],}; 非侵入式前面提到 侵入式 的 polyfill 实现，好处是方便快捷。只需要在项目的入口处（entry 模式）import core-js ，或者压根不需要 import corejs (usage 模式)，来达成 polyfill 的目的。但是这种实现是有代价的，因为存在 global pollution 的问题。如果项目工程是类库，那么这种方案会污染该库的使用方。 这个时候，babel-plugin-transform-runtime 这个库可以良好的解决这个问题。通过官网发现，transform-runtime 主要有两个目的： 提供工具函数实现，如 _extend 等(模拟 class 继承) 提供一个沙盒环境（sandboxed environment）在不污染全局作用域的前提下，达到 polyfill 的目的。 transform-runtime 通过 corejs 配置项来控制 polyfill 的支持能力，为了达成以上两个目的，还需要额外的模块来辅助： @babel/runtime （当 corejs 配置为 false） 运行时的辅助函数库，transform-runtime 会把每个文件中自动生成的工具函数改成引入该模块，达到了减少代码体积的作用。同时包含了 regenerator runtime 的实现，用户通过 regenerator 配置项，决定是否启用改功能。 @babel/runtime-corejs-2 (当 corejs 配置为 2) 等同于 corejs + @babel/runtime，需要注意的是，该模式只能 polyfill 全局变量，不能 polyfill instance method @babel/runtime-corejs-3 (当 corejs 配置为 3) 等同于 core-pure-js + @babel/runtime，很好的解决了 polyfill instance method 等问题，详见 update to corejs@3 看个例子，以 corejs: 2 为例： 修改 webpack 配置：12345678910111213//...options: {presets: [ ['@babel/preset-env'] ], plugins: [ cssModulePlugin, [\"@babel/plugin-transform-runtime\", { \"corejs\": 2 }]]}//... 编译输出： 1234function component() { var set = new _babel_runtime_corejs2_core_js_set__WEBPACK_IMPORTED_MODULE_1___default.a([1, 2, 3, 4, 5]); var element = document.createElement('div');} 可以看到 new Set ，被替换成了 polyfill 实现。其他配置项就不一一展开了。 总结 对比分析了 polyfill 和语法转换的差异 babel 目前的语法转换通过 preset-env 来完成，但是 stage-n 的特性如 class properties等，只能自己安装插件来完成。 babel 对 polyfill 的支持主要依赖于 corejs 和 regenerator runtime。7.4 版本之后 babel/polyfill 已经不推荐使用了，取而代之的是： preset-env 的方式，但是存在 pollute the global scope 的问题 entry 模式需要写一个单独的问题在项目的入口文件 import 它 usage 模式不需要手动 import polyfill 文件，但是需要安装对应的包 false 模式，默认不提供 polyfill 的能力，但是可以通过把 polyfill 作为入口文件(entry array)的一部分 transform-runtime 的方案，可以良好的解决这个问题，如果需要支持 instance method 等特性，记得使用 babel/babel-runtim-corejs3 参考babel-preset-envbabel-polyfillbabel-plugin-transform-runtimecore-jsbrowserslistthe-difference-between-polyfill-and-transpilerusebuiltins-option","link":"/2020/03/22/babel-%E7%A0%94%E7%A9%B6-polyfill-vs-transpiler/"},{"title":"webpack 之 css-module","text":"背景CSS-module 的好处是可以避免 namespace 冲突的问题，尤其是项目工程比较庞大的情况。如果不采用 css-module 的形式 className 必须包含 namespace 的信息比如：comp-domain-create-btn。css-module 的好处显而易见。同时，开启 css-module 有一定的编译器性能开销。详细可以参阅 css-module 文档。这里想要谈论 css-module 和 normal style 兼容的问题，如果要使用第三方的 css 库（只有 normal style 的形式），和本项目共存（css-modules）这种情况就不可避免了。 webpack 样式文件处理流程假设项目使用 less。在 webpack 环境下，通常编译过程如下： less-loader 负责编译 less 语法，输出 css 语法的样式文件 css-loader resolve 样式文件内所有的 @import 和 url，输出一个 webpack module，本身对css 样式内容不做任何的调整。 style-loader 负责把 css 样式文件插入到 html 文件中。可以配置，link 或 &lt;style&gt; 的形式引入。 三个 loader 的处理流程可以概括为： 1require(\"style!css!less!./file.less\") 注意：处理顺序跟书写的顺序是相反的。 而 css-module 功能由 css-loader 提供。 解决方案修改文件后缀修改文件名称是最常见的做法，显示的告知 webpack，哪些样式文件是需要启用 css-module 功能的。常见的配置如下： 123456789101112131415161718//...{test: /\\.less$/,use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true } }, { loader: 'less-loader' }]},{test: /\\.plainless/,use: [ { loader: 'style-loader' }, { loader: 'css-loader' }, { loader: 'less-loader' }]}//... 通过 AST 动态识别 css-module 文件最近看到了 umijs，提供的一个 webpack-plugin 很好的解决了这个问题，在无需修改文件后缀的前提下动态的识别 css-module 文件，添加相应的配置。其实现原理如下： 通过 AST 发现差异 在不需要 css-module 的情况下，项目中引入 样式文件的形式： 1import './style.less' 在需要使用 css-module 的情况下，项目中引入样式文件的形式： 1import styles from './style.less' 这两种写法在 babel 编译的时候，生成的 AST 是不同的： import ‘./style.less’ 模式： 123456789101112131415//...{ \"type\": \"ImportDeclaration\", \"start\": 468, \"end\": 489, \"specifiers\": [], \"source\": { \"type\": \"Literal\", \"start\": 475, \"end\": 489, \"value\": \"./style.less\", \"raw\": \"'./style.less'\" }},//... import styles from ‘./style.less’ 模式： 123456789101112131415161718192021222324252627//...{ \"type\": \"ImportDeclaration\", \"start\": 391, \"end\": 424, \"specifiers\": [ { \"type\": \"ImportDefaultSpecifier\", \"start\": 398, \"end\": 404, \"local\": { \"type\": \"Identifier\", \"start\": 398, \"end\": 404, \"name\": \"styles\" } } ], \"source\": { \"type\": \"Literal\", \"start\": 410, \"end\": 424, \"value\": \"./style.less\", \"raw\": \"'./style.less'\" }}//... 因为写法不同 css-module 的形式会多处一个 specifiers 数组。所以我们可以从这里做文章。 babel-autocss-module-plugin 实现： 123456789101112131415161718192021const { extname } = require('path');const CSS_FILE_EXTENSIONS = ['.css', '.scss', '.sass', '.less'];module.exports = () =&gt; { return { visitor: { ImportDeclaration(path) { const { specifiers, source } = path.node; const { value } = source; if ( specifiers.length &gt; 0 &amp;&amp; CSS_FILE_EXTENSIONS.includes(extname(value)) ) { source.value = `${value}?modules`; } }, }, };}; 关于 babel-plugin 的编写，可以参考 babel-handle-book。通过判断 spefifiers 数组的长度，结合文件后缀，给样式文件 url 加上 css-module 特定的参数。 具体 webpack 配置如下： 12345678910111213141516171819202122//...{test: /\\.less$/,oneOf: [ { resourceQuery: /modules/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true } }, { loader: 'less-loader' } ] }, { use: [ { loader: 'style-loader' }, { loader: 'css-loader' }, { loader: 'less-loader' } ] }]}//... 利用 resourceQuery 的能力，查询是否存在特定的参数，来决定是否启用 css-module 的功能。达到了不用修改文件名的形式，兼容了普通 css 和 css-module 的样式文件，简单而优雅：） 总结 less 文件编译通常包含三个步骤：less-loader-&gt;css-loader-style-loader, 每个 loader 职责不同 兼容 css-module 通常有修改文件后缀的做法，但是该做法不够优雅，所以从 AST 入手，动态识别样式文件引入方式，决定是否启用 css-module 功能 参考css-loaderstyle-loaderless-loadercss-loader vs style-loaderbabel-plugin-auto-css-modulesbabel-plugin-handbook.md","link":"/2020/03/22/webpack-%E4%B9%8B-css-module/"},{"title":"typescript 高级类型","text":"随着对 typescript 语言的逐渐深入实践，一些高级特性是必须掌握的，包括但不限于：Index types、Mapped types、Conditional types 等。一些名称听起来比较陌生，但实际情况是：其中一些类型可能已经在用了，另外一些奇怪的类型问题，或许都可以通过这些高级特性来解决。 top type vs bottom type为了更好的理解高级类型的用法，先了解两个基本的概念：top type 、bottom type。 top type 变量的容器，任何类型的变量都可以赋值给它们。typescript 包含两个 top type: any、unknow。对于这两个类型，它们有一些细微的差别。 any 对于 any 类型的变量，在使用的时候 ts 编译器不会进行类型检查 例如： 1234function testAny(arg: any) { // 不会报错 console.log(arg.fake())} unknow 对于 unknow 类型的变量，在使用的时候 ts 编译器会要求先进行类型 check，否则报错。 12345function testUnknow(arg: unknown) { // 报错: Object is of type 'unknown' console.log(arg.fake()) // ^^^} bottom type 表示没有其他类型(除了它自己)的变量可以对它赋值的类型。ts 有一个 bottom type：never。常常用于断言(assert)某种情况不会发生。 举个例子： 12345678910function testNever(arg: never): never { throw new Error('test ' + arg)}function main() { //... // Argument of type '\"123\"' is not assignable to parameter of type 'never'. testNever('123') // ^^^^} Assignability(可分配性)ts 采用 structural typing 的类型系统，该类型系统类似于 js熟知的 duck typing 。系统关注的是类型实际提供的能力，而不是类型的名称、继承关系等。 在 ts 的类型系统检查类型 可分配性 的常用关键字是：extends ，常用的写法： 1A extends B 含义： A 类型可以赋值给 B 类型。换句话说，A 是比 B 更加具体的类型, 或者同等类型。 举个例子： 12345678910function hello(arg: string | number) { //...}// okhello(123)// okhello('123')// error: Argument of type 'false' is not assignable to parameter of type 'string | number'hello(false) index type使用 index type 主要目的是便于编译器帮我们校验使用 动态属性名称 的时候的类型安全问题。 看个例子 从某个对象挑选部分的属性，返回一个新的对象： 12345678910111213// T: 对象类型// keyof T: 对象的 `public propery names`function pick&lt;T, K extends keyof T&gt;(arg: T, ...keys: K[]): {[P in K]: T[P]} { return keys.reduce&lt;T&gt;((acc, cur) =&gt; { acc[cur] = arg[cur] return acc }, {} as T)}const arg = { a: 1, b: 2 }const result = pick(arg, 'a')// { a: 1 }console.log(result) index type 包含两个基本的概念： index query keyof T，返回 T 这个类型的公有属性(public property name)，是一个 union type index access T[P]， P 表示属性名称（通过 keyof 生成），返回某个属性的数据类型 mapped typemapped type 利用 index type 的能力，主要用于处理 object 类型的领域，返回一个全新的 object 类型，或者修改部分属性的修饰信息（modifiters） 举个例子： 123456789101112131415// 移除属性的 `readonly` 特性type Mutable&lt;T&gt; = { -readonly [P in keyof T]: T[P]}interface Itest { readonly a: number readonly b: string}//type MutableITest = {// a: number;// b: string;//}type MutableITest = Mutable&lt;Itest&gt; mapped type 通常分为两个类型： homomorphic 在类型处理过程中，不会添加新的属性。ts 处理的时候，先从输入的类型拷贝一份旧的属性修饰信息，然后在这个基础之上做修改。 ts 内置的 homomorphic 类型如： Partial1type Partial&lt;T&gt; = {[P in keyof T]?: T[P]} Required1type Required&lt;T&gt; = {[P in keyof T]-?: T[P]} Pick1type Pick&lt;T, K extends keyof T&gt; = {[P in K]: T[P]} … non homomorphic 类型 在类型处理的过程中会生成新的属性。 ts 内置的 homomorphic 类型如： Record1type Record&lt;T extends key of any, P&gt; = {[K in T]: P} key of any 等于 string | number | symbol。表示 object 类型的 key 的合法属性类型。 Record 返回一个新的 object type。对于这类型的高级类型，通常称之为：non homomorphic conditional type如果要算 ts 里面使用最广泛的高级类型，那么非条件类型莫属。条件类型 最初在 ts2.8 版本的时候引入。写法规则： 1T extends U ? X : Y 条件类型的写法跟三元运算符类似。 比较常用的场景如： 1type XTrue&lt;T&gt; = T extends bool ? true : never 如果 T 是 boolean 类型，则 XTrue&lt;T&gt; 等于 true 类型，否则等于 never 类型。 distributive conditional分散形式的条件类型主要用于处理 union type，使用的场景非常多。有两个先决条件： union type 必须绑定到类型变量(&lt;&gt;符号内) union type 类型变量必须单独出现在 extends 关键字左边 举个例子： 1234type NonNullableX&lt;T&gt; = T extends null | undefined ? never : T//string | numbertype TX = NonNullableX&lt;string|number|null|undefined&gt; 针对上面的例子做一个详细的分解： 12345678910111213141516171819202122232425262728293031// 1. 代入类型type TX = NonNullableX&lt;| string| number| null| undefined&gt;// 2. 展开类型type TX = | NonNullableX&lt;string&gt;| NonNullableX&lt;number&gt;| NonNullableX&lt;null&gt;| NonNullableX&lt;undefined&gt;// 3. 替换表达式type TX =| (string extends null | undefined ? never : T)| (number extends null | undefined ? never : T)| (null extends null | undefined ? never : T)| (undefined extends null | undefined ? never : T)// 4. 计算表达式的值type TX =| string| number| never| never// 5. never 在 union type 里面没有意义，直接忽略type TX = string | number 在看一个项目中实际遇到过的例子 假设现在有几个类型，其关系如下： 1234567891011121314interface IBase { base: string}interface IChildren1 extends IBase { type: 'children1' foo: number}interface IChildren2 extends IBase { type: 'children2' bar: string} 目标：生成一个类型，达到 IChildren1 | IChildren2 的效果，但是不要包含 IBase 的内容信息。 结论： 1234567type Info = IChildren1 | IChildren2type DistributiveOmit&lt;T, K extends keyof T&gt; = T extends any ? Omit&lt;T, K&gt; : never// type IResult = Pick&lt;IChildren1, \"type\" | \"foo\"&gt; | Pick&lt;IChildren2, \"type\" | \"bar\"&gt;type IResult = DistributiveOmit&lt;Info, keyof IBase&gt; infer typets 里面有很多需要根据一个类型推断出另外一个类型的情形。如 获取函数的返回值类型：1type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer U ? U : never 获取类的构造参数类型：1type ConstructorParameters&lt;T extends new (...args: any) =&gt; any&gt; = T extends new (...args: infer P) =&gt; any ? P : never 关于 infer 的使用有几个约束： infer 不能出现在 类型约束 里面(即：&lt;&gt;里面) infer 只能出现在 extends 的右边 infer 推断的类型只能用在 true branch 总结 分析了 ts 的 top type 和 bottom type 的区别 对 ts 的 Assignability 进行了讨论，了解 ts 的限制以及同其他语言的区别 Index type 主要包含了：index query 和 index access，这是其他类型如：mapped type 和 conditional type 的基础 mapped type 分为 homomorphic 和 no homomorphic 两个类型。主要区别在于是否生成新的属性，还是仅仅对现有的属性描述信息进行修改 conditional type 是使用最为广泛的高级类型。形式类似于 三元运算符，但是只是作用于类型，而不是实际的值。distributive conditional 常常用于处理 union type 得到更加精确的类型，infer type 用于推导某个参数的类型 参考typescript-lang-advanced-types mariusschulz-conditional-types-in-typescript artsy-conditional-types-in-typescript the conditional types-pr","link":"/2020/03/30/typescript-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"},{"title":"Duck Type vs Structural Type vs Nominal Type","text":"背景Duck Type 、Structural Type、Nominal Type 是编程语言常用的类型系统规范。不同的编程语言采用不同的类型系统，有一些语言会采用三者之一作为主要的类型系统，部分支持支持其他类型系统。这里尝试通过不同的编程语言了解三种类型系统的差异性。 Duck TypeDuck Type 中文称之为鸭子类型（以下统一称之为鸭子类型）。常见于动态类型风格的语言。其定义为： 如果一个物体，它走路像鸭子、叫声也像鸭子，那么就可以认为它是鸭子。 在鸭子类型系统中，关注点不在于对象的类型，而在于对象实际被使用的方法、属性。如果依赖的对象的属性、方法不存在，那么可能会引发一个运行时错误。这是因为： 鸭子类型通常得益于不校验方法、函数的参数类型，依赖文档、清晰的代码和测试来确保正确使用。 举个 javascript 的例子： 123456789101112131415161718192021222324class Person { name = 'lufy' age = 23 sing() { console.log('Hi: ' + this.name + 'age: ' + this.age) }}class Dog { name = 'husky' sing() { console.log('Hi: ' + this.name) }}let v1 = new Person()let v2 = new Dog()function applySing(obj) { obj.sing()}applySing(v1)applySing(v2) 在上面的代码中，如果按照结构化类型系统（Structural Type）的理解，Dog 和 Person ，因为属性不完全相等，所以它们是不同类型（下面会分析）。如果按照标称类型系统(Nominal Type)的理解，通常类名称就表示了变量的类型（下面会分析）。Dog 类型和 Person 属于不同的类型。而这正是 鸭子类型 的好处，比较灵活。把负担都交给了：文档、测试、以及程序员对代码上下文的理解。 Duck Type 的问题鸭子类型的坏处通常是因为它太灵活了。问题的本质在于： “如果它走起来像鸭子并且叫起来像鸭子”，它也可以是一只正在模仿鸭子的人。 在实际的编码中，不能指望”人”做所有鸭子能做的事情（比如下蛋 ==|| ），而这一切都只能通过测试和对当前代码库的上下文拥有足够的了解来解决。而 Structural Type 能够一定程度缓解这种问题。 Structural TypeStructural Type 中文称之为：结构化类型（为了方便起见，以下简称结构类型），通常又称它为：基于属性的类型系统（property-base type system）其定义为： 基于对象实际包含的属性类型来决定，两个变量是否兼容性和等价。既不是通过对象所属类型的名字来判断（nominal type）。也不是通过运行时访问对象某个属性或者方法来决定类型的兼容性（duck type）。 目前在前端领域非常火热的 typescript 就是基于该类型系统。 看个例子： 1234567891011121314151617181920class Person { name = 'lufy' sing() { console.log('Hi: ' + this.name + 'age: ') }}class Dog { name = 'husky' sing() { console.log('Hi: ' + this.name) }}let v1 = new Person()let v2 = new Dog()// okv1 = v2 因为 Person 和 Dog 的属性、方法完全等价所以 v1 和 v2 两个对象能够互相赋值，这种行为在结构类型系统下是完全允许的。 把 Person 类型改造一下： 12345678910111213class Person { name = 'lufy' age = 23 sing() { console.log('Hi: ' + this.name + 'age: ') }}//...// Property 'age' is missing in type 'Dog' but required in type 'Person'v1 = v2 因为 v1 (Person 类型) 具有 age 属性而 v2（Dog 类型）没有该属性，所以赋值操作是非法的。但是反过来赋值是允许的： 12345//...// okv2 = v1 更多信息，参考 type-compatibility。 Structural type 的问题因为 Structural type 基于变量所属类型的属性和方法的类型判断类型的兼容性，这也有可能导致一些非预期的行为。而这，只能通过 Nominal Type 来解决。 Nominal TypeNominal Type 又称之为：name-based type system，按照字面意思：基于名称的类型系统。其定义为： 通过显示的声明，或者类型的名称来决定变量是否兼容和相等。 常见的基于 Nominal Type 作为类型系统的语言有：C、C++、Java、C# 等。 看个 C 语言的例子： 1234567891011121314151617#include &lt;stdio.h&gt;struct typeA { int foo;};struct typeB { int foo;};int main() { struct typeA a; struct typeB b; // error: assigning to 'struct typeB' from incompatible type 'struct typeA' b = a;} 总结 Duck Type 类型系统非常灵活，它只校验了代码实际过程中会使用的属性和方法，但是这种校验只能通过：文档、测试、开发人员对系统的熟悉程度来保证，很有可能会导致代码产生运行时错误。 Structural Type 类型基于变量类型包含的属性和方法的类型来判断变量是否兼容。对比 Duck Type，它牺牲了一定的灵活性，但是得到了很好的安全性保障，减少开发人员的心智负担。 Nominal Type 又称之为基于名称的类型系统。对比 Structural Type 类型系统更加严格，可以有效的解决 Structural Type 导致的不想干的两个类型，由于拥有相同的属性和方法被判定类型兼容的问题。 参考 Nominal_type_system typescript-type-compatibility type-systems-structural-vs-nominal-typing-explained duck-type","link":"/2020/08/31/Duck-Type-vs-Structural-Type-vs-Nominal-Type/"},{"title":"Mobx Hooks","text":"背景React 16.8 正式推出 Hooks 至今已经一年多了。作为当下炙手可热的状态管理库 Mobx 也顺应了这一潮流，推出了 v6 版本，方便我们在 Hooks 环境下，更好的对 React 进行状态管理。 这篇文章主要想深入研究一下，Mobx 为了适应 React Hooks 而作出的一些更新。为了更好的理解 mobx 的变更，首先需要了解一些背景知识。 Observe StateObserve State 表示观察数据状态的含义，如果放到 React 语境下，可以理解成： 使 React Component 响应数据状态的变化。即：当组件内有 observable state 变更的时候，自动 re-render 当前组件。 Mobx 使组件响应数据状态的变化主要有三种方式： observer HOC hoc 的方式是自打 mobx-react 诞生以来就支持的一种方式，其主要提供了如下能力：1、响应数据状态的变化2、给函数组件提供 memo 的能力3、给类组件提供 pure component 的能力4、把类组件的 props 和 state 转换成 shallow observable Observer Component Observer Component 出现了也比较早，但是最新版本的实现已经基于 hooks 来实现了。其主要目的为：1、更加细粒度的控制组件的 re-render，特别是针对我们需要传递 render props 给第三方组件的情形，当 render props 内使用了 observable state，这个时候我们需要使用 &lt;Observer&gt; 包裹 render props 的内容。 useObserver hooks useObserver 是 mobx-react 组件响应数据变化的基础。函数组件的 observer hoc、Observer Component 都是基于 useObserver 来实现的。useObserver 提供的能力非常单一：响应数据状态的变化。其好处在于定制能力比较强，例如：我们可以使用 useObserver 配合 React.memo 的比较函数，定制化优化组件等。 useLocalStoreMobx 推荐使用 useLocalStore 来组织组件的状态。首先来看一下基本使用姿势： 1234567891011121314151617const Children = function Children(props: { base: number }) {//... const store = useLocalStore( source =&gt; ({ valueWrap: { v: 1 }, get computedValue() { return this.valueWrap.v * source.base; }, incValue() { console.log(\"inc\"); this.valueWrap.v += 1; } }), props ); //... } useLocalStore 接受两个参数，第一个参数是一个函数，该函数返回一个对象，需要注意的是，该函数只会调用一次，并没有依赖其他状态重新创建对象的机制。这个对象里面可能有：属性、getter、函数。useLocalStore 内部使用 observable 处理该对象，经过处理之后，其转换关系为： 类型 结果 属性 observable property(deep) getter computed 函数 mobx action useLocalStore 第二个参数是一个对象，该对象可能是 props，也可以是其他任意的非 observable 的对象，其内部会调用 useAsObservableSourceInternal，下面会讲到。 useAsObservableSourceuseAsObservableSource, 用于把对象（主要是 props 或 其他）转换成 observable，转换结果是一个 shallow observable 对象。并且该对象在组件的生命周期内始终保持一份引用，这样在 useLocalStore 或者 useEffect 等就能正常的引用该对象。useAsObservableSource 相较于 useLocalStore 差异在于，如果不需要 action、computed，那么可以用 useAsObservableSource 来取代 useLocalStore。因为 mobx 推荐使用 useLocalStore 组织状态信息，把 props 传给 useAsObservableSource 处理。 这或许就是函数组件的 observer hoc 默认不把 props 转换成 observable 的原因？ 注意 useAsObservableSource, 不能正常响应新增、删除属性的变更，具体可以参考之前的文章： Mobx-Make Property Observable。 useEffect日常在使用 useEffect 的过程中，React 官方提供了一个 linter插件 避免我们在使用 useEffect 的时候忘记了某些依赖。 但是也有例外的情况，譬如：useRef 的返回值不需要被加入 useEffect 的 deps，否则还可能导致 BUG。同样的，useAsObservableSource 、useLocalStore 的返回值也不需要被加入 deps，但是这个时候 linter 会给出警告。 通常为了响应 props 数据的变化并做一些操作，我们的做法是，使用 useEffect，把依赖的 props 作为 deps，在 useEffect 内使用 reaction。但是更好的办法是把props 交给 useAsObservableSource 生成一个 store，直接使用这个 store。这样的好处是： 避免 props 变化的时候重复创建 reaction 降低心智负担，不需要一直查看 useEffect 依赖了那些 props 总结 mobx 响应数据变更主要有三种方式：observer hoc、Observer Component、useObserver。对于函数组件而言，useObserver 是前两者的基础。类组件的 observer 会自动把 props 和 state 转换成 shallow observable，而函数组件不会。observer hoc 针对函数组件和类组件分别有优化：(React.memo、Pure Component) mobx 提供了三个 hooks 来处理 React 组件的状态：useObserver、useLocalStore、useAsObservableSource useObserver 就只有一项基础能力，使组件能够响应数据的变化。能力基础意味着定制能力更强 useLocalStore 是 mobx 推荐的组织数据状态的方式，如果数据状态不需要 computed、action 那么可以直接使用 useAsObservableSource useAsObservableSource 把对象（主要是 props 或 其他）转换成 shallow observable，但是需要注意的是：其不能正常响应新增、删除属性的变更 同 useRef，useAsObservableSource 和 useLocalStore 的返回值并不需要 放到 useEffect 的 deps，因为 React 本身并不能感知其变化。 在需要响应 props 变更并且做 reaction 的时候 采用 useAsObservableSource 是更好的做法，因为它可以避免重复创建 reaction、不需要一直关系 useEffect 具体依赖了那些 props。 参考mobx-react.jsmobx-react-lite useEffect(effect, [ref.current]) is prematurely re-running useEffect will unpredictable when depends on ref","link":"/2020/05/24/Mobx-Hooks/"},{"title":"Mobx-Make Property Observable","text":"背景团队一直使用 mobx 作为前端的复杂状态管理工具。在日常使用过程中，发现有一类需求是比较常见的，即：如何把对象中某个属性设置成 observable。 为什么会有这种需求呢？一方面是业务逻辑的约束，在初始状态对象的某些属性是未知的，需要在随后的逻辑中加入进来。另外一方面原因是因为，Mobx &lt; 5 的版本，没有办法自动把新增的属性设置成 observable，这个工作只能由我们自己来完成。 几种方案extendObservableextendObservable, 用于给对象新增一个不存在的属性，并且把该属性设置成 observable。 看个 demo： 1234567891011121314151617181920// 定义一个 `observable` 对象只包含 `a`const obj = observable.object({ a: 1 }, {}, { deep: false });// falseconsole.log(isObservableProp(obj, \"b\"));extendObservable(obj, { b: 2 }, {});// trueconsole.log(isObservableProp(obj, \"b\"));reaction( () =&gt; obj.b, b =&gt; { console.log(\"reaction b:\", b); });// console.log: reaction b: 3obj.b = 3// console.log: reaction b: 4obj.b = 4 调用 extendObservable，b 属性变成 observable 。在后续使用过程中，对 obj.b赋值，触发了 reaction 操作。 注意代码的先后顺序： 先把新增属性变成 observable 再调用 reaction 等函数，观察新增属性的变化 如果在 extendObservable 执行之前调用了 reaction 观察新增属性，在后续对属性赋值不能够触发 reaction。 1234567891011121314151617181920reaction( () =&gt; obj.b, b =&gt; { console.log(\"reaction b1:\", b); });// extendObservablereaction( () =&gt; obj.b, b =&gt; { console.log(\"reaction b2:\", b); });// console.log: reaction b2: 3obj.b = 3// console.log: reaction b2: 4obj.b = 4 reaction b1 并没有打印出来。 另外有一个注意点，不能对对象已有的属性设置调用 extendObservable，否则会报错： 12const obj = observable.object({ a: 1 }, {}, { deep: false });extendObservable(obj, { a: 2 }, {}); [mobx] ‘extendObservable’ can only be used to introduce new properties. Use ‘set’ or ‘decorate’ instead. The property ‘a’ already exists on ‘[object Object]’ decorate前面提到的 extendObservable 只能作用于对象本身的属性，但是如果要对某一类对象新增一个 observable 属性，那么是行不通的。这个可以通过 decorate 来完成。 看个 demo: 1234567891011121314151617181920212223class A { a = 3;}const instance = new A();// falseconsole.log(isObservableProp(instance, \"prop\"));decorate(A, { prop: observable });// trueconsole.log(isObservableProp(instance, \"prop\"));reaction( () =&gt; instance.prop, prop =&gt; { console.log(\"reaction prop1: \", prop); });// reaction prop1: 4instance.prop = 4;// reaction prop1: 5instance.prop = 5; 同 extendObservable, reaction 必须在 decorate 调用之后执行，否则没有效果。另外，decorate 对于现有的属性也是有效果的，比如，把上面的例子改成 decorate a。 1234567891011121314151617181920class A { a = 3;}const instance = new A();decorate(A, { a: observable});reaction( () =&gt; instance.a, a =&gt; { console.log(\"reaction a: \", a); });// reaction a: 4instance.a = 4;// reaction a: 5instance.a = 5; proxyproxy 用法相对高级，针对的场景比较特殊一点。考虑这样一个场景， React Component 的 props 上面有两个可选的 property。那么 props 可能的值有： 123const props = { a: xx }//orconst props = { a: xx, b: yy } 由于 Mobx 的限制（Mobx &gt;=5可以解决这个问题）。在函数组件内使用 hooks：useAsObservableSource，得到的返回值每次引用是一样的，但是新增的属性（b）却不是 observable 的。 看个例子： 1234567891011121314151617181920212223242526272829303132333435function Children(props) { const observableProps = useAsObservableSource(props); // 第一次输出 key: a observable: true // 5 秒之后输出 : // key: a observable: true // key: b observable: false Object.keys(observableProps).forEach(key =&gt; { console.log( \"key: \", key, \"observable: \", isObservableProp(observableProps, key) ); }); return \"Children\";}function App(_) { const [p, setP] = useState({ a: 1 }); setTimeout(() =&gt; { setP({ a: 1, b: 2 }); }, 5300); return ( &lt;div&gt; \"hello\" &lt;Children {...p} /&gt; {/* &lt;Children a={1} b={2} /&gt; */} &lt;/div&gt; );}ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\")); 新增的 b 属性，不是 observable，导致后续的 reaction 失效。 如何完整的解决这个问题呢？ 找到 props 内非 observable 的属性。 123function getExtraPropsProperty(props: object) { return Object.keys(props).filter(key =&gt; !isObservableProp(props, key))} 把对象的属性设置成 observable 1234567function makePropertyObservable(obj: object, keys: string[]) { keys.forEach(key =&gt; { const v = obj[key] delete obj[key] extendObservable(obj, { [key]: v }, {}, { deep: false }) })} 避免重复 render 的时候，反复做同样的工作。 把 props 本身变成 observable 1234567891011121314function makePropsObservable(store: ILocalStore) { const valueBox = observable.box(store.props) Object.defineProperty(store, 'props', { configurable: true, enumerable: true, get() { return valueBox.get() }, set(v) { valueBox.set(v) } })} 为了能够成功触发 reaction props.b 这种 observer，必须在初始化的时候先把 props 本身设置成 observable。否则因为时序问题（即：reaction props.b 在前，把 props.b 设置成 observable 在后）还是不能成功触发 reaction。 写一个 hooks 对 props 进行处理 1234567891011121314151617function useExtraObservableProps(store) { const firstRef = useRef(true) if (firstRef.current) { makePropsObservable(store) firstRef.current = false } const extraKeys = getExtraPropsProperty(store.props || {}) if (extraKeys.length) { makePropertyObservable(store.props, extraKeys) runInAction(function updateProps() { // eslint-disable-next-line no-self-assign store.props = store.props }) }} 这里有一个小问题，如果 props 来自于 useAsObservableSource 每次引用都相同，因为 observable.box 的优化，store.props = store.props 是不能够成功触发更新的。 来做一点优化： 1234567891011121314151617181920function makePropsObservable(store: ILocalStore) { // 引入 atom, 去除 `observable.box` let value = store.props const atom = createAtom('props') Object.defineProperty(store, 'props', { configurable: true, enumerable: true, get() { // 记录观察点 atom.reportObserved() return value }, set(v) { value = v // 通知更新 atom.reportChanged() } })} 通过使用 atom 规避了 store.props = store.props 被observable.box 优化导致的问题。 总结 extendObservable 只能作用于新增的属性，否则会报错 decorate 能作用于现有的属性 通过代理 props 配合 atom 解决了 mobx &lt; 5 版本新增属性不是 observable 的问题 值得注意的是，mobx 内的 reaction 定义必须出现在 make property observable 之后","link":"/2020/04/15/Mobx-Make-Property-Observable/"},{"title":"React 和 Vue 的 Location 同步","text":"Location浏览器提供了一个 Location 对象，该对象用于描述当前 URL 的信息，主要包括包含：域名、路径、端口等。html 的 window 和 document 对象都有一个 location 对象： 12345678910// window.location{ //... host: \"developer.mozilla.org\" hostname: \"developer.mozilla.org\" href: \"https://developer.mozilla.org/en- US/docs/Web/API/Location\" origin: \"https://developer.mozilla.org\" pathname: \"/en-US/docs/Web/API/Location\" //...} History浏览器还提供了一个 History 对象，该对象主要用于管理浏览器的会话历史。浏览器的会话历史是一个栈的结构，history 提供了一些属性和 api 用于查看和操作这些会话记录： 1234567891011121314151617// 控制台输入：window.history{ //... length: 2 scrollRestoration: \"auto\" state: null __proto__: History back: ƒ back() forward: ƒ forward() go: ƒ go() length: (...) pushState: ƒ pushState() replaceState: ƒ replaceState() scrollRestoration: (...) //...} state state 表示当前的浏览记录的状态信息，通过 pushState 设置，或者通过 replaceState 修改。 pushState pushState 用于新增一条记录，参数如下： state object: 可以序列化的用户自定义 javascript 对象。通过 window.history.state 可以读到最新的浏览记录的状态。 title: 浏览器暂时没有支持，留空即可 URL: 新的 URL 地址，该地址跟原有的地址必须在同一个域下，否则操作不成功 注意： pushState 不会导致浏览器马上 reload 新的页面（但是浏览器的地址栏会被修改）pushState 不会触发 popevent 事件，下面会看到 小 Demo: 1234567891011121314151617181920// 当前地址：https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API// 在浏览器的控制台执行：window.history.pushState({ foo: 'bar' }, \"page 2\", \"/foo/bar\")// 浏览器的地址栏变成：https://developer.mozilla.org/foo/bar// window.location 对象变成：{ //... host: \"developer.mozilla.org\" hostname: \"developer.mozilla.org\" href: \"https://developer.mozilla.org/foo/bar\" origin: \"https://developer.mozilla.org\" //...}// window.history.length:2// window.history.state:{foo: \"bar\"} replaceState replaceState 用于修改当前浏览记录的 state 信息，不会往栈里面新增一条记录，如： 123window.history.replaceState({ foo: 'baz' }, \"\", \"/foo/baz\")// window.history.state:{foo: \"baz\"} go/back/forward 这几个函数都表示跳转到某个历史记录，区别在于向前/后跳转、跳转到指定的页面。 注意 这些函数会导致页面重新加载 这些函数会触发 popevent 事件，下面会看到 popevent popevent 事件当浏览器的浏览历史发生变化的时候，会给 window 抛出该事件。触发 popevent 的方式主要有： 1、 go/back/forward2、 用户点击浏览器的前进后退按钮 从上面的例子可以看到，浏览器的 Location 变更主要有两种途径： 用户点击浏览器的 前进、后退 按钮 通过浏览器的 api: go/back/forward 前端框架为了在不同的 URL 显示不同的页面，统一”监听” Location 的变更，并做了相识的处理。 React 和 Vue 的实现React-RouterReact-Router 依赖于 History 来对这一层进行抽象和封装。提供统一的 listen 方法监听 Location 的变更。同时，维护了一份类似于 window.history 的栈信息。 Vue-Routervue-router 内置了 history 的抽象处理，干的事情跟 React-Router 使用的 history 模块差不多。维护了一份类似于 window.history 的栈信息。 Location 同步问题当同一个前端项目既有 vue-router 又用 react-router 的时候，部分页面使用 vue 来编写，另外一部分基于 react 来实现。由于历史原因，当前项目主体结构还是 vue (即：侧边栏的 link 都是基于 vue 实现)。 当页面从 vue 切换到 react react 组件会 didMount react-router 会同步”监听“当前的 Location 信息，页面显示正常 当一个 react 页面切换到另一个 react 页面 因为 vue-router 和 react-router 各种维护了一份“浏览器历史记录”表，所以当点击 vue 的 link 组件，通过 pushState 修改了 window.history（前面说过 pushState 不会抛出 popevent 事件），这个时候 react-router 并不会响应这个事件，导致 react-router 的维护的信息是旧的，新的 react 页面不会正常显示。 当页面从 react 切换到 vue 显示正常，因为 link 组件的点击事件始终是交给 vue-router 来进行处理的。 同步 Location 监听 vue 路由变更 123456789101112const router = new VueRouter({ mode: 'history', routes})router.afterEach(() =&gt; { // 由于直接调用 `window.dispatchEvent`，会导致事件消费方没有办法拿到最新的 location 所以这里 setTimeout // 又为了避免 Vue 和 React 两个 history 同时修改 window 上的 location 信息会，所以这里没有选择把最新的 router path dispatch window.setTimeout(() =&gt; { window.dispatchEvent(new CustomEvent(eventLocationChange)) }, 0)}) react 消费变更事件 12345678910111213141516impory routerStore from '...'export function useSyncLocation() { const handleLocationChange = React.useCallback(() =&gt; { const history = routerStore.history history.transitionTo(history.getCurrentLocation()) }, []) React.useEffect(() =&gt; { window.addEventListener(eventLocationChange, handleLocationChange) // 清理事件处理函数 return () =&gt; { window.removeEventListener(eventLocationChange, handleLocationChange) } }, [handleLocationChange])} 参考HistoryWorking_with_the_History_APIdiveintohtml5-historyvue-router-html5ReactTraining-history","link":"/2020/08/11/React-%E5%92%8C-Vue-%E7%9A%84-Location-%E5%90%8C%E6%AD%A5/"},{"title":"debounce vs throttle","text":"背景debounce vs throttle 是前端开发常用的工具函数。日常过程中没有太注意其中的细节差异。凭借印象都知道它们都是延迟某个函数的执行，用于性能优化的目的等等。但其实 debounce 和 throttle 使用场景是完全不一样的。 debouncedebounce，中文含义：去抖动， 如果用一句话概括，可以表述为： 控制某个函数只在特定的空闲时间段后调用一次。 为了更好的理解 debounce 的工作原理，可以对比电梯门。假设有几个人排队进入电梯，电梯门是不会尝试关闭的。只有当电梯门口没有人进出一段时间后电梯门才会尝试关闭。 使用场景日常使用 debounce 的场景主要有两个： resize、scroll 对 html 常用的事件 debounce，在特定的时间段内停止触发相关的事件后，才执行目标函数。 12345678window.addEventListener('resize', debounce() =&gt; { // do something}, 200)// orwindow.addEventListener('scroll', debounce() =&gt; { // do something}, 200) input OnChange 对 input 输入框数据变化的时候，需要发送请求到服务器获取数据、校验输入的数据合法性等操作，通常也是需要 debouce。 实现先来实现一个基础的版本： 123456789101112131415function debounce(func: (...args: any[]) =&gt; void, wait: number) { let timer: number | undefined = undefined; let result: any = undefined return function debounced(...args: any[]) { if (timer != null) { clearTimeout(timer); timer = undefined; } timer = setTimeout(() =&gt; { result = func(...args); }, wait); return result };} debounce 本身是一个高阶函数，传入目标函数，返回一个 debounced 函数。在调用 debounced 之后会开启一个定时器，如果在定时器时间结束之前再次调用 debounced 会重置该定时器，在定时器结束之后则调用对应的目标函数。debounced 返回最后一次调用目标函数的返回值或者 undefined(初始状态)。 高级选项前面看到的 debounced 函数会在 某个空闲时间之后调用目标函数，underscore 和 lodash 等库提供的实现还支持 leading edge 模式，可以理解成： 控制某个函数只在特定的空闲时间开始时段调用一次。 12345678910111213141516171819202122232425262728293031323334export function debounceWithEdge( func: (...args: any[]) =&gt; void, wait: number, options: { edge: \"leading\" | \"tailing\" }) { let timer: number | undefined = undefined; let allowInvoke = true; let result: any = undefined; return function debounced(...args: any[]) { if (options.edge === \"leading\") { if (allowInvoke) { result = func(...args); allowInvoke = false; } } if (timer != null) { clearTimeout(timer); timer = undefined; } timer = setTimeout(() =&gt; { if (options.edge === \"leading\") { allowInvoke = true; } else { result = func(...args); } }, wait); return result; };} 对于 leading 模式，在首次触发 debounced 函数的时候调用一次，并开启一个定时器，在定时器结束之前，如果再次触发 debounced 函数则重置该定时器。定时器结束之后，标记允许再次调用目标函数。 throttlethrottle 中文名称节流阀，如果用一句话来概括的话，可以表述成： 控制某一函数在特定时间范围内最多允许调用一次。 使用场景 无限滚动 对于无限滚动的 web 页面。在用户滚动内容区域到某一位置的时候需要加载数据，填充到内容区域，实现数据无限的滚动加载效果。而 debounce 需要某一静置时间才会调用目标函数，所以对于这种场景 throttle 是恰当的选择。 实现throttle 基于 debounce 来实现，不过增加了一个最大等待时间，保证在等待时间结束的时候，目标函数被调用一次。 基于 debounceWithEdge 实现 throttle。 123456789101112131415161718192021222324252627282930313233export function debounceWithEdge( func: (...args: any[]) =&gt; void, wait: number, options: { edge: \"leading\" | \"tailing\"; maxWait?: number }) { //... let waitTimer: number | undefined = undefined; let lastDatetime = 0; return function debounced(...args: any[]) { if (options.maxWait) { if (lastDatetime === 0) { lastDatetime = Date.now(); } if (waitTimer == null) { waitTimer = setTimeout(() =&gt; { if (Date.now() - lastDatetime &gt;= options.maxWait!) { result = func(...args); if (timer != null) { clearTimeout(timer); timer = undefined; } } waitTimer = undefined; }, options.maxWait); } } //... }} 在 debounce 的基础之上增加了一个定时器，确保目标函数至少会被调用一次。 注意事项 推荐使用，lodash 或者 underscore 的实现。一方面自己实现的容易有缺陷，二是第三方库实现的功能完善，譬如 lodash 版本的实现还提供了诸如 cancel 等操作。 不要重复调用 debounce、throttledebounce 和 throttle 每次调用都返回一个新的函数，重复调用则起不到本来的效果，还可能导致错误。 总结 debounce 控制函数在某一个空闲时间之后调用一次 可以通过参数控制 debounce 调用的时机，即：tailing 或 leading throttle 在 debounce 基础上确保函数在特定时间内最多被调用一次 推荐使用第三方库现成的实现，一来它们都经过稳定的测试，功能也比较完善。还需要注意的是，不要重复调用 debounce、throttle。 参考the-difference-between-throttling-and-debouncingdebouncing-throttling-explained-examples/ lodash-debounce.js","link":"/2020/05/11/debounce-vs-throttle/"},{"title":"typescript 严格模式","text":"背景ts 编译器包含严格模式（strict mode）一系列配置。通过这些配置，能限制一些不良的编码习惯，以及可能由于思维漏洞而导致的 BUG，把问题在编译/编码阶段就暴露出来而不是等到上线之后由客户来反馈 :)。强烈建议尽可能的开启部分或者全部的严格模式，这对代码质量大有裨益。本文尝试分析 ts 的严格模式配置，并提出 fix 相关代码的建议。 配置strictstrict 等于其它选项的总开关，开启该项等于开启所有的严格模式配置。 noImplicitAnynoImplicitAny ts 对于没有类型标注的变量隐含推断出变量类型为: any。noImplicitAny 针对此类变量的定义报错。 看个例子： 1234// Parameter 'a' implicitly has an 'any' typefunction hello(a) { console.log(a)} strictNullChecksstrictNullChecks 有的时候，我们的代码没有区分 null 和 undefined。但是这样可能在运行时导致一些非预期的行为。毕竟在 javascript 的环境下，null 和 undefined 是两种类型。开启 strictNullChecks, ts 对于 null 和 undefined 作为两个类型来看待。 strictNullChecks 等于 false 12345let i = 123// oki = undefined// oki = null strictNullChecks 等于 true 12345let i = 123// Type 'undefined' is not assignable to type 'number'i = undefined// Type 'null' is not assignable to type 'number'i = null strictNullChecks 等于 true 下的可选属性 12345678class A { prop?: number}const inst = new A()// okinst.prop = undefined// okinst.prop = 123 prop?: number 等于 prop: number | undefined xx is possibly ‘undefined’ 123456const arr = [1, 2, 3]// const target: number | undefinedconst target = arr.find(it =&gt; it === 3)//Object is possibly 'undefined'target.toFixed(2) 严格模式下，对于可能返回为空的返回值，使用前需要再次判断一次，否则 ts 会报错提示。这个时候 non-null assertion 或许是一个经济的做法，另外可以参考另一篇博文：typescript-类型判断 strictFunctionTypesstrictFunctionTypes 当开启的时候，ts 会严格比较函数的类型，指的是参数类型，不包含返回值类型。(因为一些历史原因，该模式只针对函数变量的语法，而不针对成员函数的语法，具体参考：strictFunctionTypes) 看一个例子： strictFunctionTypes 等于 false 1234567type callFunc = (arg: number | string) =&gt; boolean | objectfunction testFunc1(arg: number): boolean { return arg &gt; 3}// oklet test1: callFunc = testFunc1 strictFunctionTypes 等于 true 12345678type callFunc = (arg: number | string) =&gt; boolean | objectfunction testFunc1(arg: number): boolean { return arg &gt; 3}// Type 'string | number' is not assignable to type 'number'let test1: callFunc = testFunc1 strictFunctionTypes 等于 true 且 函数类型比函数类型变量具体 12345678type callFunc = (arg: number) =&gt; boolean | objectfunction testFunc1(arg: number | string): boolean { return arg &gt; 3}// oklet test1: callFunc = testFunc1 函数参数类型：number | string。函数类型变量参数：number. strictBindCallApplystrictBindCallApply 顾名思义，这个配置项主要针对的就是 javascript 内置的三个方法：call、apply、bind。 strictBindCallApply 等于 false 123456function test(a: number) { //...}// oktest.apply(null, [false]) 函数预期的是 number 类型，传一个 boolean 绕过了检查 strictBindCallApply 等于 true 123456function test(a: number) { //...}// Type 'false' is not assignable to type 'number'test.apply(null, [false]) strictBindCallApply 等于 true, 目标参数类型放宽 12345function test(a: number | boolean) { //...}// oktest.apply(null, [false]) strictPropertyInitializationstrictPropertyInitialization 主要针对成员变量的初始化问题，对于非可选的成员变量没有初始化则报错。 看一个例子： 1234567891011121314151617class A { // Property 'prop' has no initializer and is not definitely assigned in the constructor prop: string}class B { // ok prop: string constructor() { this.prop = \"hello\" }}class C { // ok, 等于 prop: string | undefined prop!: string} 使用的时候需要判断变量是否等于 undefined。 这个时候 non-null assertion 或许是一个经济的做法，另外可以参考另一篇博文：typescript-类型判断 noImplicitThisnoImplicitThis 同 noImplicitAny，不过针对的是 this。如果 this 被推断成 any 类型则报错。 看个例子： 1234567891011class Base { width = 3 height = 4 getArea() { return function () { // 'this' implicitly has type 'any' because it does not have a type annotation return this.width * this.height } }} 修复： 1234567891011class Base { width = 3 height = 4 getArea() { return () =&gt; { // ok return this.width * this.height } }} 把普通函数转换成箭头函数的写法，ts 能正确推断出 this 的类型。 alwaysStrictalwaysStrict 开启该模式之后，编译输出的 js 文件开启 strict mode 模式。具体参考 js-strict-mode 看个例子： alwaysStrict 等于 false 12345// xx.tsconsole.log('hello world')// xx.jsconsole.log('hello world'); alwaysStrict 等于 true 123456// yy.tsconsole.log('hello world')// yy.js\"use strict\";console.log('hello world'); 总结 详细分析了 ts 严格模式的各项配置以及适用的场景： noImplicitAny 适用于推断 any 类型的变量错误 noImplicitThis推断 any 类型的 this 错误 strictNullChecks 用于区分 undefined 和 null 以及其它变量类型 strictFunctionTypes 针对的是函数类型变量参数问题 strictBindCallApply 关注 bind、call、apply 三个方法调用的参数问题 strictPropertyInitialization 关注类成员变量的初始化问题 alwaysStrict 控制编译输出的 js 文件是否要开启严格模式 如果不能启用全部的配置项（通过 strict），那么也应该尽可能多的开启配置项。 参考Strict_Type_Checking_Options_6173 typescript-类型判断","link":"/2020/04/06/typescript-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"},{"title":"从 typescript 的角度学习 React 的基本概念","text":"React 开发过程中有几个绕不开的基本概念，如： ReactElement Component JSX ReactNode ReactElementReactElement 可能是 React 中最重要的概念。其定义为： 一个不可变的对象(immutable object)，该对象决定了最终呈现的页面形态。ReactElement 不同于 HTML Dom Element，ReactElement 用于构建虚拟 Dom (Virtual Dom)。 ReactElement 用于构建 Virtual Dom ，那为什么需要虚拟 Virtual Dom 呢？主要以下几个原因： 1、传统的 Dom 操作比较耗时，Dom 操作比 javascript 操作要慢。操作 html dom 的时候，会有比较多的没有必要的更新动作。譬如：假设有一个列表，包含 10 个列表项。当对其中某一个项操作的时候，会导致整个列表重新构建。 2、Virtual Dom 这一抽象层，把 UI 的“描述” 和 UI 界面最终的展示分离，使得 React 具备构建跨平台的视图的能力，如：react-native、react-dom 等。 ReactElement 类型定义从 @types/react 包内可以看到 ReactElement 的类型定义： 12345interface ReactElement&lt;P = any, T extends string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;&gt; { type: T; props: P; key: Key | null; } type 的定义表示该 ReactElement 可能描述的是一个 HTML Dom Element （string 类型），或者是用户自定义的组件（通过 JSXElementConstructor 构建）。 props 表示该 ReactElement 的属性。 key 是一个可选的属性，主要用在构建ReactElement 列表的时候，方便在 React 做 reconciliation 的时候，分辨出哪些项发生了变更。key 有两个要求点： 1、在相邻的列表项之间唯一2、列表项的 key 不会因为多次渲染而发生改变 ReactElement 的构建ReactElement 有三种方式构建： 1、React.createElement 1var element = React.createElement('div', { className: 'div-wrapper' }, \"helloworld\") createElement 接受三个参数，分别表示 type、props、children，其中第二、三个参数都是可选参数。 2、React.createFactory createFactory 是一个工具函数其作用等价于： 123function createFactory(type) { return React.createElement.bind(null, type)} 3、JSX JSX 具备 js 的灵活表现能力，是创建 ReactElement 的语法糖。JSX 构建出来的元素是 JSX.Element 的类型，其定义： 12345declare global { namespace JSX { interface Element extends React.ReactElement&lt;any, any&gt; { } }} 可以看出： JSX.Element 等于 React.ReactElement&lt;any, any&gt; 全局的作用域类型有 JSX 类型默认的定义（可以使用自己的方式定义 JSX，如果有需要的话），等价于 React.Element。 使用 babel 插件，可以把 jsx 的语法编译成 createElement 的形式： 1const a = &lt;div className=\"div-wrapper\"&gt;helloworld&lt;/div&gt; 输出： 1234\"use strict\";const a = /*#__PURE__*/React.createElement(\"div\", { className: \"div-wrapper\"}, \"helloworld\"); ComponentComponent 的定义：ReactElement 用于构建 Virtual Dom，而 Component 用于构建 ReactElement。Component 接受 props 作为参数，返回 ReactElement 作为结果。 Component 分类ReactElement 的 type 有两种类型：string | JSXElementConstructor&lt;any&gt;。JSXElementConstructor 的定义： 123type JSXElementConstructor&lt;P&gt; = | ((props: P) =&gt; ReactElement | null) | (new (props: P) =&gt; Component&lt;P, any&gt;); 从定义可以看出，ReactElement 的构造器可能是两种类型： 1、函数组件1(props: P) =&gt; ReactElement | null) 2、类组件1(new (props: P) =&gt; Component&lt;P, any&gt;) Pure Component vs Stateless Component相较于普通的 Component， Pure Component 主要针对 Class Component 来说。Pure Component 通过定义 shouldComponentUpdate 方法来避免组件不必要的 rerender 从而提高性能。 Stateless Component 主要针对 Function Component 来说。该组件等同于一个纯函数，没有内部状态，没有副作用（side effects）。 ReactNodeReactNode 的定义： 1234567type ReactText = string | number;type ReactChild = ReactElement | ReactText;interface ReactNodeArray extends Array&lt;ReactNode&gt; {}type ReactFragment = {} | ReactNodeArray;type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; 在 React 系统中，有两个地方用到了 ReactNode，一个是 类组件 的 render 函数： 12345class Component&lt;P, S&gt; { //... render(): ReactNode; //...} 另外一个是 children 的定义： 1type PropsWithChildren&lt;P&gt; = P &amp; { children?: ReactNode }; 为什么 Function Component 的返回值不是一个 ReactNode 呢？ Function Component 的类型定义： 1234567interface FunctionComponent&lt;P = {}&gt; { (props: PropsWithChildren&lt;P&gt;, context?: any): ReactElement | null; propTypes?: WeakValidationMap&lt;P&gt;; contextTypes?: ValidationMap&lt;any&gt;; defaultProps?: Partial&lt;P&gt;; displayName?: string;} 返回值是：ReactElement | null，这可能是历史原因，理论上，Function Component 和 Class Component 的 render 具有相同的返回值类型 根据 React 官方的定义，合法的 render 返回值： 12type ComponentReturnType = ReactElement | Array&lt;ComponentReturnType&gt; | string | number | boolean | null // Note: undefined 是非法的 总结： Class Component 返回 ReactNode 是一种比 React 要求更加松散的约定Function Component 返回 ReactElement | null 则比 React 要求的更加严苛 参考 react-terminology.md react-glossary when-to-use-jsx-element-vs-reactnode-vs-reactelement react-virtual-dom stateless-component-vs-pure-component react-components-elements-and-instances","link":"/2020/07/29/%E4%BB%8E-typescript-%E7%9A%84%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0-React-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"观察者模式 vs 发布/订阅","text":"背景观察者模式和发布/订阅模式，属于基于事件的编程范式的两种使用广泛的实现。这里尝试对两种模式做简要的剖析。 观察者模式观察者模式在”4 人帮”设计模式一书中归类为对象行为模式。在 wikipedia 文章中，定义如下： 在这种模式中，一个目标对象（被观察者）管理所有的依赖于它的对象（观察者），并且在它本身的状态发生变化的时候主动发出通知。这通常通过调用观察者提供的某个函数来实现。 通过观察者模式的定义看出，其主要包含两个对象： 被观察者 观察者 首先来实现一个基础的 typescript 版本： 123456789101112131415161718192021222324252627interface INotify { notify: (...args: any[]) =&gt; void}class Target { observers: INotify[] = [] observe&lt;T extends INotify&gt;(observer: T) { this.observers.push(observer) } onChange(...args: any[]) { this.observers.forEach(it =&gt; it.notify(...args)) }}class Foo implements INotify { notify(...args: any[]) { console.log('Foo receive notify') }}class Bar implements INotify { notify(...args: any[]) { console.log('Bar receive notify') }} Target 表示目标对象，即：被观察者。其维护了一个观察者对象的列表。当其自身状态发生变化的时候(onChange)，通过 notify 函数通知观察者对象（所有的观察者必须实现 INotify 接口） 观察者模式的实现简单明了，但是它主要存在以下两个问题： 耦合问题 每个观察者必须和被观察对象绑定在一起，这引入了耦合。 性能问题 在最基本的实现中观察对象必须同步地通知观察者。这可能会导致性能瓶颈。 发布/订阅模式发布/订阅模式 定义如下： 在 发布/订阅模式 有 发布者 和 订阅者，它们通过信道链接到一起。 发布/订阅模式完成了观察者模式的基本功能的同时，也解决了观察者模式的两个主要的缺陷。其主要包含以下三个基本概念： 信道 每个信道都有一个名字，发布者可以往某个信道中发布消息，订阅者可以订阅一个或者多个信道的消息。在这里 信道 是一个更加抽象的概念，它一般在其他代码库中实现。可以是： 1、进程 2、分布式基础设施 3、第三方库 … 信道的实现细节对用户代码来说是隐藏的。 发布者 顾名思义就是消息的发布者，它往信道中投递消息。 订阅者 订阅者可以订阅它感兴趣的一个或者多个信道的消息。 发布/订阅模式的主要优点有： 1、发布者和订阅者的通信是在用户代码之外处理的，通过信道降低了发布者和订阅者的耦合性2、不同的信道的实现中，发布者和订阅者的通信可能是异步的，实现比较灵活 当然 发布/订阅模式 也有其缺点： 比较难以查看当前系统中有哪些发布者、订阅者以及事件的处理情况，这需要借助额外的工具来做 profile 目前很多平台都有内置的发布订阅的实现，譬如：Node.js 内置的 events 模块包含了发布/订阅模式的简单实现： 123456789var EventEmitter = require('events').EventEmitter; var event = new EventEmitter(); event.on('some_event', function() { console.log('some_event 事件触发'); }); setTimeout(function() { event.emit('some_event'); }, 1000); EventEmitter 仅限于单个进程内的通信。 其他基础设施例如：Redis 也提供了发布/订阅模式的实现。 参考Publish–subscribe_patternObserver_patternevents_class_eventemitterredis-pubsub","link":"/2020/08/16/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-vs-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85/"},{"title":"Typescript 典型的类型问题","text":"背景现在越来越多的项目采用 typescript 作为主要的开发语言。在日常开发过程中，经常遇到几个常见的类型问题，在此做一个记录。 过滤数组空数据假设当前项目中有如下代码片段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263type FieldType = 'text' | 'long-text'interface FieldBase { type: FieldType specifics?: { queryable?: boolean updatable?: boolean }}export interface FieldText extends FieldBase { type: 'text'}export interface FieldTextArea extends FieldBase { type: 'long-text'}export type FieldItem = FieldTextArea | FieldTextinterface FormItem { type: string disabled?: boolean dataIndex: string}// 通过 `fieldItems` parse 得到 FormItem[]function parseFormItems(field: FieldItem[]): FormItem[] { // 报错：Type 'undefined' is not assignable to type 'FormItem' return field.map(it =&gt; { it.specifics = { ...it.specifics, ...defaultSpefics} switch (it.type) { case 'text': case 'long-text': { return parseTextFormItem(it) } default: { throw new Error(\"invalid field type: \" + it) } } })}// 通过 `fieldItem` parse 得到 FormItemfunction parseTextFormItem(field: FieldItem): FormItem | undefined { if (!field.specifics) { return undefined } if (field.name === 'xxx') { return { type: 'string', disabled: false, dataIndex: '2' } } return { type: 'string', disabled: false, dataIndex: '1' }} 上面的例子中，ts 报错了（在 tsconfig 开启了strictNullChecks的前提下）：Type ‘undefined’ is not assignable to type ‘FormItem’ 因为 parseTextFormItem 的返回值类型是FormItem | undefined，而 undefined 不能赋值给 FormItem。我们需要把 undefined 类型过滤掉。在 typescript 语言环境中，这种方式叫 type-guard 。需要优化一下 parseFormItems 的实现： 123456function parseFormItems(field: FieldItem[]): FormItem[] { return field.map(it =&gt; { //... // 过滤“空”值 }).filter((it): it is FormItem =&gt; it != null)} 把属性标记为 Required在上面的例子，其中有一段代码是没有作用的： 1234567//...function parseTextFormItem(field: FieldItem): FormItem | undefined { if (!field.specifics) { return undefined } //...} 因为 parseFormItems 内部已经把 specifics 设置了默认值：123//...it.specifics = { ...it.specifics, ...defaultSpefics}//... 所以在 parseFormItems 内部其实是不需要做这个条件判断的。这个时候需要变更一下函数的参数类型，把 specifics 设置为 Required。 我们需要一个把一个类型的某个属性设置为 Required 的工具类型。 typescript 没有内置可以直接使用的相关类型，但是可以通过它提供的其他类型拼凑出来： 1type RequiredProperty&lt;T, K&gt; = Exclude&lt;T, K&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt; 改写 parseTextFormItem: 123function parseTextFormItem(field: RequiredProperty&lt;FieldItem, 'specifics'&gt;): FormItem | undefined { //...} 注意： 在实际的测试过程中，发现低于 3.5 版本的 typescript ，上面的方法不会生效，或许跟 ts-3.5 新增的特性有关。 另外，推荐使用 ts-essentials，它提供了强大的类型工具，满足日常开发的绝大多数场景。 访问/设置对象的属性值刚学习 typescrept 的时候，经常遇到下面的错误提示： Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index type ‘XX’. No index signature with a parameter of type ‘string’ was found on type ‘XX’ 观察错误提示，其表示：XX 类型没有 index signature(索引签名)。这类错误一般出现在当我们需要动态访问对象的某个属性，或者给动态对象属性赋值的时候。看个例子： 12345678910111213141516interface ISomeObject { firstKey: string; secondKey: string; thirdKey: string;}let someObject: ISomeObject = { firstKey: 'firstValue', secondKey: 'secondValue', thirdKey: 'thirdValue'};let key: string = 'secondKey';// 报错let secondValue: string = someObject[key]; 需要把 ISomeObject 类型改一下，给该类型加上 index signature： 123456interface ISomeObject { firstKey: string; secondKey: string; thirdKey: string; [key: string]: any} 再看一个给对象动态赋值的例子： 1234567function clone&lt;T extends {}&gt;(obj: T): T { return Object.keys(obj).reduce((acc, cur) =&gt; { // 报错：Element implicitly has an 'any' type because type '{}' has no index signature acc[cur] = obj[cur] return acc }, {} as T)} 需要把类型约束：T extends {} 修改一下，改成：T extends {[k: string]: any} 即可，表示该类型满足 index signature。 当 typescript 升级到 3.5 及以上的时候，情况又有所不同。因为 T extends {[k: string]: any} 原则上并不是严格意义限制了 T 满足 index signature。这个时候需要做一点修正： 1234567function clone&lt;T extends {[k: string]: any}&gt;(obj: T): T { const result = Object.keys(obj).reduce((acc, cur) =&gt; { acc[cur] = obj[cur] return acc }, {} as {[k: string]: any}) return result as T} typescript 3.5 对于 index type 校验问题更多的讨论，参考：TypeScript/issues/31661。 Object vs object vs {} vs {[key: string]: any}{} 和 Object{} 和 Object 在 typescript 环境下是等价的，任何类型的值都能赋值给该类型的变量： 12345678var p: {};p = { prop: 0 }; // OKp = []; // OKp = 42; // OKp = \"string\"; // OKp = false; // OKp = null; // Errorp = undefined; // Error objectobject 类型由 typescript 2.2 引入。其约束不能把原始类型赋值给该类型的数据： 123456789declare function create(o: object | null): void;create({ prop: 0 }); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Errorcreate(false); // Errorcreate(undefined); // Error {[key: string]: any}{[key: string]: any} 是 index-signatures 的类型，但是有一些奇怪的值（如：数组）也能绕过类型检查： 12345678var q: { [key: string]: any };q = { prop: 0 }; // OKq = []; // OKq = 42; // Errorq = \"string\"; // Errorq = false; // Errorq = null; // Errorq = undefined; // Error 可以看到 {[key: string]: any} 类型约等于：object 类型，或许在某些时候，{[key: string]: string} 是更好的选择。 对比几种类型： 1、{} 等价于 Object 限制最为宽松，可以赋值任何对象、数组、原始类型值。2、object 约等于：{[key: string]: any} ，不能赋值原始类型值，但是能赋值对象、数组。{[key: string]: any} 还起到了 index signature 的作用3、{ [key: string]: string } 是更具体的类型，其不能赋值：数组、原始类型值、以及属性值不是字符串的对象。 参考index-types-and-index-signaturestype-guards-and-differentiating-typests-essentialsdifference-between-object-and-in-typescript","link":"/2020/08/23/Typescript-%E5%85%B8%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98/"},{"title":"深入理解 Mobx Computed","text":"背景computed 又名计算属性，是 Mobx 最重要的特性之一。其目的在于：根据某一个或者多个属性计算得到新的属性，提供给消费方。 注：被 computed 依赖的属性本身需要是 observable 的，可以是直接通过 observable.xx 定义的属性，也可以是另外一个 computed 属性。 使用 computed 主要有两个优势： 尽量减少可修改的状态属性 a、可修改的属性越多意味着程序需要维护的状态越多，间接提高了程序的复杂度，增加维护成本。b、避免了无意间修改了某个属性而导致 BUG，提升程序的健壮性。 computed 最大程度的提升了程序性能 computed 缓存计算结果，避免不必要的复杂计算，下面会慢慢分析。 基于以上两点，日常开发过程中原则是：能使用 computed 的地方应该尽量使用 computed。 基本使用来定义一个订单的 Store 1234567891011121314class Order { @observable price = 3; @observable amount = 1; @computed get total() { console.log(\"calc total\"); return this.price * this.amount; }}const inst = new Order();// console: calc total// console: 3autorun(() =&gt; console.log(inst.total)); 以上就是 computed 的基本使用姿势： 基于某些个 observable 计算得到新的属性值 通过 reaction 来消费 computed 属性值 当修改 computed 依赖的 observable 属性时，computed 会再次执行，得到新的值，并缓存之。 123456//...const inst = new Order();autorun(() =&gt; console.log(inst.total))// console: calc total// console: 12inst.amount = 4 注意：如果 computed 还依赖了某些非 observable 属性，而属性的变更并不会导致 computed 重新执行： 123456789101112131415161718class Order { @observable price = 3; @observable amount = 1; x = 2 @computed get total() { console.log(\"calc total\"); return this.price * this.amount * this.x; }}const inst = new Order();// console: calc total// console: 6autorun(() =&gt; console.log(inst.total))// 没有任何输出inst.x = 4 computed vs autorun通过上面的了解，computed 感觉跟 autorun 很像。都用于响应某些 observable 属性的变化。其主要差异有以下几点： computed 主要用于基于现有属性生成新的属性值，供其他 observer（如：autorun、reaction、observer 等） 消费。 autorun 基于某些 observable 属性的变化作出一些行为，可能是发送请求也可能是打印日志等等 autorun 需要使用者自己 dispose，而 computed 由mobx内部负责回收，如果 computed 消费者不存在的时候，computed 会处于 Suspend 状态，即：computed 依赖的属性变化也不会重新计算生成新的属性值。（当开启 keepLive 的时候情况会有所不同，下面会说明） 进阶避免不必要的重复计算使用 computed 有一个比较大的误区在于，绕过 reaction 直接使用 computed 属性： 123456789101112//...const inst = new Order();// console: calc total// console: 3console.log(inst.total)// console: calc total// console: 3console.log(inst.total)// console: calc total// console: 3console.log(inst.total) console 引用了 computed 三次，重复计算了三次。所以当某些计算量比较大的 computed 计算了太多次，那么就要看看使用姿势是不是不对了。庆幸的是，mobx 有一个配置来警告这种行为： 123configure({ computedRequiresReaction: true}) 或者： 1234567//...@computed({ requiresReaction: true })get total() { console.log(\"calc total\"); return this.price * this.amount;}//... Computed KeepAlive通过上面的例子看到，computed 不适合被直接使用，因为会有重复的计算。但是为了方便想要直接使用该怎么办呢？一种办法是把 computed value 进行 reaction 化、另外一种方式是：keepAlive。keepAlive 的作用在于避免过多的计算，同时又能获取最新的值（对比不使用 keepAlive），而且经过 mobx 优化具有延迟计算的能力（对比 autorun）。即：在 computed keepAlive 在消费之前修改 observable 的值，并不会导致重新计算，看两个例子。 computed with keepAlive123456789101112131415161718class Order { @observable price = 3; @observable amount = 1; @computed({ keepAlive: true }) get total() { console.log(\"calc total\"); return this.price * this.amount; }}const inst = new Order();// console: 3console.log(inst.total)// console: 3console.log(inst.total)// console: 3console.log(inst.total) 没有重复的 calc total computed defer compute 1234567891011121314151617181920212223class Order { @observable price = 3; @observable amount = 1; @computed({ keepAlive: true }) get total() { console.log(\"calc total\"); return this.price * this.amount; }}const inst = new Order();inst.price = 4inst.price = 5//console: calc total//console: 5console.log(inst.total)//console: 5console.log(inst.total)//console: 5console.log(inst.total) 第一次 console 的时候再计算 computed 属性值。 使用 keepAlive 有一个缺陷是容易导致内存泄露，因为它无法被 mobx 回收，又必须时刻保持 alive 的状态。详情参考：why-does-mobxs-keepalive-cause-a-memory-leak Computed ComparerComputed 还有一个比较重要的属性：equals。equals 用来指定一个函数用于比较两次计算得出的 computed value 是否相等。如果不相等，则消费 computed 的 reaction 会响应。看一个例子： 1234567891011121314151617181920class Order { //... @computed({ equals: () =&gt; true }) get total() { console.log(\"calc total\"); return this.price * this.amount; }}const inst = new Order();//console: calc total//console: 3autorun(() =&gt; console.log(inst.total))//console: calc totalinst.price = 4//console: calc totalinst.price = 5 当 observable 变化的时候，触发了 computed，但是自定义比较器始终返回 true，导致 mobx 认为前后的值没有变化，所以 autorun 没有被响应。 mobx 内置了 4 种比较器：1234567891011121314151617181920212223//...function identityComparer(a: any, b: any): boolean { return a === b}function structuralComparer(a: any, b: any): boolean { return deepEqual(a, b)}function shallowComparer(a: any, b: any): boolean { return deepEqual(a, b, 1)}function defaultComparer(a: any, b: any): boolean { return Object.is(a, b)}export const comparer = { identity: identityComparer, structural: structuralComparer, default: defaultComparer default: defaultComparer, shallow: shallowComparer} 默认使用 Object.is 判断函数。多说一句，在 react 内默认使用的比较函数是：shallowEqual，也依赖了 Object.is 譬如：shouldComponentUpdate、memo 等。比较器本身没啥可说的。重点来看看 shallowComparer、structuralComparer 的使用场景。 首先来看看 structuralComparer 的使用场景： 12345678910111213141516171819class Sum { @observable.ref val1 = { v: 1 }; @observable.ref val2 = { v: 2 }; @computed get total() { console.log(\"calc total\"); return { val1: this.val1, val2: this.val2 }; }}const inst = new Sum();// console: xxautorun(() =&gt; console.table(inst.total));// console: xxinst.val2 = { v: 2 }; 因为 val2 的引用变了，所以导致触发了 total computed，但是我们看到 val2.v 实际上还是等于 2。这个时候就可以用 structuralComparer： 1234567891011121314151617 //... @computed({ equals: comparer.structural }) get total() { console.log(\"calc total\"); // atom.reportObserved(); return { val1: this.val1, val2: this.val2 }; } //...// console: calc total// console: xxautorun(() =&gt; console.table(inst.total));// console: calc totalinst.val2 = { v: 2 }; 可以看到，虽然设置 val2 的时候 total computed 被重新计算了，但是由于深度比较后发现计算值跟前一次并没有差别，所以 autorun 没有被响应。 shallowComparer 的例子比较困难，因为 mobx 有内置的优化，导致以下写法不会重新计算属性： 1234567891011121314151617181920class Sum { @observable.ref val1 = 1; @observable.ref val2 = 2; @computed get total() { console.log(\"calc total\"); return { val1: this.val1, val2: this.val2 }; } }const inst = new Sum()// calc total// console: xxautorun(() =&gt; console.log(inst.total));// 没有 calc totalinst.val2 = 2 由于 mobx 内置优化的缘故，对于：inst.val2 = 2 并没有引起重新的 calc computed，也就没法验证 shallow comparer 的作用了。需要一个办法绕过这个优化：那就是：Atom。 Atom 是 Mobx 的基础设施，多数 observable 特性都是基于 atom 来实现的。Atom 主要使用在，当目前提供的 reaction、observable 不能满足需求的时候，例如需要对 stream 信息做响应式计算。 先定义一个 Atom: 1const atom = createAtom(\"test-shallowComparer\"); 对属性劫持，强制触发变更通知： 1234567891011121314151617181920212223242526272829303132333435//...@computed({ equals: comparer.shallowComparer })get total() { console.log(\"calc total\"); return { val1: this.val1, val2: this.val2 };} // ...const inst = new Sum();let val2 = inst.val2;Object.defineProperty(inst, \"val2\", { configurable: true, enumerable: true, get() { atom.reportObserved(); return val2; }, set(v) { val2 = v; atom.reportChanged(); }});// console: calc total// console: xxautorun(() =&gt; console.table(inst.total));// console: calc totalinst.val2 = 2// console: calc totalinst.val2 = 2 通过劫持 val2 属性，当第一次读取 val2 值信息的时候都记录一个观察者，当设置 val2 属性值的时候通知观察者。因为此时由于 shallowComparer 两个 total 的值实际上是相等的。所以只触发了计算，没有触发 autorun。 总结 日常开发应该尽可能多的使用 computed 减少 mutable 状态的使用，提升代码的健壮性、降低复杂度 computed 有两个前置条件：1、依赖 observable 属性的变化。2、被 reaction 消费（如果有意减少不必要的计算） computed 和 autorun 有很多相识之处，computed 主要用于生成一个新的属性值供消费，autorun 用于基于 observable 做某些操作。computed 会被 mobx 优化，也可以根据需要调整 comparer 函数。 解决在非 reaction 内使用 computed 导致重复计算的问题有两个方式：reaction 转换如 autorun、keepAlive，keepAlive 的好处是：延迟计算，也不需要额外的转换，坏处是容易导致内存泄漏，而 reaction 的方式容易 dispose","link":"/2020/05/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Mobx-Computed/"},{"title":"tsconfig 必知必会","text":"背景tsconfig.json 是 ts 项目的配置文件，用于项目的编译。归纳总结，主要包含了几块内容： 项目的安装和初始化 编译输入文件 编译输出配置 基本编译选项 对 js 的支持 类型检查和 lint 配置 模块解析配置 其他配置 本文尝试分析日常开发过程中必须熟悉的 tsconfig 相关配置知识。 安装编译工具tsc 作为 ts 项目文件的编译器，需要先安装好。 npm i -g typescript 如果希望安装到现有的某个项目下，可以使用： npm install typescript –save-dev 安装完毕之后会有一个 tsc 的命令。 初始化配置tsc 有个 init 的指令，执行命令：1tsc --init 在当前目录下生成一个 tsconfig.json, 如： 123456789101112{ \"compilerOptions\": { /* Basic Options */ \"target\": \"es5\", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */ \"module\": \"commonjs\", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */ \"strict\": true, /* Enable all strict type-checking options. */ \"esModuleInterop\": true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */ \"forceConsistentCasingInFileNames\": true /* Disallow inconsistently-cased references to the same file. */ //... 其他配置 }} 默认生成的配置文件只包含了编译相关的配置， 因为对于输入文件和输出都有默认的行为。 输入文件 tsconfig 默认如果不配置输入文件，则会加载当前项目下所有的以：.ts、.tsx 、.d.ts 结尾的文件。如果配置了 allowJs 还会加载 .js、.jsx 文件。 tsconfig 内跟输入文件有关的主要包含三个配置：files、include、exclude。files 和 include 用于指定输入文件，exclude 用于指定需要排除的输入文件。需要注意的是，如果 exclude 内指定的文件，在实际的编译过程中还是被引用 (import) 了，那么该文件还是会参与编译。 files 和 include 作用并不重复，其主要区别在于： includes 能使用 glob 通配符，而 files 只能包含某个文件的相对路径 files 指定的文件不能被 exclude 排除，而 include 则可以 来看一个 Demo： 当前目录结构如下： 12345678910.├── package.json├── src│ ├── dir│ │ ├── foo.js│ │ └── foo.ts│ ├── dir2│ │ └── bar.ts│ └── index.ts└── tsconfig.json tsconfig.json 配置： 123456789{ \"include\": [ \"src/**/*.*\" ], \"exclude\": [ \"src/dir/*.*\" ], //... 其他配置} 编译文件： tsc –outDir ./dist 生成文件： 12345➜ dist tree ..├── dir2│ └── bar.js└── index.js 因为 dir 内的文件被排除了，所以没有参与编译 修改配置，强制包含 dir 内的文件： 1234{ \"files\": [\"src/dir/foo.ts\"], //...其他配置} 生成结果： 1234567➜ dist tree ..├── dir│ └── foo.js├── dir2│ └── bar.js└── index.js 注意： 1、虽然 tsc 有文件后缀的加载规则，但是可以通过 include pattern 只包含指定后缀的文件2、虽然 tsc 会编译 tsx 后缀的文件（通过 allowJs还会加载 jsx）。但是如果想在文件中使用 jsx 语法，那么还必须开启 jsx 配置项（见下文）。 输出文件输出的文件配置主要包含两个选项：outFile、outDir。 outFile 用于指定输出的文件，该指令会把输入文件合并成单个文件，文件顺序取决余代码加载的顺序。outDir 不会合并文件，会把文件按照原位置输出。需要注意的是 outFile 对于 module 有要求，当开启 outFile 的时候，module 指定的模块规范必须支持单文件的模式。只有 “AMD” 和 “System”能和 outFile 一起使用。 看个 demo: tsconfig: 1234567{\"compilerOptions\": { \"module\": \"amd\", \"outFile\": \"./aa.js\"},//...其他配置} 编译输出： 1234567891011\"use strict\";define(\"dir/foo\", [\"require\", \"exports\"], function (require, exports) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); exports.foo = 123;});define(\"dir2/bar\", [\"require\", \"exports\"], function (require, exports) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); exports.bar = 456;}); 可以看到多个源文件被合并成单个文件输出。 基本编译配置 incremental incremental 表示增量的意思，作用在于减少编译的时间，每次编译会保存编译信息，下次编译的时候加载本次编译信息，只做增量的编译，从而减少编译时间。还有一个配置项叫：tsBuildInfoFile 用于指定保存编译信息的文件路径。 target 指定编译输出文件的 ECMAScript 版本信息，可能的值有：ES3、ES5 、ESNEXT 等。 ESNEXT 是一个动态的概念，表示截止目前为止最新的标准 ECMAScript 特性，外加进入 stag-3 及以上阶段的特性。 module module 指定输出代码的模块格式，支持的模块有： 1 commonjs2 es module3 amd4 umd5 systemjs6 none 关于模块的详细说明，参考 modules。 lib lib 给 ts 编译的时候提供默认的类型信息，主要指的是内置的语言 API信息。如果 lib 选项没有配置，默认的行为： 当 target 等于 es5 的时候，lib 等于 [DOM,ES5,ScriptHost] 当 target 等于 es6 的时候，lib 等于[DOM,ES6,DOM.Iterable,ScriptHost] 当我们的项目中需要使用某些语言特性，但是不在默认的 lib 列表内，那么就需要手动指定。需要注意的是 tsc 不会帮我们做 polyfill 的事情，这是有意为之。即：指定 lib 只能绕过类型检查，但是 polyfill 的事情需要开发者自己完成。 Provide additional runtime functionality or libraries. Instead, use TypeScript to describe existing libraries 简而言之，tsc 提供了某种 syntax transform(语法转换)的能力，如转译箭头函数的功能，但是不做 polyfill 的事情。这个需要开发者自行完成。 看个 demo: index.ts123// 类型“(number | number[])[]”上不存在属性“flat”const arr = [1,2,3, [4]].flat() 把 ES2019 加上： 1234567{ //... \"compilerOptions\": { \"lib\": [\"DOM\", \"ES2015\", \"ES2019\"], } //...} 警告就消失了。 关于 polyfill 和 transplier 的差异请参考：babel-研究-polyfill-vs-transpiler，以及：what-is-the-difference-between-polyfill-and-transpiler。 jsx typescript 支持 jsx 的语法，其包含 jsx、jsx-factory 两个配置。 jsx 有三个可选值： preserve tsc 在编译的时候不对 jsx 语法进行转换，原样保存到输出文件中。对 jsx 语法的转换留给 babel-plugin 等其他工具。该配置下，输出文件是一个 .jsx，另：这是默认的配置 react 把 jsx 语法转化为 React.createElement。参考 从-typescript-的角度学习-React-的基本概念，jsx 其实是 createElement 的语法糖。该配置下，输出文件是一个 .js 文件 react-native 同 preserve 但是输出文件是一个 .js 文件。 注意： 因为会跟 jsx 语法冲突，jsx/tsx 文件中不能使用 &lt;foo&gt; 来做类型断言 jsxFactory 该配置配合 jsx: react 替换默认的 React.createElement，比如 preact 的实现等。 其他信息，参考：handbook-jsx 对 js 的支持 allowJs 默认的 tsc 编译只会加载 ts 和 tsx 文件，如果还需要编译 js 、或 jsx，则需要把该选项打开。 checkJs checkJs 跟 allowJs 配合使用，默认 tsc 不对参与编译的 js 文件做类型检查，可以通过该配置项目，启用检查。 类型检查和 lintlint 检查配置 noUnusedLocals 针对未使用的局部变量 lint 告警 noUnusedParameters 针对未使用的函数参数 lint 告警 noImplicitReturns 针对需要返回值但是没有返回的函数 lint 告警 noFallthroughCasesInSwitch 针对没有 default case 的 switch 告警 tsc 也支持部分 lint 检查能力，几个配置项目都比较直观。 类型检查配置ts 提供了完整的类型检查机制，参考：typescript-严格模式。 模块解析配置相对路径加载 vs 非相对路径加载相对路径加载定义，指的是以以下几个字符开始的加载目录： 1、/2、./3、../ 所有其他类型的 import 路径都被认为是非相对路径的加载例如： import jquery from 'jquery' 所有通过相对路径加载的模块，用户必须保证所在模块必须存在，不会走 baseUrl、path mapping、以及环境模块声明(ambient module declaration)。 模块解析策略moduleResolution 配置项目用于指定模块的加载策略，typescript 模块解析分为两种策略： 1、classic2、node 如果用户没有配置 moduleResolution，默认当 module 等于：AMD | System | ES2015 的时候，使用 classic 策略，其他 module 使用 node 策略。 classic 策略： 1、相对模块 假设当前文件：/root/src/folder/A.ts 有模块加载语句： import { b } from &quot;./moduleB&quot; 那么 tsc 将会查找如下文件： a、/root/src/folder/moduleB.tsb、/root/src/folder/moduleB.d.ts 2、非相对模块 假设当前文件：/root/src/folder/A.ts 有模块加载语句： import { b } from &quot;moduleB&quot; 那么 tsc 将会按照如下顺序查找模块： a、/root/src/folder/moduleB.tsb、/root/src/folder/moduleB.d.tsc、/root/src/moduleB.tsd、/root/src/moduleB.d.tse、/root/moduleB.tsf、/root/moduleB.d.tsg、/moduleB.tsh、/moduleB.d.ts node 策略 这里简要说说 node.js 如何做模块加载的，标准的 node.js 模块加载使用 require 函数加载模块。 假设有 /root/src/moduleA.js 文件包含一个 require 语句： var x = require(&quot;./moduleB&quot;); node.js 将会按照以下顺序查找模块： a、查找 /root/src/moduleB.jsb、如果 /root/src/moduleB 是一个文件夹，文件夹包含 package.json ，package.json 下有个 main 字段指定了具体了文件c、如果 /root/src/moduleB 是一个文件夹，文件夹包含一个 index.js 文件，该文件被认为是这个文件夹的导出模块 假设有 /root/src/moduleA.js 文件包含一个 require 语句：var x = require(&quot;moduleB&quot;); node.js 将会按照以下顺序查找模块： a、/root/src/node_modules/moduleB.jsb、/root/src/node_modules/moduleB/package.json (如果指定了main字段)c、/root/src/node_modules/moduleB/index.jsd、/root/node_modules/moduleB.jse、/root/node_modules/moduleB/package.json (如果指定了main字段)f、/root/node_modules/moduleB/index.js g、/node_modules/moduleB.jsh、/node_modules/moduleB/package.json (如果指定了main字段)i、/node_modules/moduleB/index.js 完整的过程请参考：modules_loading_from_node_modules_folders。 typescript 版本的 node 加载策略 该模式和 node.js 版本非常相识，不同在于： 1、默认加载: .ts、.tsx、.d.ts 文件（如果配置了 allowJs会加载: .js、.jsx、.d.js）3、查找 package.json 的 types 字段，而不是 main 字段 假设有 /root/src/moduleA.js 文件包含一个 import 语句： import { b } from &quot;./moduleB&quot; tsc 将会按照如下顺序查找模块： a、/root/src/moduleB.tsb、/root/src/moduleB.tsxc、/root/src/moduleB.d.tsd、/root/src/moduleB/package.json (if it specifies a &quot;types&quot; property)e、/root/src/moduleB/index.tsf、/root/src/moduleB/index.tsxg、/root/src/moduleB/index.d.ts 同样的假设有 /root/moduleA.js 文件包含一个 import 语句： import { b } from &quot;moduleB&quot; tsc 将会按照如下顺序查找模块： 1、/root/node_modules/moduleB.ts2、/root/node_modules/moduleB.tsx3、/root/node_modules/moduleB.d.ts4、/root/node_modules/moduleB/package.json (如果指定了types属性)5、/root/node_modules/@types/moduleB.d.ts6、/root/node_modules/moduleB/index.ts7、/root/node_modules/moduleB/index.tsx8、/root/node_modules/moduleB/index.d.ts 9、/node_modules/moduleB.ts10、/node_modules/moduleB.tsx11、/node_modules/moduleB.d.ts12、/node_modules/moduleB/package.json (如果指定了types属性)13、/node_modules/@types/moduleB.d.ts14、/node_modules/moduleB/index.ts15、/node_modules/moduleB/index.tsx16、/node_modules/moduleB/index.d.ts 其他模块解析配置 baseUrl baseUrl 用于告诉编译器去哪里查找模块。当设置 baseUrl 的时候，所有非相对路径模块的模块导入，都被认为相对于 baseUrl 设置的路径。baseUrl 对相对路径的导入没有影响。 Path mappingPath mapping 相对应模块导入的快捷方式，举个例子，假设我们希望 import jquery from 'jquery' 实际导入的是：node_modules/jquery/dist/jquery.slim.min.js，可以这么设置： 12345678{ \"compilerOptions\": { \"baseUrl\": \".\", // 当需要使用 `paths` 时必须设置 \"paths\": { \"jquery\": [\"node_modules/jquery/dist/jquery\"] // 路径相对于 `baseUrl` } }} Virtual Directories(rootDirs) rootDirs 用于把多个不同文件夹内的模块 import 可以像在查找同一个文件夹的模块。编译输出的时候，多个文件夹内的模块，会被合并成单个文件夹。 traceResolution 上面看到了模块解析有时候比较繁琐 traceResolution 是一个方便诊断模块加载问题的语法。它会列出 tsc 执行的时候，模块加载的顺序。 allowSyntheticDefaultImports 当我们加载某个没有 default export 的第三方包的时候，通常的写法如下： 1import * as React from 'react' 开启了 allowSyntheticDefaultImports 的时候，写法可以变成： 1import React from 'react' 需要注意的是，allowSyntheticDefaultImports 只会绕过类型检查，并不会对 tsc 编译出来的 js 代码产生影响。这个时候，需要的是 esModuleInterop 配置项目 esModuleInterop typescript 采用标准的 es modules 标准。但是大量的第三方包采用的是 common.js 的模块规范。 esModuleInterop 配置项为 es module 模块导入 commonjs 模块提供便利。 通常 node.js 模块的导出方式为： 123module.exports = { foo: bar} 没有 export default，所以我们在使用这类包的时候，只能写成： 1import * as React from 'react' 开启 esModuleInterop 配置项目之后，可以写成： 12import React from 'react'console.log(React.Children) tsc 会把上述代码编译成： 1234567\"use strict\";var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod };};Object.defineProperty(exports, \"__esModule\", { value: true });var react_1 = __importDefault(require(\"react\"));console.log(react_1.default.Children); 注意：开启 esModuleInterop 后，自动会开启 allowSyntheticDefaultImports 配置项。 typeRoots typeRoots 配置项主要用于，指定编译的时候，类型主要包含哪些类型什么的文件夹。默认配置为：123./node_modules/@types/,../node_modules/@types/,../../node_modules/@types/ 当项目中有自定义类型文件夹的时候，可以通过该配置项来指定。如： 12345{ \"compilerOptions\": { \"typeRoots\": [\"./typings\", \"node_modules/@types\"] }} types 跟 typeRoots 不同的是，types 指定的是具体的某几个包的类型数组，而 typeRoots 指定某个文件夹，文件下的所有模块都会被包含。 其他配置 importHelpers tsconfig 在开启某些配置项的时候，tsc 在编译输出文件内会插入而外的 helper 代码，如： a、extending classb、spreading arrays or objects(展开语法)c、async 操作 为了避免在每个输出的代码文件都有同样的一份 helper 代码，ts 提供了一个 tslib 包，包含了所有 helper 代码的实现。注意：tslib 需要手动安装。 Source Map 配置 declaration 为编译输出的每个文件都提供一个类型声明文件，描述该文件导出的模块信息。 declarationMap 为每个类型声明文件，都额外生成一份 source map 文件。 参考 tsconfig reference modules module-resolution node.js-modules handbook-jsx","link":"/2020/06/30/tsconfig-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"}],"tags":[{"name":"transition","slug":"transition","link":"/tags/transition/"},{"name":"animation","slug":"animation","link":"/tags/animation/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"cheatsheet","slug":"cheatsheet","link":"/tags/cheatsheet/"},{"name":"propertys","slug":"propertys","link":"/tags/propertys/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"mobx","slug":"mobx","link":"/tags/mobx/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"Quill","slug":"Quill","link":"/tags/Quill/"},{"name":"富文本编辑器","slug":"富文本编辑器","link":"/tags/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"sailsjs","slug":"sailsjs","link":"/tags/sailsjs/"},{"name":"inline block","slug":"inline-block","link":"/tags/inline-block/"},{"name":"AMD","slug":"AMD","link":"/tags/AMD/"},{"name":"CMD","slug":"CMD","link":"/tags/CMD/"},{"name":"commonjs","slug":"commonjs","link":"/tags/commonjs/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"position","slug":"position","link":"/tags/position/"},{"name":"layout","slug":"layout","link":"/tags/layout/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"table","slug":"table","link":"/tags/table/"},{"name":"h5","slug":"h5","link":"/tags/h5/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"benchmark","slug":"benchmark","link":"/tags/benchmark/"},{"name":"vuejs","slug":"vuejs","link":"/tags/vuejs/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"重构","slug":"重构","link":"/tags/%E9%87%8D%E6%9E%84/"},{"name":"password","slug":"password","link":"/tags/password/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"log","slug":"log","link":"/tags/log/"},{"name":"weex","slug":"weex","link":"/tags/weex/"},{"name":"codepush","slug":"codepush","link":"/tags/codepush/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"monitor","slug":"monitor","link":"/tags/monitor/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"rest","slug":"rest","link":"/tags/rest/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"BlockChain","slug":"BlockChain","link":"/tags/BlockChain/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"mixed-content","slug":"mixed-content","link":"/tags/mixed-content/"},{"name":"context","slug":"context","link":"/tags/context/"},{"name":"hooks","slug":"hooks","link":"/tags/hooks/"},{"name":"antd","slug":"antd","link":"/tags/antd/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"babel","slug":"babel","link":"/tags/babel/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"debounce","slug":"debounce","link":"/tags/debounce/"},{"name":"throttle","slug":"throttle","link":"/tags/throttle/"},{"name":"strict-mode","slug":"strict-mode","link":"/tags/strict-mode/"},{"name":"tsconfig","slug":"tsconfig","link":"/tags/tsconfig/"},{"name":"观察者模式","slug":"观察者模式","link":"/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"发布订阅","slug":"发布订阅","link":"/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"},{"name":"computed","slug":"computed","link":"/tags/computed/"}],"categories":[{"name":"web","slug":"web","link":"/categories/web/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"server","slug":"server","link":"/categories/server/"},{"name":"vscode","slug":"vscode","link":"/categories/vscode/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"系统监控","slug":"系统监控","link":"/categories/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"},{"name":"lerning","slug":"lerning","link":"/categories/lerning/"},{"name":"软件开发","slug":"软件开发","link":"/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"Vue源码分析系列文章","slug":"Vue源码分析系列文章","link":"/categories/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"name":"nodejs","slug":"server/nodejs","link":"/categories/server/nodejs/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"mobx","slug":"web/mobx","link":"/categories/web/mobx/"},{"name":"typescript","slug":"web/typescript","link":"/categories/web/typescript/"},{"name":"react","slug":"web/mobx/react","link":"/categories/web/mobx/react/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"mobx","slug":"mobx","link":"/categories/mobx/"},{"name":"statemanager","slug":"mobx/statemanager","link":"/categories/mobx/statemanager/"}]}